<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE spec SYSTEM "../../support/dtd/v3m.dtd">
<!-- $Id: datatypes-source.xml 7848 2009-05-26 00:28:48Z ggrieve $ -->
<spec xmlns:xlink="http://www.w3.org/TR/WD-xlink">
	<header>
		<title>Data Types - Abstract Specification</title>
		<version>2.0</version>
<!--		<revision>$Revision: 7848 $</revision>-->
		<ballot type="Membership" number="4"/>
		<date>Sept 2008</date>
		<authlist>
			<author>
				<role>Primary Contributer &amp; Co-Chair of Modelling &amp; Methodology</role>
				<name>Grahame Grieve</name>
				<affiliation>Kestral Computing Pty. Ltd.</affiliation>
				<email href="grahame@kestral.com.au" xlink-form="simple" show="embed" actuate="auto"/>
			</author>
			<author>
				<role>Primary Contributer</role>
				<name>Gunther Schadow</name>
				<affiliation>Indiana School of Medicine</affiliation>
				<email href="gschadow@regenstrief.org" xlink-form="simple" show="embed" actuate="auto"/>
			</author>
			<author>
				<role>Primary Contributer (R1)</role>
				<name>Paul Biron</name>
				<affiliation>Sparrow Hawk Photography</affiliation>
				<email href="paul@sparrow-hawk.org" xlink-form="simple" show="embed" actuate="auto"/>
			</author>
			<author>
				<role>Primary Contributer &amp; Co-Chair of Modelling &amp; Methodology</role>
				<name>Lloyd McKenzie</name>
				<affiliation>Lloyd Mackenzie and Associates</affiliation>
				<email href="lloyd@lmckenzie.com" xlink-form="simple" show="embed" actuate="auto"/>
			</author>
			<author>
				<role>Co-Chair of Modelling &amp; Methodology</role>
				<name>George (Woody) Beeler</name>
				<affiliation>Beeler Consulting LLC</affiliation>
				<email href="woody@beelers.com" xlink-form="simple" show="embed" actuate="auto"/>
			</author>
			<author>
				<role>Co-Chair of Modelling &amp; Methodology</role>
				<name>Dale Nelson</name>
				<affiliation>II4SM</affiliation>
				<email href="dale@zed-logic.com" xlink-form="simple" show="embed" actuate="auto"/>
			</author>
			<author>
				<role>Co-Chair of Modelling &amp; Methodology</role>
				<name>Craig Parker</name>
				<affiliation>Arizona State University</affiliation>
				<email href="craigparkermd@gmail.com" xlink-form="simple" show="embed" actuate="auto"/>
			</author>
			<author>
				<role>Co-Chair of Modelling &amp; Methodology</role>
				<name>Ioana Singureanu</name>
				<affiliation>Eversolve, LLC</affiliation>
				<email href="ioana.singureanu@gmail.com" xlink-form="simple" show="embed" actuate="auto"/>
			</author>
		</authlist>
	</header>
	<front>
		<div1 id="datyp2preface">
			<head>Preface</head>
			<div2 id="preface">
				<head>Notes to Readers</head>
				<p>
				This is the fourth membership ballot for Release 2 of the <emph>Data Type - Abstract Specification</emph>.
			</p>
				<p>
				One substantiative change has been to this ballot, the removal of the <termref ref="dt-CD">CD</termref>.isCompositional 
				property. This change is the only part of the document that is open for comment in this ballot. Other comments
				may be made, but will most likely be deferred to data types R3. 
			</p>
				<p>
				The primary issue already deferred to R3 is the question of an improved conformance framework that 
				properly handles translations and property level conformance. In particular, this should provide 
				a more elegant solution to the recognised problem of requiring an attribute to have either text or 
				a code. In addition, the subject of nested ADXP's will be considered for R3.
			</p>
			</div2>
			<div2 id="datyp2acks">
				<head>Acknowledgements</head>
				<p>
				This work is the result of much work and many MBs of text in skype, wiki, and email
				by the Data Types R2 Taskforce, as well as phone calls and face to face meetings. The
				Data Types R2 Taskforce has an informal membership. The core members are
			</p>
				<list role="unordered">
					<item>
						<p>Grahame Grieve</p>
					</item>
					<item>
						<p>Gunther Schadow</p>
					</item>
					<item>
						<p>Lloyd Mckenzie</p>
					</item>
					<item>
						<p>Lee Coller</p>
					</item>
					<item>
						<p>Charlie McCay</p>
					</item>
					<item>
						<p>Dale Nelson</p>
					</item>
				</list>
				<p>Many other individuals have helped out during the data types R2 proposal. The R2 taskforce would particularly like to thank</p>
				<list role="unordered">
					<item>
						<p>Doug Pratt</p>
					</item>
					<item>
						<p>Mark Tucker</p>
					</item>
					<item>
						<p>Kevin Coonan</p>
					</item>
					<item>
						<p>David Markwell</p>
					</item>
					<item>
						<p>Jay Lyle</p>
					</item>
				</list>
				<p>
				Release 2 was made possible by Connecting For Health.
			</p>
				<p>
				Data Types Release 2 is a continuation of the first release of the
				data types, which was the result of many years of intense work
				through e-mail, telephone conferences and meeting discussions. And
				ballot reconciliation. Thanks go to many individuals who participated
				at various times in design, discussions and ballot review. Gunther Schadow
				chaired the task force, and was the main author of this document. Paul
				Biron, Doug Pratt, Lloyd Mckenzie, and Grahame Grieve served as editors
				at various times. Major contributions of thoughts and support come from
				Mark Tucker, George Beeler, Stan Huff, as well as Mike Henderson,
				Anthony Julian, Joann Larson, Mark Shafarman, Wes Rishel, and Robin
				Zimmerman. Acknowledgements for their critical review and infusion of
				ideas go to Bob Dolin, Clem McDonald, Kai Heitmann, Rob Seliger, and Harold
				Solbrig. Vital support came from the members of the task force, Laticia
				Fitzpatrick, Matt Huges, Randy Marbach, Larry Reis, Carlos Sanroman, 
				and Greg Thomas. Thanks also to James Case, Norman Daoust, Irma Jongeneel,
				Michio Kimura, John Molina, Richard Ohlmann, David Rowed, and Klaus Veil,
				for sharing their expertise in critical questions. 
			</p>
				<p>
				Release 1 was made possible by the Regenstrief Institute for Health Care.
			</p>
			</div2>
		</div1>
	</front>
	<body>
		<div1 id="datyp2intro">
			<head>Overview</head>
			<div2 id="datyp2introscope">
				<head>Introduction and Scope</head>
				<p> 
				This document provides the semantic definitions for the data types used in the 
				creation of HL7 V3 specifications.  These "abstract" semantic definitions are 
				also able to be used as constraints in the creation of implementation guides,
				and implementation technology specifications that enable actual exchange of 
				data are based on these semantic definitions.
			</p>
				<p>
				The audience for this document is anyone who uses HL7 V3 data types - both 
				implementers and designers of HL7 specifications. For implementers, this 
				document should be treated as secondary supplemental information to the 
				ITS data types, which provide an basis for actual implementation of the 
				data types.
			</p>
				<p>
				The data types defined in this specification are not intended to be 
				implemented solely based on the details presented herein. For example, this 
				specification does not differentiate between the information that should 
				be represented explicitly in any technical representation such as XML and the information that should be derived 
				from the explicit representation. This document	corresponds broadly to the RM-ODP 
				informational view ("concerned with the kinds of information handled by the system and constraints on the use and interpretation of that information"). The ISO data types specification is an ITS for 
				these data types that corresponds to the RM-ODP computational view ("concerned with the functional decomposition of the system into a set of objects").
				See [<loc href="http://www.rm-odp.net/" xlink-form="simple" show="embed" actuate="auto"/>] for further information.
			</p>
				<p>
				Readers should be familiar with the use of data types
				in a programming context, and will find reading easier if they are
				familiar with standard notations such as regular expressions,
				Bakus-Naur form, and UML class diagrams.
			</p>
			</div2>
			<div2 id="datyp2introwhat">
				<head>What is a Data Type?</head>
				<p>
				   The RIM is composed of classes with attributes which are data elements.
				   A data element is a unit of data for which the definition, identification, representation, and permissible 
				   values are specified by means of a set of attributes.
					Every data element has a data type. The data type defines the set of 
					valid values that can be assigned to a data
					element and their meaning (semantics). Meaningful exchange of data requires that we know the
					definition of values so exchanged. This is true for complex "values"
					such as timing specifications as well as for simpler values such as
					character strings or integer numbers. An instance of a data type is 
					a data value.
				</p>
				<p>
					According to ISO 11404, a data type is "a set of distinct values,
					characterized by properties of those values and by operations on
					those values."  A data type can be defined by <emph>intension</emph> or by
					<emph>extension</emph>, or by a combination of these approaches. 
					Intensional definition specifies the properties that the set of valid 
					values must have: e.g. a definition that stipulates that a "string" 
					is "an ordered collection of legible characters from a defined 
					character set."  Extensional definition enumerates the values 
					deemed valid: e.g. the assertion that the boolean type consists of 
					the values "true" and "false".  While extensional definitions are 
					useful for coded attributes, almost all abstract data types are 
					defined intensionally.
				</p>
				<p>
					A property of a data type is referred to by a name and can be evaluated for 
					any value of a data type. The value of a data value's property must itself be a
					value defined by a data type - no data value exists that cannot be
					defined by a data type.
				</p>
				<p>
					Data types are thus the basic building blocks used to construct any
					higher order meaning: messages, computerized patient records,
					or business objects and their transactions. For the purposes of this document, 
					business objects are defined as any class built using data types that is used 
					to store or convey information in helathcare systems (this definition is more 
					general than the term business objects may convey in other contexts). What, then, is the
					difference between a data type and a message, document, or business
					object? <emph role="strong">Data type values stand for themselves: the
					value is all that counts. Neither identity nor state is defined for a data value.</emph> In business
					objects, we track state and identity; the properties of an identical
					object might change between now and later. Not so with data values: a
					data value and its properties are constant. For example, number 5 is
					always number 5: there is no difference between this number 5 and that
					number 5 (no identity distinguished from value), number 5 never
					changes to number 6 (no change of state). One can think of data values
					as immutable objects where identity does not matter (identity and
					equality are the same).
				</p>
			</div2>
			<div2 id="datyp2introrep">
				<head>Representation of Data Values</head>
				<p>
					Data values can be represented through various symbols but the data
					value's meaning is not bound to any particular representation.
				</p>
				<p>
					For example, integers are defined intensionally as a data type where each value has a successor value. Based on this
					definition we can define addition, multiplication, and other
					mathematical operations. Whatever representation reflects the rules we
					stated in the intensional definition of the integer data type is a
					valid representation of integer numbers. Examples for valid integer
				    representations are decimal digit strings, roman numerals, or
					scratches on a wall, given appropriate syntaxes for negative numbers. The number five is represented by the
					word "five", by the Arabic number "5" or by the Roman number "V". The
					representation does not matter as long as it conforms to the semantic
					definition of the data type.
				</p>
				<p>
					Another example, the Boolean data type is defined by its extension,
					the two distinct values <emph>true</emph> and <emph>false</emph> and
					the rules of negation and combining these values in conjunction and
					disjunction. The representation of Boolean values can be the words
					"true" and "false," "yes" and "no," the numbers 0 and 1, or any other two signs
					that are distinct from each other. The representation of data types
					does not matter as long as it conforms to the semantic definition of
					the data type.
				</p>
				<p>
					This specification defines the semantics, the meaning of the HL7 data
					types. <emph role="strong">This specification is about semantics only,
					independent from representational and operational concerns or specific
					implementation technologies.</emph> Additional standards for
					representing the data values defined here using various technological approaches may be defined by HL7
					or other standards bodies. These standards are called
					"Implementable Technology Specification" (ITS). These ITS define how
					values are represented so that they conform to the semantic
					definitions of this specification, this may include syntaxes for
					character or binary representations, and computer procedures to act on
					the representation of data values. The meaning of these ITS
					representations communicated, generated, and processed in computer
					programs, is defined based on this standard, the semantic data type
					specification.
				</p>
			</div2>
			<div2 id="datyp2introprop">
				<head>Properties of Data Values</head>
				<p>
					Data types specify the properties of data values. The fields of composite data 
					types &#8212; e.g., the units property of a measurement &#8212; are an obvious example 
					of such properties. Generally, however, one should think of a data value's
					properties as logical predicates or as mathematical functions. In
					simpler but still correct terms, properties are the answers to questions one can ask
					about a data value.
				</p>
				<p>
					A property is referred to by its name. For example, the data type
					<emph>integer</emph> may have a property named "sign."  A property has
					a domain, which is the set of possible "answer" values. The set of
					possible "answer" values is defined by the property's data type. The
					domain of a property may be a subset of the property's data type's value set, since
					other constraints may be applied to the data type in the context of the 
					property.
				</p>
				<p>
					A property may also have arguments, additional information one must
					supply with a question to get an answer. For example, an important
					property of an integer number is that one integer <emph>plus</emph>
					another integer results in another integer, so the plus property of
					one integer requires an argument: the other integer.
				</p>
				<p>
					Whether properties have arguments is not a fundamentally
					relevant distinction. Properties that do not take arguments are not 
					necessarily more fundamental than others, and such a property is not 
					necessarily to be represented as a field of a composite data type. For
					example, for integer values, we can define the property
					<emph>is-zero</emph> that has the Boolean value <emph>true</emph> when
					the number is zero and <emph>false</emph> when the number is not
					zero. This does not mean that <emph>is-zero</emph> must be an explicit
					component of any integer representation.
				</p>
				<p>
				    Similarly, a property with arguments need not imply specific operational 
				    notions such as "procedure calls" or "arguments." These are concepts of 
				    computer system implementations of data types, but these operational
					notions are irrelevant for the semantics of data types.
					The fact that a data type has a property does not mean that implementations 
					must explicitly model the property; only that the property must be derivable.  
					The "sign" property in the previous example could be modeled as a discrete 
					element separate from the integer's magnitude, or it could be implicit in 
					the field, discretely identifiable only through an operation such as 
					comparing the value to its absolute value.  
				</p>
				<p>
					Many properties are never explicitly represented in an implementation, and 
					may be only implicitly derivable from the implementation design rather than 
					the data value.  For instance, every type defined here inherits the "type" 
					property, but actual data values are not commonly stored with explicit 
					representations of their types: that information is implicit in the database, 
					schema, or other data storage technology or specification.
				</p>
				<p>
					<emph role="strong">This specification is about semantics of data
					types only. It is not about value representation syntax (not even
					an abstract syntax), nor is it about an operational interface to the
					data values.</emph>
				</p>
			</div2>
			<div2 id="datyp2intronabs">
				<head>Need for Abstraction</head>
				<p>
					<emph role="strong">Why does this specification make such a big issue
					about its being abstract from representation syntax as well as
					operational implementation?</emph>
				</p>
				<p>
					HL7 needs this kind of abstract semantic data type specification for a
					very practical purpose. One important design feature of HL7 version 3
					is its neutrality towards representation and implementation
					technologies. All HL7 version 3 specifications are required to be technology 
					and representationally neutral. HL7 acknowledges that, while at times some
					representation and implementation technologies may be more popular
					than others, technology is going to change - and with changing
					technology, representations of data values will change. HL7 standards
					are primarily targeted to healthcare domain information, independent
					from the technology supporting this information. HL7 expects that
					specifications defined independent from today's technology will
					continue to be useful, even after the next technological "paradigm
					shift."
				</p>
				<p>
					The issue of data types is closer to implementation technology than
					most other HL7 information standards - and therein lays a certain
					danger that we define data types too dependent on current
					implementation technologies.
				</p>
				<p>
					The majority of HL7 standards are about complex business
					objects. Complex business objects with many informational attributes
					can be specified as abstract syntax, where components are eventually
					defined in terms of data types. Conversely, defining data types in
					terms of some abstract representational syntax is of little use because the components of
					such abstract syntax constructs would still need to be defined.
				</p>
				<p>
					<emph role="strong">Why is this specification so circular?
					Why is the data type "ANY" defined in terms of specializations
					of itself?</emph>
				</p>
				<p>
					This specification needs to be independent of any particular implementation,
					so its definitions are necessarily self-dependent.  The properties of ANY all 
					have a type that is some specialisation of ANY; this allows the self-dependent 
					definitions of basic concepts to be re-used where appropriate. The circularity 
					is not a problem, as it does not introduce any uncertainty about what this 
					specification says. This specification is also abstract, and not intended to 
					be directly implemented, and therefore does not address the challenges this
					poses for implementations; this is left to the various implementation
					technology specifications to best resolve. 
				</p>
				<p>
					<emph role="strong">Why doesn't this specification define a set of
					primitive data types based on which composite data types could be
					defined simply as abstract syntax?</emph>
				</p>
				<p>
					Any concrete implementation of the HL7 standards must ultimately use
					the built-in data types of its implementation technology. Therefore,
					we need a flexible mapping between HL7 abstract data types and
					those data types built into any specific implementation
					technology. An Implementable Technology Specification (ITS) conforms 
					to an abstract specification by asserting a mapping the constructs of 
					its technology and the properties defined in the HL7 version 3 
					abstract data types. Whether a data type is primitive or composite is irrelevant
					from a semantic perspective, and the answer may be different for
					different implementation technologies.
				</p>
				<p>
					For example, this standard specifies a character string as a data type
					with many properties (e.g., charset, language, etc.).  However, in many
					Implementation Technologies, character strings are primitive first
					class data types. We encourage that these native data types be used
					rather than a structure that slavishly represents all the semantic
					properties as "components."  This specification only requires that the
					properties defined for data values can somehow be inferred from
					whatever representation is chosen: it does not matter how these values
					are represented. Whether "primitive" or "composite," with few or many
					"components," as "fields" or "methods" - this is all irrelevant.
				</p>
				<p>
					For another example, a decimal representation, a floating-point
					register and a scaled integer are all possible native representations
					of real numbers for different implementation technologies. Some of
					these representations have properties that others do not have. Scaled
					integers, for instance, have a fixed precision and a relatively small
					range. Floating-point values have variable precision and a large
					range, but floating-point values lose any information about
					precision. Decimal representations are of variable precision and
					maintain the precision information (yet are slow to process).  The
					data type semantics must be independent from all these accidental
					properties of the various representations, and must define the
					essential properties that any technology should be able to represent.
				</p>
			</div2>
			<div2 id="datyp2introndts">
				<head>Need for an HL7 Data Type Standard</head>
				<p>
					<emph role="strong">Why does HL7 need its own data type standard? Why
					can't HL7 simply adopt a standard defined by some other body?</emph>
				</p>
				<p>
					As noted in the previous section, all HL7 implementation technologies
					have some data type system, but there are differences among the data
					type systems between implementation technologies. In addition, many
					implementation technologies' data type systems are not powerful enough
					to express the concepts that matter for the HL7 application layer.
				</p>
				<p>
					Few implementation technologies provide the concepts of
					physical quantities, precision, ranges, missing information, and
					uncertainty that are so relevant in scientific and health care
					computing.
				</p>
				<p>
					On the other hand, implementation technologies do make distinctions
					that are not relevant from the abstract semantics viewpoint, e.g.,
					fixed point vs. floating-point real numbers; 8, 16, 32, or 64-bit
					integers; date vs. timestamp.
				</p>
				<p>
					A number of data type systems have been used as input to this
					specification. These include the type systems of many major
					programming languages, including BASIC, Pascal, MODULA-2, C, C++,
					JAVA, ADA, LISP and SCHEME. This also includes type systems of
					language-independent implementation technologies, such as Abstract
					Syntax Notation One (ASN.1), Object Management Group's (OMG) Interface
					Definition Language (IDL) and Object Constraint Language (OCL), SQL 92
					and SQL 99, the ISO 11404 language independent data types, and XML
					Schema Part 2 data types. Health care standards related data types
					have been considered as well, among these HL7 version 2.x, types used
					by CEN TC 251 messages and Electronic Health Record Architecture
					(EHCRA) and DICOM.
				</p>
			</div2>
			<!-- 			<div2 id="datyp2introreq">
				<head>Requirements</head>
				<p>
					The data types described in this specification are designed
					to meet a number of requirements. These include
				</p>
				<list role="unordered">
					<item>
						Modelling considerations: The data types must be designed in a coherent consistent fashion
					</item>
					<item>
						Implementation Considerations: It must be possible to implement the data types in existing technologies
					</item>
					<item>
						Compatibility with other data type standards: It must be possible to determine when other specifications meet these standards, and the specification must not prevent translation among its implementations
					</item>
					<item>
						Functional Requirements identified in other HL7 standards
						where the data types are used:  The specification must support requirements specified in HL7 standards
					</item>
				</list>
				<p>
					Of these, the last is the most important consideration. These data types are designed
					to deliver the functionality required throughout the HL7 standards. These requirements
					are not always compatible, and throughout this specification there are a number of places
					where particular design features are less than optimal for one of the 4 considerations
					listed above. In a number of these places, the requirements that led to this design
					feature are described in a requirements section. These requirements sections are only
					informative, not normative.
				</p>
				<requirement>
					<p>
						The Reference Information Model defines a number of reference classes on which
						all domain information models are based. Each of these reference classes has
						a series of attributes, each of which has an assigned type. Where the reference classes
						are used in domain models, the types in the reference classes may
						be replaced by other types to clarify and constrain the use of the attribute in
						the clone classes.
					</p>
					<p>
						This data types specification must define the rules for which data
						types can be substituted in this fashion. 
					</p>
					<p>
						This specification chooses
						to use the specialization metaphor as a basis for the substitution
						rules, since this is widely understood and used method in theory and
						practice, and because these rules are more easily understood and
						managed than the alternatives. This use of specialization may lead to
						designs that may appear unfamiliar to some.
					</p>
				</requirement>
			</div2> -->
			<div2 id="datyp2introovw">
				<head>Overview of Data Types</head>
				<p>
					The following table lists all of the data types in this specification, each 
					with the text description taken from its definition.	
				</p>
				<table id="dt-summary-table">
					<caption>
       Overview of HL7 version 3 data types
    </caption>
					<col width="79"/>
					<col width="60"/>
					<col width="413"/>
					<thead>
						<tr>
							<th> </th>
							<th>Name</th>
							<th>Symbol</th>
							<th>Description</th>
						</tr>
					</thead>
					<tbody>
						<tr style="background: silver;">
							<td colspan="3" style="font-weight: bold;">
								<b>Foundation</b>
							</td>
							<td>Core structural datatypes that are needed in order to build the types that are in the healthcare domain</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>DataValue</td>
							<td>
								<termref ref="dt-ANY">ANY</termref>
							</td>
							<td>
					An abstract type that defines the basic properties common to all data values defined in this specification. 
					Data Value is an abstract type, meaning that no proper value
					can be just a data value without belonging to any concrete type. Every concrete
					type is a specialization of this general abstract DataValue type.
				</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>Boolean</td>
							<td>
								<termref ref="dt-BL">BL</termref>
							</td>
							<td>
					A binary value for use in boolean logic. A <emph>BL</emph>
					value can be either <emph>true</emph> or <emph>false</emph>, or, as
					any other value, MAY be NULL.
				</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>Collection</td>
							<td>
								<termref ref="dt-COLL">COLL</termref>
							</td>
							<td>
					A collection of values which can be enumerated using an iterator.
				</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>Bag</td>
							<td>
								<termref ref="dt-BAG">BAG</termref>
							</td>
							<td>
					An unordered collection of values, where any value can occur
					more than once.
				</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>Sequence</td>
							<td>
								<termref ref="dt-LIST">LIST</termref>
							</td>
							<td>
					An ordered collection of discrete (but not necessarily distinct) values.
				</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>Set</td>
							<td>
								<termref ref="dt-SET">SET</termref>
							</td>
							<td>
					A value that contains distinct values in no particular order.
				</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>EqualComparator</td>
							<td>
								<termref ref="dt-CEQ">CEQ</termref>
							</td>
							<td>
					A comparator based on the equality relationship defined for all types.
				</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>DiscreteSet</td>
							<td>
								<termref ref="dt-DSET">DSET</termref>
							</td>
							<td>
					An unordered collection of values that contains discrete distinct values.
				</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>HistoryItem</td>
							<td>
								<termref ref="dt-HXIT">HXIT</termref>
							</td>
							<td>
					A generic data type extension that adds a time range and/or link to the ControlAct 
					associated with the creation of the data on any data value whatever its data type. 
				</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>History</td>
							<td>
								<termref ref="dt-HIST">HIST</termref>
							</td>
							<td>
					A list of data values that have a valid-time property.
				</td>
						</tr>
						<tr style="background: silver;">
							<td colspan="3" style="font-weight: bold;">
								<b>Basic</b>
							</td>
							<td>Basic building blocks that are used in health care information models - text, coded concepts, identifiers, names and addresses</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>EncapsulatedData</td>
							<td>
								<termref ref="dt-ED">ED</termref>
							</td>
							<td>
					Data that is primarily intended for human interpretation or for
					further machine processing outside the scope of HL7. 
				</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>CharacterString</td>
							<td>
								<termref ref="dt-ST">ST</termref>
							</td>
							<td>
					Text data, primarily
					intended for machine processing (e.g., sorting, querying, indexing, presentation,
					etc.). 
				</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>CharacterStringWithCode</td>
							<td>
								<termref ref="dt-SC">SC</termref>
							</td>
							<td>
					A character string that optionally may have a code attached.
				</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>ConceptDescriptor</td>
							<td>
								<termref ref="dt-CD">CD</termref>
							</td>
							<td>
					A reference to a concept defined in a code system
				</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>CodedOrdinal</td>
							<td>
								<termref ref="dt-CO">CO</termref>
							</td>
							<td>
					 Coded data, where the coding system from which the code comes defines a 
					 partial or complete order on some or all of the codes in the system. 
				</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>CodedSimpleValue</td>
							<td>
								<termref ref="dt-CS">CS</termref>
							</td>
							<td>
					Coded data in its simplest form, where only the code is not predetermined.
					The code system and code system version are fixed by the context in which
					<emph>CS</emph> value occurs. <emph>CS</emph> is used for coded attributes that have a single
					HL7-defined value set.
				</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>ObjectIdentifier</td>
							<td>
								<termref ref="dt-OID">OID</termref>
							</td>
							<td>
					A globally unique string representing an ISO Object Identifier
					(OID) in a form that consists only of numbers and dots (e.g.,
					"2.16.840.1.113883.3.1"). According to ISO, <emph>OID</emph>s are paths in a tree
					structure, with the left-most number representing the root and the
					right-most number representing a leaf.
				</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>UniversalUniqueIdentifier</td>
							<td>
								<termref ref="dt-UUID">UUID</termref>
							</td>
							<td>
					A globally unique string representing a DCE Universal Unique
					Identifier (UUID) in the common UUID format that consists of 5
					hyphen-separated groups of hexadecimal digits having 8, 4, 4, 4,
					and 12 places respectively.
				</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>HL7ReservedIdentifierScheme</td>
							<td>
								<termref ref="dt-RUID">RUID</termref>
							</td>
							<td>
					A globally unique string defined exclusively by HL7. Identifiers in
					this scheme SHALL only be defined by balloted HL7 specifications. Local
					communities or systems SHALL never use such reserved identifiers based
					on bilateral negotiations.
				</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>InstanceIdentifier</td>
							<td>
								<termref ref="dt-II">II</termref>
							</td>
							<td>
					An identifier that uniquely identifies a thing or object. Examples
					are object identifier for HL7 RIM objects, medical record number,
					order id, service catalog item id, Vehicle Identification Number
					(VIN), etc. 
				</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>TelecommunicationAddress</td>
							<td>
								<termref ref="dt-TEL">TEL</termref>
							</td>
							<td>
					A locatable resource that is identified by a URI. The address is specified as a Universal Resource 
					Identifier (URL) qualified by time specification and use codes that 
					help in deciding which address to use for a given time and purpose.
					TEL may be used to designate a retrievable resource such as a web 
					page, a telephone number (voice, fax or some other resource mediated 
					by telecommunication equipment), an e-mail address, or any other locatable
					resource that can be specified by a URL.
				</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>PostalAddress</td>
							<td>
								<termref ref="dt-AD">AD</termref>
							</td>
							<td>
					Mailing and home or office addresses. A sequence of address parts,
					such as street or post office box, city, postal code, country, etc.
				</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>EntityName</td>
							<td>
								<termref ref="dt-EN">EN</termref>
							</td>
							<td>
					A name for a person, organization, place or thing. A sequence of name
					parts, such as given name or family name, prefix, suffix, etc.
					Examples for entity name values are "Jim Bob Walton, Jr.", "Health
					Level Seven, Inc.", "Lake Tahoe", etc. An entity name may be as simple
					as a character string or may consist of several entity name parts,
					such as, "Jim", "Bob", "Walton", and "Jr.", "Health Level Seven" and
					"Inc.", "Lake" and "Tahoe".
				</td>
						</tr>
						<tr style="background: silver;">
							<td colspan="3" style="font-weight: bold;">
								<b>Quantities</b>
							</td>
							<td>Simple numerical types such as numbers, and also more complex notions such as physical quantities and ratios</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>IntegerNumber</td>
							<td>
								<termref ref="dt-INT">INT</termref>
							</td>
							<td>
					Integer numbers (-1,0,1,2, 100, 3398129, etc.) are precise numbers
					that are results of counting and enumerating. Integer numbers are
					discrete, the set of integers is infinite but countable.  No arbitrary
					limit is imposed on the range of integer numbers. Two NULL flavors are
					defined for the positive and negative infinity.
				</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>RealNumber</td>
							<td>
								<termref ref="dt-REAL">REAL</termref>
							</td>
							<td>
					A scalar magnitude. Typically used whenever quantities are measured,
					estimated, or computed from other real numbers.  The typical
					representation is decimal, where the number of significant decimal
					digits is known as the precision.
				</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>Ratio</td>
							<td>
								<termref ref="dt-RTO">RTO</termref>
							</td>
							<td>
					A quantity constructed as the quotient of a numerator quantity divided
					by a denominator quantity. Common factors in the numerator and
					denominator are not automatically cancelled out.  The <emph>RTO</emph> data
					type supports titers (e.g., "1:128") and other quantities produced by
					laboratories that truly represent ratios. Ratios are not simply
					"structured numerics": for instance, blood pressure measurements
					(e.g. "120/60") are not ratios.
				</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>PhysicalQuantity</td>
							<td>
								<termref ref="dt-PQ">PQ</termref>
							</td>
							<td>
					A dimensioned quantity expressing the result of measuring.
				</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>MonetaryAmount</td>
							<td>
								<termref ref="dt-MO">MO</termref>
							</td>
							<td>
					A quantity expressing an amount of money in some
					currency. While the monetary amount
					is a single kind of quantity (money) the exchange rates between the
					different units are variable.  This is the principle difference
					between <termref ref="dt-PQ">PQ</termref> and <emph>MO</emph>, and the reason why
					currency units are not physical units.
				</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>PointInTime</td>
							<td>
								<termref ref="dt-TS">TS</termref>
							</td>
							<td>
					A quantity specifying a point on the axis of natural time. A point
					in time is most often represented as a calendar expression.
				</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>Expression</td>
							<td>
								<termref ref="dt-EXPR">EXPR</termref>
							</td>
							<td>
					A generic data type extension used to specify an expression
					that can be used to derive the actual value of T given information
					taken from the context of use.
				</td>
						</tr>
						<tr style="background: silver;">
							<td colspan="3" style="font-weight: bold;">
								<b>Quantity Collections</b>
							</td>
							<td>Complex expressional types which can be used to build sophisticated concepts such as timing specifications</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>ContinuousSet</td>
							<td>
								<termref ref="dt-QSET">QSET</termref>
							</td>
							<td>
					An unordered set of distinct values which are quantities.
				</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>ContinuousSetUnion</td>
							<td>
								<termref ref="dt-QSU">QSU</termref>
							</td>
							<td>
					A Term in a <termref ref="dt-QSET">QSET</termref> expression that builds a <termref ref="dt-QSET">QSET</termref> from a union
					of other <termref ref="dt-QSET">QSET</termref>s.
				</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>ContinuousSetIntersection</td>
							<td>
								<termref ref="dt-QSI">QSI</termref>
							</td>
							<td>
					A Term in a <termref ref="dt-QSET">QSET</termref> expression that builds a <termref ref="dt-QSET">QSET</termref> from an intersection
					of other <termref ref="dt-QSET">QSET</termref>s.
				</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>ContinuousSetDifference</td>
							<td>
								<termref ref="dt-QSD">QSD</termref>
							</td>
							<td>
					A Term in a <termref ref="dt-QSET">QSET</termref> expression that builds a <termref ref="dt-QSET">QSET</termref> from the
					difference between 2 <termref ref="dt-QSET">QSET</termref>s.
				</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>ContinuousSetPeriodicHull</td>
							<td>
								<termref ref="dt-QSP">QSP</termref>
							</td>
							<td>
					A Term in a <termref ref="dt-QSET">QSET</termref> expression that builds a <termref ref="dt-QSET">QSET</termref> from the
					difference between 2 <termref ref="dt-QSET">QSET</termref>s.
				</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>CodedContinuousSet</td>
							<td>
								<termref ref="dt-QSC">QSC</termref>
							</td>
							<td>
					A Term in a <termref ref="dt-QSET">QSET</termref> expression that builds a <termref ref="dt-QSET">QSET</termref> from a coded value.
				</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>Interval</td>
							<td>
								<termref ref="dt-IVL">IVL</termref>
							</td>
							<td>
					A set of consecutive values of an ordered base data type.
				</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>PeriodicInterval</td>
							<td>
								<termref ref="dt-PIVL">PIVL</termref>
							</td>
							<td>
					An interval of time that recurs periodically. <emph>PIVL</emph> has
					two properties, <termref ref="prop-PIVL.phase">phase</termref> and <termref ref="prop-PIVL.period">period</termref>/<termref ref="prop-PIVL.frequency">frequency</termref>.
					<termref ref="prop-PIVL.phase">phase</termref> specifies the "interval
					prototype" that is repeated every <termref ref="prop-PIVL.period">period</termref> or <termref ref="prop-PIVL.frequency">frequency</termref>.
				</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>EventRelatedPeriodicInterval</td>
							<td>
								<termref ref="dt-EIVL">EIVL</termref>
							</td>
							<td>
					Specifies a periodic interval of time where the recurrence is based on
					activities of daily living or other important events that are
					time-related but not fully determined by time.
				</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>GeneralTimingSpecification</td>
							<td>
								<termref ref="dt-GTS">GTS</termref>
							</td>
							<td>
					An alias for <termref ref="dt-QSET">QSET</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;. 
				</td>
						</tr>
						<tr style="background: silver;">
							<td colspan="3" style="font-weight: bold;">
								<b>Uncertainties</b>
							</td>
							<td>Extend the previously defined types to cater for the various quantitative uncertainties encountered in healthcare information models</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>UncertainValueProbabilistic</td>
							<td>
								<termref ref="dt-UVP">UVP</termref>
							</td>
							<td>
					A generic data type extension used to specify a quantified probability expressing
					the information producer's belief that the given value is correct.
				</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>UncertainRange</td>
							<td>
								<termref ref="dt-URG">URG</termref>
							</td>
							<td>
					Indicates that the value comes from a range of possible values of an ordered base data type.
				</td>
						</tr>
					</tbody>
				</table>
				<p>
  	 
  </p>
				<p>
					The following table lists all of the flavors in this specification, each with 
					the text description taken from its definition. 
					<specref ref="flavors"/> are not fully qualified types, but only restrictions on previously defined 
					types and flavors.
				</p>
				<table id="flavor-summary-table">
					<caption>
       Overview of HL7 version 3 data type flavors
    </caption>
					<col width="79"/>
					<col width="60"/>
					<col width="413"/>
					<thead>
						<tr>
							<th> </th>
							<th>Name</th>
							<th>Symbol</th>
							<th>Description</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td> 
    </td>
							<td>BooleanNonNull</td>
							<td>
								<termref ref="dt-BN">BN</termref>
							</td>
							<td>
								<emph>BN</emph> constrains the <termref ref="dt-BL">BL</termref> so that it is not null.
						This is defined for use within the data types specification where it is not
						appropriate for a null value to be used.
					</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>TextWithReference</td>
							<td>
								<termref ref="dt-ED.TEXT">ED.TEXT</termref>
							</td>
							<td>
								<emph>ED.TEXT</emph> constrains <termref ref="dt-ED">ED</termref> so that it  
						only contains plain text. 
					</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>DigitalSignature</td>
							<td>
								<termref ref="dt-ED.SIGNATURE">ED.SIGNATURE</termref>
							</td>
							<td>
								<emph>ED.SIGNATURE</emph> constrains <termref ref="dt-ED">ED</termref> so that the contents are an 
						XML digital Signature according the W3C Signature specifications. 
					</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>Image</td>
							<td>
								<termref ref="dt-ED.IMAGE">ED.IMAGE</termref>
							</td>
							<td>
								<emph>ED.IMAGE</emph> constrains <termref ref="dt-ED">ED</termref> so that the contents are an 
						image. 
					</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>StructuredText</td>
							<td>
								<termref ref="dt-ED.STRUCTURED_TEXT">ED.STRUCTURED_TEXT</termref>
							</td>
							<td>
								<emph>ED.STRUCTURED_TEXT</emph> constrains <termref ref="dt-ED">ED</termref> so that the contents are structured
						text. 
					</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>StructuredTitle</td>
							<td>
								<termref ref="dt-ED.STRUCTURED_TITLE">ED.STRUCTURED_TITLE</termref>
							</td>
							<td>
								<emph>ED.STRUCTURED_TITLE</emph> constrains <termref ref="dt-ED">ED</termref> so that the contents are a structured title. 
					</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>StringNoTranslations</td>
							<td>
								<termref ref="dt-ST.NT">ST.NT</termref>
							</td>
							<td>
								<emph>ST.NT</emph> constrains <termref ref="dt-ST">ST</termref> so that it there are no translations.
					</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>StringSimple</td>
							<td>
								<termref ref="dt-ST.SIMPLE">ST.SIMPLE</termref>
							</td>
							<td>
								<emph>ST.SIMPLE</emph> constrains <termref ref="dt-ST.NT">ST.NT</termref> so that it does not specify a language.
					</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>CodedStringNoTranslations</td>
							<td>
								<termref ref="dt-SC.NT">SC.NT</termref>
							</td>
							<td>
								<emph>SC.NT</emph> constrains <termref ref="dt-SC">SC</termref> so that it has no translations.
					</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>CodedValue</td>
							<td>
								<termref ref="dt-CV">CV</termref>
							</td>
							<td>
								<emph>CV</emph> constrains <termref ref="dt-CD">CD</termref> so that there is no translations,
						and only a single concept is allowed.
					</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>LocatableResource</td>
							<td>
								<termref ref="dt-TEL.URL">TEL.URL</termref>
							</td>
							<td>
								<emph>TEL.URL</emph> constrains <termref ref="dt-TEL">TEL</termref>  so that it points to a locatable resource that returns binary content.
					</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>TelephoneAddress</td>
							<td>
								<termref ref="dt-TEL.PHONE">TEL.PHONE</termref>
							</td>
							<td>
								<emph>TEL.PHONE</emph> constrains <termref ref="dt-TEL.PERSON">TEL.PERSON</termref>  so it refers to some telephone based
						communication system with a person or organisation.
					</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>EmailAddress</td>
							<td>
								<termref ref="dt-TEL.EMAIL">TEL.EMAIL</termref>
							</td>
							<td>
								<emph>TEL.EMAIL</emph> constrains the <termref ref="dt-TEL.PERSON">TEL.PERSON</termref>  type so that it is an SMTP email address.
					</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>PersonName</td>
							<td>
								<termref ref="dt-PN">PN</termref>
							</td>
							<td>
								<emph>PN</emph> constrains <termref ref="dt-EN">EN</termref> for use when the named Entity
						is a Person. 
					</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>OrganizationName</td>
							<td>
								<termref ref="dt-ON">ON</termref>
							</td>
							<td>
								<emph>ON</emph> constrains <termref ref="dt-EN">EN</termref> for use when the named Entity
						is an Organization. 
					</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>TrivialName</td>
							<td>
								<termref ref="dt-TN">TN</termref>
							</td>
							<td>
								<emph>TN</emph> constrains <termref ref="dt-EN">EN</termref>  so that it is effectively a simple string, suitable
						for use as a simple name for things and places.
					</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>IntegerNonNegative</td>
							<td>
								<termref ref="dt-INT.NONNEG">INT.NONNEG</termref>
							</td>
							<td>
								<emph>INT.NONNEG</emph> constrains <termref ref="dt-INT">INT</termref>  so that it has a value of 0 or greater.
					</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>IntegerPositive</td>
							<td>
								<termref ref="dt-INT.POS">INT.POS</termref>
							</td>
							<td>
								<emph>INT.POS</emph> constrains <termref ref="dt-INT.NONNEG">INT.NONNEG</termref>  so that it has a value greater than 0.
					</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>LengthOfTime</td>
							<td>
								<termref ref="dt-PQ.TIME">PQ.TIME</termref>
							</td>
							<td>
								<emph>PQ.TIME</emph> constraints <termref ref="dt-PQ">PQ</termref> so that it has units that describe a period of time.
					</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>Date</td>
							<td>
								<termref ref="dt-TS.DATE">TS.DATE</termref>
							</td>
							<td>
								<!-- Lloyd: Can we add "Allows for partial dates"? -->
								<emph>TS.DATE</emph> constrains <termref ref="dt-TS">TS</termref>  so that it only contains a date value.
					</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>FullDate</td>
							<td>
								<termref ref="dt-TS.DATE.FULL">TS.DATE.FULL</termref>
							</td>
							<td>
								<emph>TS.DATE.FULL</emph> constrains <termref ref="dt-TS.DATE">TS.DATE</termref>  so that it contains a reference to a particular day.
					</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>DateTime</td>
							<td>
								<termref ref="dt-TS.DATETIME">TS.DATETIME</termref>
							</td>
							<td>
								<emph>TS.DATETIME</emph> constrains a <termref ref="dt-TS">TS</termref>  so that it is not more precise
						than seconds.
					</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>FullDateTime</td>
							<td>
								<termref ref="dt-TS.DATETIME.FULL">TS.DATETIME.FULL</termref>
							</td>
							<td>
								<emph>TS.DATETIME.FULL</emph> constrains <termref ref="dt-TS.DATETIME">TS.DATETIME</termref> so that it contains a reference to a particular second with a timezone.
					</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>InstantInTime</td>
							<td>
								<termref ref="dt-TS.INSTANT">TS.INSTANT</termref>
							</td>
							<td>
								<emph>TS.INSTANT</emph> constrains <termref ref="dt-TS.DATETIME">TS.DATETIME</termref> so that it contains a reference to a particular millisecond with a timezone.
					</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>IntervalLow</td>
							<td>
								<termref ref="dt-IVL.LOW">IVL.LOW</termref>
							</td>
							<td>
								<emph>IVL.LOW</emph> constrains <termref ref="dt-IVL">IVL</termref> so that low is provided and lowClosed is true.
						All other properties are prohibited.
					</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>IntervalHigh</td>
							<td>
								<termref ref="dt-IVL.HIGH">IVL.HIGH</termref>
							</td>
							<td>
								<emph>IVL.HIGH</emph> constrains <termref ref="dt-IVL">IVL</termref> so that high is provided and highClosed is true.
						All other properties are prohibited.
					</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>IntervalWidth</td>
							<td>
								<termref ref="dt-IVL.WIDTH">IVL.WIDTH</termref>
							</td>
							<td>
								<emph>IVL.WIDTH</emph> constrains <termref ref="dt-IVL">IVL</termref> so that width is mandatory and low, lowClosed, high and highClosed are prohibited.
					</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>UncertainRangeLow</td>
							<td>
								<termref ref="dt-URG.LOW">URG.LOW</termref>
							</td>
							<td>
								<emph>URG.LOW</emph> constrains <termref ref="dt-URG">URG</termref> so that low and lowClosed are required.
						high and highClosed are prohibited.
					</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>UncertainRangeHigh</td>
							<td>
								<termref ref="dt-URG.HIGH">URG.HIGH</termref>
							</td>
							<td>
								<emph>URG.HIGH</emph> constrains <termref ref="dt-URG">URG</termref> so that high and highClosed are required.
						low and lowClosed are prohibited.
					</td>
						</tr>
						<tr>
							<td> 
    </td>
							<td>BoundedPeriodicInterval</td>
							<td>
								<termref ref="dt-GTS.BOUNDEDPIVL">GTS.BOUNDEDPIVL</termref>
							</td>
							<td>
								<emph>GTS.BOUNDEDPIVL</emph> constrains <termref ref="dt-QSI">QSI</termref>&lt;<termref ref="dt-TS">TS</termref>&gt; (GTS) so that it only allows an intersection of <termref ref="dt-IVL">IVL</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;
						and <termref ref="dt-PIVL">PIVL</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;. 
					</td>
						</tr>
					</tbody>
				</table>
				<p>
  	 
  </p>
			</div2>
			<div2 id="datyp2conf">
				<head>Conformance</head>
				<p>
					All instantiations of these data types SHALL be valid with respect to the
					invariant statements contained in this specification.
					If an application receives or parses an instance that is not valid with
					regard to this specification, the receiver MAY reject the
					instance in whatever fashion it deems appropriate, but it is not required
					to.
				</p>
				<p>
					Note that many of the invariants contained in this specification only apply
					when the data types do not have an exceptional value (some kind of nullFlavor).
					These invariants specifically exclude exceptional values using some statement
					such as
				</p>
				<exhibit role="dtdl" id="conf">
					<anchor id="conf"/>
					<caption/>
					<pre>
invariant(T x) where x.nonNull {
  etc...
};</pre>
				</exhibit>
				<p>
					Other invariants must be true whether or not the value is an exceptional value.
				</p>
				<div3 id="dt2confmodel">
					<head>Constraining Model</head>
					<p>
						Generally these data types are used as the type of a RIM attribute in the
						presence of other models that may express further constraints 
						on the domain values of these types. In such cases, there MAY 
						be one single model which is regarded as the primary Constraining Model.
					</p>
					<p>
						If the constraining model labels the attribute as Mandatory, the instance
						SHALL contain a valid data value that conforms to all the constraints stated
						in this specification and any additional constraints on the value domain 
						stated in the model. In cases where the attribute is not mandatory, if the instance does not meet the constraints 
						specified in the Constraining Model, the instance SHALL have some form of 
						nullFlavor, though other information may still be provided.
					</p>
					<p>
						The constraining model may apply a cardinality to an attribute. 
						A cardinality consists of a minimum value, specified as a whole number,
						and a maximum value, specified as a whole number or "*". The cardinality
						is usually presented as [minimum value]..[maximum value], e.g. 0..1 or [1..*].
						The meaning of 
						the cardinality differs between collection based attributes and other attributes.
					</p>
					<p>
						For attributes with a collection type (<termref ref="dt-COLL">COLL</termref> and its specializations),
						the cardinality specifies how many items may be in the collection. A cardinality maximum value 
						of * means that there is no limit to the number of items in the collection. (Note that
						this does not imply that applications are required to handle infinitely large collections
						of data, but the specification itself places no limit on the size of the collection).
						The minimum value specifies how many items must be in the collection. Note that 						
						in the case of a mandatory collection, the collection SHALL NOT contain any null items.		
					</p>
					<p>
						For other attributes, the
						only cardinalities that may be applied are 0..0, 0..1, and 1..1. Cardinality of 
						0 means that the attribute is not to be represented in the instance, and has an
						implicit nullFlavor of NI. Cardinality of 1 means that the attribute has a value,
						though the value may be a nullFlavor unless the attribute is also mandatory.
					</p>
					<p>
					   A mandatory attribute SHALL have a minimum cardinality of 1 or more. 		
					</p>
					<p>
						If an application receives or parses an instance that does not conform to 
						these rules, the receiver MAY reject the instance in whatever fashion it 
						deems appropriate but it is not required to by this specification. Note that other specifications 
						that describe how Constraining Models are constructed and applied MAY make 
						additional rules concerning application behaviour.
					</p>
					<p>
						Any specification that describes a model other than a primary constraining model 
						(such as templates) MUST also describe how it affects the conformance behavior of downstream models.
						For further information,
						see in the "Core Principles of V3 Models" specification under "CIM" ([<loc href="../coreprinciples/v3modelcoreprinciples.htm#coreP_Types_of_HL7_V3_Models-Static-CIM" xlink-form="simple" show="embed" actuate="auto"/>])
					</p>
				</div3>
			</div2>
		</div1>
		<div1 id="dtdl-introduction">
			<head>Data Type Definitions</head>
			<p>
			   This specification groups data types into the following sections: foundation (necessary to construct the other types), 
			   basic, quantities, collections of quantities, and uncertainties.  Each section of this document uses a UML class 
			   diagram to illustrate the relationships among the types within the section.  In addition to the UML diagram that 
			   introduces each section, each data type specified here is defined with the following sections: 
			</p>
			<list role="unordered">
				<item>
					<p>A natural language name, unique within this specification; an 
					abbreviation of that name; and the specializations, or parent data types from
					which the type being specified inherits properties</p>
				</item>
				<item>
					<p>A prose definition</p>
				</item>
				<item>
					<p>A table of "primary" properties (described below)</p>
				</item>
				<item>
					<p>A formal Data Type Definition Language (DTDL) definition (described below)</p>
				</item>
				<item>
					<p>A full description for each property of the data type</p>
				</item>
				<item>
					<p>A table of domain definitions for coded types or properties (described below)</p>
				</item>
				<item>
					<p>A prose explanation of key points of the definition, or clarification or extension of the DTDL definition (optional)</p>
				</item>
				<item>
					<p>Notes identifying common misunderstandings, usage expectations, open questions, and other important points that don&#8217;t fit neatly into the above categories (optional)</p>
				</item>
			</list>
			<div2 id="umllang">
				<head>Unified Modeling Language (UML) Diagrams</head>
				<p>
					This specification uses Unified Modeling Language (UML) class diagrams to
					graphically represent how data types relate to each other. Data types are
					shown as UML classes using the shortname for the type. Properties of
					types are shown as UML operations. Generic types are shown as UML
					parameterized classes.
				</p>
				<p>
					Much of the detail of the data type declarations cannot be represented
					in the UML representation. Therefore the formal definition of the data
					types in the Data Type Definition Language (DTDL) should be used for
					detailed specification of the data types.
				</p>
				<graphic source="graphics/dtUML-Main.png" alt="UML Overview of Data Types and Flavors"/>
				<p>
					A number of stereotypes, enclosed in guillemots («»), are used in the diagram, some defined explicitly 
					in order to represent the concepts embodied in this specification.
				</p>
				<p>
					<emph>interface</emph>: All the types defined in this specification are interfaces,
					so the standard UML interface stereotype has been used throughout. These data types
					are	not intended for implementation, but describe a set of conceptual interfaces 
					that may be implemented in multiple different ways.
				</p>
				<p>
					<emph>bind</emph>: When a generic type is specialized, and the specialization
					includes binding the generic to a particular type, a "realize" association links
					the two classes, using a "bind" stereotype to indicate that the specialization
					binds the class to a particular type for the parameter. The type is indicated
					as a parameter on the bind stereotype.
				</p>
				<p>
					<emph>mixin</emph>: The mixin stereotype applies to a generic type: it
					denotes that the type is an interface, and that it specializes the parameter
					type and expresses all the properties of the type T in addition to its own
					properties - known as a Generic Type Extension.
				</p>
				<p>
					<emph>flavor</emph>: Rather than being a type, a flavor that expresses
					a set of constraints on a data type.   Note: &#8220;null flavors&#8221; is a concept
                    domain, not a flavor in this sense.
				</p>
				<p>
					<emph>constrain</emph>: Indicates the relationship between a flavor and the
					type or other flavor that it constrains. The exact nature of the relationship
					is described in the <specref ref="flavors"/> section.
				</p>
				<p>
					<emph>iteratable</emph>: Indicates that it makes sense to enumerate the items
					of the collection that this interface represents using a classic iterator interface.
				</p>
				<p>
					The UML diagrams use colors in the diagram. The colors act as an informal categorization
					of the data types. No particular significance is associated with the categorization.
					 The colors have absolutely no relationship to the color coding of the RIM or of classes 
					 in static model diagrams.
				</p>
				<table width="1px">
					<tr>
						<th rowspan="1" colspan="1">Colour</th>
						<th rowspan="1" colspan="1">Category</th>
					</tr>
					<tr>
						<td rowspan="1" colspan="1">White</td>
						<td rowspan="1" colspan="1">Infrastructure</td>
					</tr>
					<tr>
						<td rowspan="1" colspan="1">Salmon</td>
						<td rowspan="1" colspan="1">Text &amp; Multimedia</td>
					</tr>
					<tr>
						<td rowspan="1" colspan="1">Green</td>
						<td rowspan="1" colspan="1">Coded Concepts</td>
					</tr>
					<tr>
						<td rowspan="1" colspan="1">Orange</td>
						<td rowspan="1" colspan="1">Names and Addresses</td>
					</tr>
					<tr>
						<td rowspan="1" colspan="1">Purple</td>
						<td rowspan="1" colspan="1">Identifiers &amp; Contacts</td>
					</tr>
					<tr>
						<td rowspan="1" colspan="1">Grey</td>
						<td rowspan="1" colspan="1">Quantities</td>
					</tr>
					<tr>
						<td rowspan="1" colspan="1">Yellow</td>
						<td rowspan="1" colspan="1">Generics</td>
					</tr>
					<tr>
						<td rowspan="1" colspan="1">Blue</td>
						<td rowspan="1" colspan="1">Generic Extensions</td>
					</tr>
					<tr>
						<td rowspan="1" colspan="1">Mauve</td>
						<td rowspan="1" colspan="1">Comparators</td>
					</tr>
				</table>
			</div2>
			<div2 id="tabprop">
				<head>Tables of Properties</head>
				<p>
					For a quick overview at the beginning of many data types this
					specification contains tables listing "primary" properties. "Primary"
					properties are a somewhat fuzzy notion of those properties that are
					semantically most salient, and more likely to be thought of as "fields" when the data type where
					implemented as a record, or that are expected to be used more
					often. These tables are provided to facilitate an overview of the
					content and purpose of data types. There is no requirement that the
					properties listed in these tables be represented as fields, and these
					tables are <emph role="strong">not</emph> abstract syntax definitions.
				</p>
				<p>
					Each row of the property tables describes one property with the
					following columns:
				</p>
				<list role="ordered">
					<item>
						<emph role="strong">Name</emph> - the name of the property as stated in
						the formal definition.
					</item>
					<item>
						<emph role="strong">Type</emph> - the data type of that property.
					</item>
					<item>
						<emph role="strong">Definition</emph> - a short text describing
						the meaning of the property.
					</item>
				</list>
			</div2>
			<div2 id="domdefn">
				<head>Concept Domain Definitions and Bindings</head>
				<p>
					A number of properties in this specification have associated concept domains that 
					define the value domain for the property. These properties are all of type CD
					or some constraint thereof. 
				</p>
				<p>
					A concept domain is a named category of like concepts. Concept domains are bound
					to value sets in the context of a realm. A value set represents a uniquely identifiable
					set of valid concept representations, which may be taken from one or more code systems.
					The binding process is discussed in detail in the Core Principles of V3 Models [<loc href="../coreprinciples/v3modelcoreprinciples.htm" xlink-form="simple" show="embed" actuate="auto"/>] document.
				</p>
				<p>
					Unless otherwise specified, these concept domains are universally bound to 
					value sets that comprise a single code system. The code systems may be 
					defined by HL7 or some other external body, such as the W3C. The owner of 
					the code system is clearly identified. The <termref ref="dt-OID">OID</termref> (Object Identifier) for the code system is also
					clearly specified. Note that OIDs are subject to ongoing revision; the OID published
					in this specification is correct at the time that this specification is published.
					The Core Principles of V3 Models [<loc href="../coreprinciples/v3modelcoreprinciples.htm" xlink-form="simple" show="embed" actuate="auto"/>] 
					document discusses OID management in depth. Unless otherwise specified, the name of the code system
					is the same as the name of the domain.
				</p>
				<p>
					Where possible, a set of illustrative codes from the code system will be provided. 
					For externally defined code systems, the actual contents
					of the domain are defined on an on-going basis by the external body. In the 
					case of HL7 defined domains, the contents of the code systems are subject to on-going
					changes by harmonisation. This document lists the code system definitions as they were when the
					document was published, but more recent versions of the contents published by HL7 may be used
					with the data types defined herein, unless otherwise indicated.
				</p>
				<p>
					The list of illustrative codes is shown in tables containing columns representing code, name, 
					definition, and either status or level. Note that Status and level are not incompatible, but no circumstance where a combination
					of the two is useful has arisen. The table has a caption which names the concept domain, specifies the OID of 
					the associated code system, and names the owner of the code system.
				</p>
				<p>
					The code systems presented in this specification are all hierarchical in nature. The hierarchy represents subsumption, except in the case of AddressPartType
					where the hierarchy is compositional in nature. In a compositional hierachy, codes represented as child codes of another code represent parts of the concept 
					represented by the parent code; whereas in a subsumption heirarchy, the child codes represent a more specialised meaning than the parent code.
				</p>
				<p>
					<emph>code</emph>: The code column contains the symbol that goes in the
					<termref ref="dt-CD">CD</termref>.<termref ref="prop-CD.code">code</termref> property,
					and that is actually exchanged in the instance in order to represent the concept.
					Subsumption or composition within the code system hierarchy is shown by indenting 
					the code.
				</p>
				<p>
					<emph>name</emph>: The name column contains a descriptive name for the
					concept, and is a suitable value for use in the 
					<termref ref="dt-CD">CD</termref>.<termref ref="prop-CD.displayName">displayName</termref> property.
				</p>
				<p>
					<emph>definition</emph>: The definition specifies the meaning of the concept, along with clarifying 
					information and usage notes.
				</p>
				<p>
					<emph>status</emph>: For some domains, HL7 stipulates whether implementation of specific 
					concepts is prohibited, permitted, or required.
				</p>
				<p>
					<emph>level</emph>: The level column (labelled "lvl") is a value that 
					represents the depth of the subsumption or composition of the current concept. This is 
					only provided to help readers navigate the tables; it has no other meaning.
				</p>
				<p>
					Some concepts are abstract, and are only defined to allow 
					the relationships of other concepts to be defined. These concepts have a 
					code of "--" shown. Since multiple abstract concepts may exist that 
					subsume or compose the same concrete concept, a concept may be listed more than 
					once in the definition of the domain. 
				</p>
			</div2>
			<div2 id="datyp2introform">
				<head>Formal Data Type Definition Language (DTDL)</head>
				<p>
					We define a formal data type definition language in order to specify 
					the semantics of the proposed types as unambiguously as possible. A specific 
					abstract syntax is required because other syntaxes are either specific to a technology
					or dependent on their own type libraries and conventions.   
					Formal languages make essential statements crisply and 
					are therefore accessible to formal argument of proof or rebuttal. However, 
					the terseness of such formal statements may also be difficult to
					understand. Therefore, all the important inferences from the
					formal statements are also included as plain English statements.
				</p>
				<note role="Disclaimer">
					<p>
						<emph role="strong">This is not an API specification.</emph> While
						this formal language might resemble a programming language or
						interface definition language, it is not intended to define the
						details of programs and other means of implementation. The formal
						definitions are a normative part of this specification, but this
						particular language need not be implemented or used in conformant
						systems; nor need all the semantic properties be implemented or used
						by conformant systems. The internal working of systems, their way of
						implementing data types, and <emph role="strong">their functionality and
						services is entirely out of scope of this specification. The formal
						definition defines the meaning</emph> of the data values
						through statements defining semantic relationships and behavior.
						Property definitions resemble programmatic function or method 
						definitions, but the resemblance does not imply any procedural machinery.
					</p>
					<p>
						The DTDL borrows from a variety of existing tools and specifications, including 
						Interface Definition Language (IDL), the Object Constraint Language (OCL), 
						JAVA, C++, and the parser generation tools LEX and YACC, to meet the key 
						objectives of semantic descriptiveness, internal consistency, syntactical 
						agnosticism, freedom from built-in or primitive types, and concision.
					</p>
				</note>
				<p>
					This formal data type definition language specifies:
				</p>
				<list role="unordered">
					<item>
						type name and short name
					</item>
					<item>
						named values of a fully enumerated extension
					</item>
					<item>
						semantic properties, unary, binary, and higher order properties
					</item>
					<item>
						invariants, i.e. constraints over the properties
					</item>
					<item>
						allowable type conversions
					</item>
					<item>
						syntax of character string value literals (if any)
					</item>
					<item>
						additional constraints on the types as flavors
					</item>
				</list>
				<p>
					Definition of a data type occurs in two steps. First, the data type is
					declared. The declaration claims a name for a new data type with a
					list of names, types, and signatures of the new type's 
					properties. This declares the type, but not does not define it. The definition occurs
					in logic statements about what is always true about this type's
					values and their properties (invariant statements).
				</p>
				<div3 id="decl">
					<head>Declaration</head>
					<p>
						Every data type is declared in a form that begins with the keyword 
						<emph role="strong">type</emph>. For example, the following is the 
						header of a declaration for the data type Boolean  which has the short 
						name <termref ref="dt-BL">BL</termref> and specializes the data type
						ANY.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
type Boolean alias BL specializes ANY
   values(true, false)
{
     BL  not;
     BL  and(BL x);
     BL  or(BL x);
     BL  xor(BL x);
     BL  implies(BL x);
};</pre>
					</exhibit>
					<p>
						The Boolean data type declaration also contains a
						<emph role="strong">values</emph> clause that declares the Boolean's
						complete set of values (its extension) as named entities. These named
						values are also valid character string literals. None of the other
						data types defined in this specification has a finite value set, which
						is why the <emph role="strong">values</emph> clause is unique to the
						Boolean. 
					</p>
					<p>
						The block in curly braces following the header contains declarations
						of the semantic properties that hold for every value of the data
						type. A semicolon terminates each property declaration; and another
						semicolon after the closing curly brace terminates the data type
						declaration.
					</p>
					<p>
						A property declaration specifies from left to right (1) the data type
						of the property's value domain, (2) the property name, and (3) an optional
						argument list. The argument list of a property is enclosed in
						parentheses containing a sequence of argument declarations. Each
						argument is declared by the data type name and argument name. Semantic
						properties without arguments do not use an empty argument
						list.
					</p>
					<p>
						The <emph role="strong">specializes</emph> clause implies (a)
						inheritance of properties from the genus to the species, and (b)
						substitutability of values of the species type for variables of the
						genus type. Specialization can include the definition of additional
						properties and the specification of constraints on inherited
						properties for the specialized type.
					</p>
					<p>
						An example for inheritance: <termref ref="dt-CD">CD</termref> has the constraint
						that every nonNull <termref ref="dt-CD">CD</termref> must have a code. Because <termref ref="dt-CS">CS</termref>
						specializes <termref ref="dt-CD">CD</termref>, every <termref ref="dt-CS">CS</termref> must also have
						a code if it is nonNull, even though this constraint is not made 
						explicit in the definition of <termref ref="dt-CS">CS</termref> itself. Note that a 
						type can be declared to specialize a flavor rather than a type. This means
						that the type inherits from the base type that the flavor constrains, and 
						in addition is subject to the constraints defined for the flavor.
					</p>
					<p>
						An example for substitutability: A property is declared as of data
						type <termref ref="dt-ED">ED</termref>. Because <termref ref="dt-ST">ST</termref> specializes
						<termref ref="dt-ED">ED</termref>, then a value of such property MAY be of type
						<termref ref="dt-ST">ST</termref>. In other words, substitutability is the same as
						subsumption of all values of type <termref ref="dt-ST">ST</termref> being also values
						of type <termref ref="dt-ED">ED</termref>.
							</p>
					<p>
								It is generally agreed that inheritance should not retract properties defined 
								for the genus.  However, because a child type may constrain the properties 
								of a parent type, it is possible for a child to constrain a property to the 
								null value without retracting the property.
							</p>
					<p>
						The <emph role="strong">type</emph> declaration may be qualified by
						the keyword <emph role="strong">abstract</emph>, <emph role="strong">protected,</emph>, or <emph role="strong">private</emph>. An abstract type is a type where no
						non-exceptional value can be of this type: a proper value MUST belong to a concrete
						specialization of the abstract type. A protected type is a type that is
						used inside this specification but no property outside this
						specification should be declared of a protected type. A private type
						is an internal "helper" abstraction, defined only for the purpose of
						defining some aspect of the semantics of data types but that is not
						used even as the type of another protected or public type's
						property.<footnote>
							<p>
								Note the meaning of protected is a little different from the
								accessibility qualifiers (public, package, protected, private) as
								known from JAVA and C++. The protection used here is not about hiding
								the type information or barring properties defined by a protected type
								from access outside of this specification "package."  It mainly is a
								strong recommendation not to declare attributes or other features of
								such protected types. Protected types should be used as "wrapped" in
								other types. The protected type is still directly accessible within
								the "wrap," no notion of "delegated properties" exists.
							</p>
						</footnote>
					</p>
				</div3>
				<div3 id="invs">
					<head>Invariant Statements</head>
					<p>
						The declaration of semantic properties, their names, data types, and
						arguments provide only clues as to what the new data type might be
						about. The true definition lies in the invariant statements. Invariant
						statements are logical statements that are true at all times.
					</p>
					<p>
						Throughout this specification, invariant statements are provided in a
						formal syntax but are also written in plain English. The advantage of
						the formal syntax is that it can be interpreted unambiguously, and
						that it is strongly typed. The advantage of plain English statements
						is that they are more understandable, especially to those untrained in
						reading formal languages.
					</p>
					<p>
						The formal syntax sharpens the decisiveness of this
						specification. In some cases, however, the full semantics of a type
						are beyond what can be fully expressed in such invariant
						statements. The combination of both plain and formal language makes
						this specification more clear.
					</p>
					<p>
						Invariant statements are formed using the 
						<emph role="strong">invariant</emph> keyword that declares one or more
						variables in the form of an argument list of a property. The
						invariant statement can contain a <emph role="strong">where</emph>
						clause that constrains the arguments for the invariant
						body. The invariant body is enclosed in curly braces. It contains a
						list of assertions that must all be true.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(BL x)
      where x.nonNull {
   x.and(true).equal(x);
};</pre>
					</exhibit>
					<p>
						The semantics of the invariant statement is a logic predicate with a
						universal quantifier ("for all").
					</p>
					<p>
						The above invariant statement can be read in English as "For all
						Boolean values x, where x is non-NULL it holds that x AND
						<emph>true</emph> equals x."  All properties should be named such that
						one can read the assertions like English sentences by substituting 
						appropriate english words for the syntactical elements such as dot 
						notation for property access. Note that some familiarity with reverse
						polish notation is useful in this regard.
					</p>
					<p>
						The argument list of an invariant statement need not be specified if no such 
						argument is needed.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant {
   true.not.equal(false);
   false.not.equal(true);
};</pre>
					</exhibit>
					<div4 id="assert">
						<head>Assertion Expressions</head>
						<p>
							Assertions in invariant statements are expressions built with the
							semantic properties of the data types defined in this specification. Assertion expressions MUST
							have a Boolean value (<emph>true</emph> or
							<emph>false</emph>).
							No primitive data types, or operations, pre-exist the definition of
							any data type. The only preexisting features of the assertion
							expression language are the following:<footnote>
								<p>
									Most of these syntactic features are in the spirit of the JAVA
									language, use of argument lists, curly braces to enclose blocks,
									semicolon to finish a statement, and the period to reference value
									properties. The double colon :: as used by C++ or IDL to distinguish
									between member-references and value-references are not used (as in
									Java). Unlike Java but like C++ and IDL, every statement is ended by a
									semicolon, including type declarations. Implicit type conversion is
									also retained from C++.
								</p>
							</footnote>
						</p>
						<list role="unordered">
							<item>
								character strings representing utterances in the data type definition
								language;
							</item>
							<item>
								the notion of an assertion being successful (<emph>true</emph>) or
								failing (<emph>false</emph>);
							</item>
							<item>
								the invariant statement: <emph role="strong">invariant</emph>(...)
								<emph role="strong">where</emph> ... {...};
							</item>
							<item>
								the universal quantifier expression form <emph role="strong">forall</emph>
								(...) <emph role="strong">where</emph>
								... {...}; synonymous to the invariant statement;
							</item>
							<item>
								the existence quantifier expression form <emph role="strong">exists</emph>
								(...) <emph role="strong">where</emph>
								... {...};
							</item>
							<item>
								the implicit conjunction (logical AND) between the semicolon-separated
								<emph>assertions</emph>: <emph>assertion</emph>
								<emph role="sub">1</emph>; <emph>assertion</emph>
								<emph role="sub">2</emph>; ... ; <emph>assertion</emph>
								<emph role="sub">n</emph>;
							</item>
							<item>
								variables and declarations in the invariant argument list;
							</item>
							<item>
								the property reference using the period: <emph>x.property</emph>;
							</item>
							<item>
								implicit and explicit type conversion: <emph role="strong">(</emph>
								<emph>T</emph>
								<emph role="strong">)</emph>
								<emph>x</emph>;
							</item>
							<item>
								parentheses to override the priorities of the conversion and property
								resolution operators: (<emph>T</emph>)<emph>x.property</emph>
								versus((<emph>T</emph>)<emph>x</emph>)<emph>.property</emph>.
							</item>
						</list>
						<p>
							It is because the entities upon which this syntax operates are themselves 
							data types that the specification is fundamentally recursive.
						</p>
					</div4>
					<div4 id="nested">
						<head>Nested Quantifier Expressions</head>
						<p>
							A quantifier expression indicates the scope of an assertion:  it is true 
							for all scenarios (universal quantifier), no scenarios (prohibition), or 
							for at least one (existential).  The invariant statement is a universal 
							quantifier.  Quantifiers can be nested within assertion expressions
							to articulate complex requirements.  In the following example, the outer 
							statement regarding the set x contains an inner statement about the elements T of x.
						</p>
						<exhibit role="dtdl">
							<caption/>
							<pre>
invariant(SET&lt;T&gt; x, y)
      where x.nonNull {
   x.subset(y).equal(
      forall(T element) where x.contains(element) {
         y.contains(element);
         });
};</pre>
						</exhibit>
						<p>
							The existence quantifier has the same meaning as in common propositional
							logic. For example, the following invariant means: "SET values
							<emph>x</emph> and <emph>y</emph> intersect if and only if there
							exists an element <emph>e</emph> that is contained in both sets
							<emph>x</emph> and <emph>y</emph>."
						</p>
						<exhibit role="dtdl">
							<caption/>
							<pre>
invariant(SET x, y)
      where x.nonNull {
   x.intersects(y).equal(
      exists(T e) {
         x.contains(e);
         y.contains(e);
         });
};</pre>
						</exhibit>
						<p>
							The existence quantifier may have a where-clause; however, there is no
							difference whether an assertion is made as a where-clause or in the
							body of the existence quantifier. Conversely, for universal
							quantifiers, the where-clause weakens the assertion since the body now
							only applies for values that meet the criterion in the where-clause.
						</p>
					</div4>
				</div3>
				<div3 id="typconv">
					<head>Type Conversion</head>
					<p>
						This specification defines certain allowable conversions between data
						types. For example, there are a pair of conversions between the
						Character String (<termref ref="dt-ST">ST</termref>) and Encode Data (<termref ref="dt-ED">ED</termref>). 
						This means that if a one expects an <termref ref="dt-ED">ED</termref>
						value but actually encounters an <termref ref="dt-ST">ST</termref> value instead, one can
						convert the <termref ref="dt-ST">ST</termref> value into an <termref ref="dt-ED">ED</termref>.
					</p>
					<p>
						Three kinds of type conversions are defined: promotion, demotion, and
						character string literals. Type conversions can be implicit or
						explicit. Implicit type conversion occurs when a certain type is
						expected (e.g. as an argument to a statement) but a different type is
						actually provided. If the type provided has a conversion to the type
						expected the conversion should be performed implicitly.
					</p>
					<note role="ITS">
						<p>
							Implementation Technology Specifications must specify how
							implicit type conversions are supported. Some technologies support it
							directly, while others do not; in any case, processing rules can be defined that
							specify how these conversions are realized.
						</p>
					</note>
					<p>
						An explicit conversion can be specified in an assertion expression
						using the converted-to type name in parenthesis before the converted
						value. For example the following is an explicit type conversion from ED to ST in the
						where clause of an invariant statement.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(ED x)
   where ((ST)x).nonNull { ... };</pre>
					</exhibit>
					<p>
						The type conversion has lower order of precedence than the property resolution
						period. Thus "(<emph>T</emph>)a.<emph>b</emph> " converts the value of
						the property <emph>b</emph> of variable a to data type <emph>T</emph>
						while "((<emph>T</emph>)a).<emph>b</emph> " converts the value of
						variable a to <emph>T</emph> and then references property
						<emph>b</emph> of that converted value.
					</p>
					<p>
						Implicit type conversions in the assertion expressions are performed
						where possible. If a property's formal argument is declared of data
						type <emph>T</emph>, but the expression used as an actual argument is
						of type <emph>U</emph>, and if <emph>U</emph> does not extend
						<emph>T</emph>, and if <emph>U</emph> defines a conversion to
						<emph>T</emph>, that conversion from <emph>T</emph> to <emph>U</emph>
						takes effect.
					</p>
					<div4 id="demotion">
						<head>Demotion</head>
						<p>
							A demotion is a conversion with a net loss of information. Generally,
							this means that a more complex type is converted into a simple type.
						</p>
						<p>
							An example for a demotion is the conversion from Interval 
							(<termref ref="dt-IVL">IVL</termref>) to a simple Quantity (<termref ref="dt-QTY">QTY</termref>), e.g. the
							center of the interval. In the data type definition language, a
							demotion is declared using the keyword <emph role="strong">demotion</emph> 
							and the data type name to which to demote:
						</p>
						<exhibit role="dtdl">
							<caption/>
							<pre>
type Interval alias IVL {
   ...
   demotion  QTY;
   ...
};</pre>
						</exhibit>
						<p>
							The specification of demotions SHALL indicate what information is lost
							and what the major consequences of losing this information are.
						</p>
					</div4>
					<div4 id="promotion">
						<head>Promotion</head>
						<p>
							A promotion is a conversion where new information is
							generated. Generally, this means that a simpler type is converted into
							a more complex type.
						</p>
						<p>
							For example, we allow any Quantity (<termref ref="dt-QTY">QTY</termref>) to be
							converted to an Interval (<termref ref="dt-IVL">IVL</termref>). However, 
							<termref ref="dt-IVL">IVL</termref> has more semantic properties than
							<termref ref="dt-QTY">QTY</termref>, including low
							and high boundaries. Thus, the conversion of <termref ref="dt-QTY">QTY</termref> to
							<termref ref="dt-IVL">IVL</termref> is a promotion. The additional properties of 
							<termref ref="dt-QTY">QTY</termref> not present in <termref ref="dt-IVL">IVL</termref> must assume new 
							values, default values, or computed values. The specification of the promotion
							must indicate what these values are or how they can be generated.
						</p>
						<p>
							A promoting conversion from type <termref ref="dt-QTY">QTY</termref> to type 
							<termref ref="dt-IVL">IVL</termref> is defined as a semantic property of data type 
							<termref ref="dt-QTY">QTY</termref> using the keyword promotion and the data type name to
							which to promote:
						</p>
						<exhibit role="dtdl">
							<caption/>
							<pre>
type Quantity alias QTY {
   ...
   promotion  IVL;
   ...
};</pre>
						</exhibit>
						<p>
							Typically, a promotion is defined from a simple type to a more complex
							type. Also, typically, the simple type is declared earlier in this
							document than a more complex type. Declaring all promotions to complex
							types in the simple type would thus involve forward references in the document, and
							may be confusing to the reader. Therefore, an alternative syntax
							allows promotions to be defined in the more complex type. This is
							indicated by naming the type from which to promote in an argument list
							behind the type to which to promote.
						</p>
						<exhibit role="dtdl">
							<caption/>
							<pre>
type Interval alias IVL {
   ...
   promotion  IVL (QTY x);
   ...
};</pre>
						</exhibit>
					</div4>
				</div3>
				<div3 id="literalFormIntro">
					<head>Literal Form</head>
					<p>
						A literal is a character string representation of a data
						value. Literals are defined for many types. A literal is a type
						conversion from and to a Character String (<termref ref="dt-ST">ST</termref>) with a
						specially defined syntax.
					</p>
					<p>
						Not every conversion from and to an <termref ref="dt-ST">ST</termref> is a literal
						conversion, however. A literal for a data type should be able to
						represent the entire value set of a data type whereas any other
						conversion to and from <termref ref="dt-ST">ST</termref> may only map a smaller subset
						of the converted data type.
					</p>
					<p>
						The purpose of having literals is so that one can write down values in
						a short, human-readable form. For example, literals for the types
						integer number (<termref ref="dt-INT">INT</termref>) and real number 
						(<termref ref="dt-REAL">REAL</termref>) are strings of sign, digits, possibly a decimal
						point, etc. The more important interval types 
						(<termref ref="dt-IVL">IVL</termref>&lt;<termref ref="dt-REAL">REAL</termref>&gt;,
						<termref ref="dt-IVL_PQ">IVL&lt;PQ&gt;</termref>, <termref ref="dt-IVL_TS">IVL&lt;TS&gt;</termref>)
						have literal representations that allow one to use, e.g., "&lt;5" to
						mean "less than 5", which is much more readable than a fully
						structured form of the interval. For some of the more advanced data
						types such as intervals, general timing specification, and parametric
						probability distribution, we expect that the literal form may be the
						only form seen for representing these values until users have become
						used to the underlying conceptualizations.
					</p>
					<p>
						Each literal conversion has its own syntax (grammar), often aligned
						with what people find intuitive. This syntax may therefore not be
						the most obvious from a computing perspective.
					</p>
					<note role="ITS">
						<p>
							Character string based Implementable Technology Specifications (ITS)
							of these abstract data types may or may not choose the literals
							defined here as their representations for these data types. We expect
							that the XML ITS will use some but not all of the literals defined
							here.
						</p>
						<p>
								The different grammars of literals are not meant to be combined into
								one overall HL7 value expression grammar. Although attempts have been
								made to resolve potential ambiguities between the literals of
								different types where they would be harmful, some of these ambiguities
								still remain. For example "1.2" can be a valid literal for both Object
								Identifier (<termref ref="dt-OID">OID</termref>) and a Real Number.
							</p>
					</note>
					<div4 id="decls">
						<head>Declaration</head>
						<p>
							In the data type definition language we declare a literal form as a
							property of a data type using the keyword "literal" followed by the data
							type name <termref ref="dt-ST">ST</termref>, since the literal is a conversion to and
							from the <termref ref="dt-ST">ST</termref> data type.
						</p>
						<exhibit role="dtdl">
							<caption/>
							<pre>
type IntegerNumber alias INT {
   ...
   literal  ST;
   ...
};</pre>
						</exhibit>
					</div4>
					<div4 id="defns">
						<head>Definition</head>
						<p>
							The actual definition of the literal form occurs outside the data type 
							declaration body using an attribute grammar. An attribute grammar is a grammar 
							that specifies both syntax and semantics of language structures. The syntax is 
							defined in essentially the Backus-Naur-Form (BNF).<footnote>
								<p>
									The BNF variant used here is similar to the YACC parser and LEX lexical
									analyzer generator languages but is simplified and made consistent to the 
									syntax and declarative style of this data type definition language. The 
									differences are that all symbols have exactly one attribute, their value 
									strongly typed as one of the defined data types. Each symbol's type is 
									declared in front of the symbol's definition (e.g.: INT digit : "0" | "1" | 
									... | "9";). The start symbol has no name but just a type (e.g., INT : digit |
									INT digit;). A data type name can occur as a symbol name meaning a literal of 
									that data type.
								</p>
							</footnote>
						</p>
						<p>
							For example, consider the following simple definition of a data type
							for cardinal numbers (positive integers).  This type definition
							depends only the Boolean data type (<termref ref="dt-BL">BL</termref>) and has a
							character string literal declared:
						</p>
						<exhibit role="dtdl">
							<caption/>
							<pre>
type CardinalNumber alias CARD {
   BL       isZero;
   BL       equal(ANY x);
   CARD     successor;
   CARD     plus(CARD x);
   CARD     timesTen;
   literal  ST;
};</pre>
						</exhibit>
						<!-- Converted to bullet item from fifth-level heading -->
						<!-- pvb: 20050804: list removed completely
						<list role="unordered">
							<item>
								Syntax Definition
							</item>
						</list>
   -->
						<p>
							The literal syntax and semantics is first exposed completely and then
							described in all detail. The following example shows a literal
							consisting of two syntactic rules, each including several semantic definitions. 
						</p>
						<exhibit role="dtdl">
							<caption/>
							<pre>
CARD.literal ST {
   CARD : CARD digit  { $.equal($1.timesTen.plus($2); }
        | digit       { $.equal($1); };

   CARD digit : "0"   { $.isZero; }
              | "1"   { $.equal(0.successor); }
              | "2"   { $.equal(1.successor); }
   ...
              | "8"   { $.equal(7.successor); }
              | "9"   { $.equal(8.successor); }
};</pre>
						</exhibit>
						<p>
							Every syntactic rule consists of the name of a symbol, a colon and the
							definition (so called <emph>production</emph>) of the symbol. A
							production is a sequence of symbols. These other symbols are also
							defined in the grammar, or they are terminal symbols. Terminal symbols
							are character strings written in double quotes or string patterns
							(called <emph>regular expressions</emph>).  Thus the form:
						</p>
						<exhibit role="dtdl">
							<caption/>
							<pre>
CARD : CARD digit
     | digit;</pre>
						</exhibit>
						<p>
							means, that any cardinal number symbol is a cardinal number symbol
							followed by a digit or just a digit. The vertical bar stands for a
							disjunction (logical OR).  A syntactic rule ends with a semicolon.
						</p>
						<p>
							Every symbol has exactly one value of a defined data type. The data
							type of the symbol's value is declared where the symbol is defined:
						</p>
						<exhibit role="dtdl">
							<caption/>
							<pre>
CARD digit : "0"
           | "1"
           | "2"
           | ...
           | "8"
           | "9";</pre>
						</exhibit>
						<p>
							means that the symbol <emph>digit</emph> has a value of type
							CARD. The start-symbol is the data type itself and does not need a
							separate name.
						</p>
						<!-- Converted to bullet item from fifth-level heading -->
						<!-- pvb: 20050804: list removed completely
						<list role="unordered">
							<item>
								Semantics Definition
							</item>
						</list>
  -->
						<p>
							The semantics of the literal expression is specified in semantic rules
							enclosed in curly braces for each of the defined productions of a
							symbol:
						</p>
						<p>
							<emph>symbol</emph>
							<emph role="strong"> : </emph>
							<emph>production</emph>
							<emph role="sub">1</emph>
							<emph role="strong"> { </emph>
							<emph>rule</emph>
							<emph role="sub">1</emph>
							<emph role="strong"> } </emph>
							<emph role="strong"> | </emph>
							<emph>production</emph>
							<emph role="sub">2</emph>
							<emph role="strong"> { </emph>
							<emph>rule</emph>
							<emph role="sub">2</emph>
							<emph role="strong"> } </emph>
							<emph role="strong"> | </emph>
							... <emph role="strong"> | </emph>
							<emph>production</emph>
							<emph role="sub">
								<emph>n</emph>
							</emph>
							<emph role="strong"> { </emph>
							<emph>rule</emph>
							<emph role="sub">
								<emph>n</emph>
							</emph>
							<emph role="strong"> };</emph>
						</p>
						<p>
							A semantic rule is simply a semicolon-separated list of Boolean
							assertion expressions of the same kind as those used in invariant
							statements. However, there are special variables defined in the
							semantic rule that all begin with a dollar character (e.g., $, $1, $2,
							$3, ...)  The simple $ stands for the value of the currently defined
							symbol; while $1, $2, $3, etc. stand for the values of the respective parts of
							the semantic rule's associated production. For example, in
						</p>
						<exhibit role="dtdl">
							<caption/>
							<pre>
CARD : CARD digit  { $.equal($1.timesTen.plus($2); }
     | digit       { $.equal($1); };</pre>
						</exhibit>
						<p>
							the first production "CARD digit" has a semantic rule that says: the
							value $ of the defined symbol equals the value $1 of the first symbol
							CARD times ten plus the value $2 of the second symbol digit.<footnote>
								<p>
								Note that the equal property (defined for all data types, see
								<termref ref="prop-ANY.equal">equal</termref>) is a relation, a test for equality, not an 
								assignment statement. One can not assign a value to another value. Unlike YACC
								and LEX analyzers, this data type definition language is purely
								declarative it has no concept of assignment. For this reason, the
								grammar rules define both parsing and building literal expressions.
							</p>
							</footnote>
						</p>
						<!-- Converted to bullet item from fifth-level heading -->
						<!-- pvb: 20050804: list removed completely
						<list role="unordered">
							<item>
								Terminal Symbols
							</item>
						</list>
  -->
						<p>
							A terminal symbol can be specified as a string pattern, so-called
							<emph>regular expression</emph>. The regular expression syntax used
							here is the classic syntax invented by Aho and used in AWK, LEX, GREP,
							and Perl. Regular expressions appear between two slashes 
							<emph role="strong">/</emph>...<emph role="strong">/</emph>. In a regular
							expression pattern every character except <emph role="strong">[ ] ^ $
							. / : ( ) \ | ? * + { }</emph> matches itself. The other characters
							that are actually used in this specification are defined in 
							<tabref ref="special-regex-chars"/>.
						</p>
						<table id="special-regex-chars">
							<caption>Special Characters for Regular Expressions</caption>
							<col width="0.69" span="1"/>
							<col width="5.06" span="1"/>
							<thead>
								<tr>
									<th rowspan="1" colspan="1">Pattern</th>
									<th rowspan="1" colspan="1">Definition</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td rowspan="1" colspan="1">[ ... ]</td>
									<td rowspan="1" colspan="1">
										Specifies a character class. For example, /[A-Za-z]/ 
										matches the characters of the upper and lower case English
										alphabet.
									</td>
								</tr>
								<tr>
									<td rowspan="1" colspan="1">[^ ...]</td>
									<td rowspan="1" colspan="1">
										Specifies a character class negatively. For example, 
										/[^BCD]/ matches any character except B, C, and D.
									</td>
								</tr>
								<tr>
									<td rowspan="1" colspan="1">...?</td>
									<td rowspan="1" colspan="1">
										The preceding pattern is optional. For example, /ab?c/ 
										matches  "ac" and "abc".
									</td>
								</tr>
								<tr>
									<td rowspan="1" colspan="1">...*</td>
									<td rowspan="1" colspan="1">
										The preceding pattern may occur zero or many times. For 
										example, /ab*c/ matches  "ac", "abc", "abbc", "abbbc",
										etc.
									</td>
								</tr>
								<tr>
									<td rowspan="1" colspan="1">...+</td>
									<td rowspan="1" colspan="1">
										The preceding pattern may occur one or more times. For 
										example, /ab+c/ matches "abc", "abbc", "abbbc", but not 
										"ac".
									</td>
								</tr>
								<tr>
									<td rowspan="1" colspan="1">... {n,m}</td>
									<td rowspan="1" colspan="1">
										The preceding pattern may occur <emph>n</emph> to 
										<emph>m</emph> times where <emph>n</emph> and <emph>m</emph> 
										are cardinal numbers 0 ( <emph>n</emph> ( <emph>m</emph>. 
										For example, /ab{2,4}c/ matches "abbc", "abbbc", and 
										"abbbbc".
									</td>
								</tr>
								<tr>
									<td rowspan="1" colspan="1">... | ...</td>
									<td rowspan="1" colspan="1">
										The pattern on either side of the bar may match. For 
										example, /ab|cd/ matches "abd" and "acd" but not "abcd".
									</td>
								</tr>
								<tr>
									<td rowspan="1" colspan="1">( ... )</td>
									<td rowspan="1" colspan="1">
										The pattern in parentheses is used as one pattern for 
										the above operators. For example, /a(bc)*/ matches "a", 
										"abc", "abcbc", "abcbcbc", etc.
									</td>
								</tr>
								<tr>
									<td rowspan="1" colspan="1">... : ...</td>
									<td rowspan="1" colspan="1">
										The left pattern matches if followed by the right 
										pattern, but the right pattern is not consumed by a match. 
										For example, /ab:c/ matches "abc" but not "ab", however,
										the value of a symbol thus matched is "ab" and the "c" is 
										left over for the next symbol. The colon is a slight 
										deviation from the conventional slash / but the slash is 
										also conventionally used to enclose the entire pattern and 
										may occur as a character to match - three meanings is one 
										too many.
									</td>
								</tr>
								<tr>
									<td rowspan="1" colspan="1">... \ ...</td>
									<td rowspan="1" colspan="1">
										Matches the following character literally, i.e. escapes
										from any special meaning of that character. For example, 
										/a\+b/ matches "a+b".
									</td>
								</tr>
								<tr>
									<td rowspan="1" colspan="1">... \/ ...</td>
									<td rowspan="1" colspan="1">
										Matches the slash as a character. For example, /a\/bc/ 
										matches "a/bc".
									</td>
								</tr>
							</tbody>
						</table>
					</div4>
				</div3>
				<div3 id="generics">
					<head>Generic Data Types</head>
					<p>
						Generic data types are incomplete type definitions. This
						incompleteness is signified by one or more <emph>parameters</emph> to
						the type definition, which stand for other types, using the keyword <emph>template</emph>. Using
						parameters, a generic type might declare semantic properties that are
						not fully specified. For example, the generic data type
						Interval is declared with a parameter <emph>T</emph> that can stand
						for any Quantity data type (<termref ref="dt-QTY">QTY</termref>). The properties
						<emph>low</emph> and <emph>high</emph> are declared as being of type
						<emph>T</emph>.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
template&lt;QTY T&gt;
type Interval&lt;T&gt; alias IVL&lt;T&gt; {
   T  low;
   T  high;
};</pre>
					</exhibit>
					<p>
						Instantiating a generic type means completing its definition. For
						example, to instantiate an Interval, one SHALL specify of what base
						<emph>data type</emph> the interval should be. This is done by
						<emph>binding</emph> the parameter <emph>T</emph> to a specific data type. To instantiate an
						Interval of Integer numbers, one would bind the parameter
						<emph>T</emph> to the type Integer. Thus, the incomplete data type
						Interval is completed to the data type <emph>Interval of
						Integer</emph>.
					</p>
					<p>
						For example, the following type definition for MyType declares a
						property named "multiplicity" that is an interval of the integer
						number data type used in the above examples.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
type MyType alias MT {
   IVL&lt;INT&gt;  multiplicity;
};</pre>
					</exhibit>
					<p>
						A type parameter MAY have a default type associated with it. This default
						type is implied if no other parameter is bound when the type is associated.
						In the following example, a default parameter type has been used to specify
						exactly the same outcome as the previous example.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
template&lt;QTY T = INT&gt;
type Interval&lt;T&gt; alias IVL&lt;T&gt; {
   T  low;
   T  high;
};

type MyType alias MT {
   IVL       multiplicity;
};</pre>
					</exhibit>
					<p>
						Default types for parameters requires care on the part of the users, and this 
						technique is used sparingly in this specification.
					</p>
					<p>
						Generics SHALL have types specified for each parameter prior to being instantiated.
						The types MAY be supplied in this specification, in any dependent specification, 
						or even at run-time: that is, an ITS may allow the use of a generic type that 
						leaves the parameter type unspecified until it is used.
					</p>
					<div4 id="collections">
						<head>Generic Collections</head>
						<p>
							Generic data types for collections are used throughout this
							specification. The most important of them are:
						</p>
						<p>
							<emph role="strong">Set</emph> (<termref ref="dt-SET">SET</termref>&lt;T&gt;)  A
							set contains elements in no particular order and without duplicate
							elements. There are two specializations of <termref ref="dt-SET">SET</termref>: 
							<termref ref="dt-DSET">DSET</termref>, for sets composed from discrete elements
							that may be iterated, and <termref ref="dt-QSET">QSET</termref>, for sets composed 
							of items from continuous domains, such as <termref ref="dt-REAL">REAL</termref>.
						</p>
						<p>
							<emph role="strong">Sequence</emph> 
							(<termref ref="dt-LIST">LIST</termref>&lt;T&gt;)  A sequence is a collection of
							values in a specified order. A sequence has a head and
							a tail, where the head is the first element and the tail is the sequence
							without its head.
						</p>
						<p>
							<emph role="strong">Interval</emph> 
							(<termref ref="dt-IVL">IVL</termref>)&lt;T&gt;  An interval is a continuous subset
							of an ordered type.
						</p>
						<p>
						    These generic data types and their
							properties are used in this specification and readers should understand these types to understand this specification completely.
						</p>
					</div4>
					<div4 id="mixins">
						<head>Generic Type Extensions</head>
						<p>
							Generic data type extensions are generic types with one parameter type
							that the generic type specializes. In the formal data type definition
							language, generic type specializations follow the pattern:
						</p>
						<note role="ITS">
							<p>
					Values of such extended types MAY be substituted for their base
					type. However, an ITS MAY limit what extensions
					are supported.
				</p>
						</note>
						<p>
					At this time generic type extensions
					SHALL NOT be used except where the type of an attribute is assigned
					to ANY, or the use is explicitly enabled (in this or another
					HL7 specification) for use cases where this advanced
					functionality is important. In these cases, instances of these generic
					type extensions SHALL be specifically and explicitly reflected in the
					RIM, static models or other specifications as applicable, as a result
					of formally approved content.<footnote>
								<p>
							In so doing, this specification
							imposes a self-restraint upon itself to allow existing systems a
							graceful transition. However, the formal specification keeps the
							generic type extensions as substitutable for their base types. This
							self-restraint may be omitted in the future. New implementations may
							invest in accommodating some generalizable support for these generic
							data type extensions.
						</p>
							</footnote>
						</p>
						<p> 
					Generic extensions keep their properties when specialized or subtended by generic collections. If a generic extension that extends <termref ref="dt-QTY">QTY</termref> is
					applied to a <termref ref="dt-QSET">QSET</termref> type parameter or specialization, the generic extension
					can be used throughout the <termref ref="dt-QSET">QSET</termref> on any value contained 
					within the expression tree.					
				</p>
						<exhibit role="dtdl">
							<caption/>
							<pre>
template&lt;ANY T&gt;
type GenericTypeExtensionName specializes T {
   ...
};</pre>
						</exhibit>
						<p>
				These generic type extensions inherit the properties of their
				base type and add some specific	feature to it. The generic type extension
				is a specialization of the base type, thus a value of the extension data
				type can be used instead of its base data type.<footnote>
								<p>
									Generic type extensions are sometimes called "mixins", since their
									effect is to mix certain properties into the preexisting data type.
								</p>
							</footnote>
						</p>
						<p>
				While a Generic Type Extension extends its base&#8212;or parameter type&#8212;in effect annotating
				it with additional properties, it does not modify the interface of the of the base 
				parameter type.
				
				However the Generic Type Extension, while not changing the definition of a property MAY
				alter the semantics of the implementation. 
				
				For instance, while <termref ref="dt-INT">INT</termref> of 1
				is equal of <termref ref="dt-INT">INT</termref> of 1, <termref ref="dt-INT">INT</termref> of 1 is not equal to a 
				<termref ref="dt-PPD">PPD</termref>&lt;<termref ref="dt-INT">INT</termref>&gt; of 1 +/- 0.5.
				
				Similarly, while <termref ref="dt-INT">INT</termref>.plus(<termref ref="dt-INT">INT</termref>) has a return type of <termref ref="dt-INT">INT</termref>,
				both <termref ref="dt-PPD">PPD</termref>&lt;<termref ref="dt-INT">INT</termref>&gt;.plus(<termref ref="dt-INT">INT</termref>) and  
				<termref ref="dt-INT">INT</termref>.plus(<termref ref="dt-PPD">PPD</termref>&lt;<termref ref="dt-INT">INT</termref>&gt;) have
				a return type of <termref ref="dt-PPD">PPD</termref>&lt;<termref ref="dt-INT">INT</termref>&gt;.

				Note that in all cases the invariants on the parameter type must always be true.<footnote>
								<p>
									This rule actually applies to all specializations, but are restated here
									since it is easy to overlook these implications when designing and implementing
									generic type extensions. Generic Type Extensions are only different from normal
									specializing types because the type that is specialized depends on the type 
									parameter.
								</p>
							</footnote>
						</p>
						<exhibit role="dtdl">
							<caption/>
							<pre>
invariant (INT x, INT y, PPD&lt;INT&gt; z) 
    where x.isOne.and(y.isOne).and(((INT) z).isOne).and(z.standardDeviation.nonNull) {
  x.equal(y);
  x.equal(z).isNull; 
};</pre>
						</exhibit>
					</div4>
				</div3>
				<div3 id="flavors">
					<head>Flavors</head>
					<p>
				  Data type flavors are named constraints on the existing data types.
				  The flavors do not introduce any new semantics to the data type, but 
				  constrain an existing data type for a particular purpose. Flavors
				MAY NOT add new properties, or set default values for properties;
				the value of properties can be fixed, but not defaulted.
				</p>
					<p>
				  Flavors MAY be used as types in other models, for instance in the RIM,
                  and in RIM-derived models, when attributes are assigned a type that is a flavor.
                  However flavors are not true types; when used in this fashion, they designate that
                  the type of the attribute is the type from which the flavor is derived, with the 
                  constraints indicated in the flavor definition applied. For an instance of the 
                  data value assigned to the attribute, the type property is always that of the 
                  underlying type.  
                </p>
					<p>
				Flavors MAY constrain other flavors. When a flavor constrains another flavor, the 
				flavor adds new constraints to those already specified in the other flavor. 
			</p>
					<p>
                  Flavors are limited in this fashion so that a single implementation based on 
                  this specification will always be able to process all instances, but local 
                  implementations may describe a number of different constraint patterns on the 
                  data types defined in this specification.<footnote>
							<p>
						An Implementation Technology Specification may make its own rules about
						how the concept of a flavor is represented in any particular technology;
						however the requirement detailed here is of primary importance. 
					</p>
						</footnote>
					</p>
					<p>
				In the formal data type definition language, flavors follow this pattern:
			</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
flavor LongDescriptiveName alias ShortName constrains BaseTypeOrFlavor;
</pre>
					</exhibit>
					<p>
				The definition of a flavor cannot introduce any new semantics, only define 
				a long and short name, and the type or flavor that this flavor constrains. 
				By convention, the short name has the form Type.shortName, such as TS.Time,
				but some flavors have other names due to backwards compatibility constraints.
				Once the flavor is defined it is usually followed by one or more invariants 
				that specify the constraints associated with the flavor.
					</p>
					<p>
						In rare cases, the constraints cannot be even partially expressed using
						the data type definition language, but it is still useful to define the
						flavor. In such cases, the flavor will not have any associated invariant
						statements. An example of this case would be further constraints on the narrative
						text described in the CDA specification ([<loc href="http://www.hl7.org/v3ballot/html/infrastructure/cda/cda.htm" xlink-form="simple" show="embed" actuate="auto"/>]).
						
			</p>
					<p>
						<specref ref="RepresentationalProperties"/> documents the property flavorId. When
				this representational property is used in association with one of the flavors 
				documented here, it contains the value of the flavor name. 
			</p>
					<p>
				Additional flavors may be defined beyond those defined in this specification. The
				rules concerning definition, naming, and registration may be found in the Refinement, Constraint
				and Localization Specification ([<loc href="http://www.hl7.org/v3ballot/html/infrastructure/conformance/conformance.htm" xlink-form="simple" show="embed" actuate="auto"/>]). 
			</p>
				</div3>
				<div3 id="concepts">
					<head>Concept References</head>
					<p>
						Some invariants make reference to concepts defined in a concept domain. The
						syntax for this reference is [CodeSystemName].[code] where [CodeSystemName] 
						is the name of one of the code systems presented in this specification and 
						[code] is the code of one of the concepts defined in that domain. 
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(ANY x) {
   x.isNull.equal(x.nullFlavor.implies(NullFlavor.NI));
};</pre>
					</exhibit>
					<p>
						This invariant specifies that when a data type is null, its nullFlavor property
						implies the NullFlavor concept NI, which is identified by the Concept Reference 
						NullFlavor.NI.
					</p>
				</div3>
			</div2>
		</div1>
		<div1 id="datyp2foundtyp">
			<head>Foundation Types</head>
			<graphic source="graphics/dtUML-Foundation.png" alt="Foundation types"/>
			<div2 id="dt-ANY">
				<anchor id="ANY"/>
				<head>DataValue (ANY)</head>
				<p>
					<emph role="strong">Definition:     </emph>
					An abstract type that defines the basic properties common to all data values defined in this specification. 
					Data Value is an abstract type, meaning that no proper value
					can be just a data value without belonging to any concrete type. Every concrete
					type is a specialization of this general abstract DataValue type.
				</p>
				<table id="dt-ANY-prop-summary">
					<caption>Property Summary of
      DataValue</caption>
					<col width="79"/>
					<col width="60"/>
					<col width="413"/>
					<thead>
						<tr>
							<th>Name</th>
							<th>Type</th>
							<th>Description</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>
								<termref ref="prop-ANY.dataType">dataType</termref>
							</td>
							<td>
								<termref ref="dt-TYPE">TYPE</termref>
							</td>
							<td>
						The data type of the value. 
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-ANY.nullFlavor">nullFlavor</termref>
							</td>
							<td>
								<termref ref="dt-CS">CS</termref>
							</td>
							<td>
						  An indicator of a data value's exceptional status, sometimes also denoting the manner and rationale for that status. 
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-ANY.nonNull">nonNull</termref>
							</td>
							<td>
								<termref ref="dt-BN">BN</termref>
							</td>
							<td>
					    A predicate indicating that that a property has a value, i.e.  is a non-null ("non-exceptional") value of the data type.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-ANY.isNull">isNull</termref>
							</td>
							<td>
								<termref ref="dt-BN">BN</termref>
							</td>
							<td>
						A predicate indicating that that a value is an exceptional value, or a null-value. 
						A null value means that the information does not exist, is not available, or cannot
						be expressed in the data type's normal value set.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-ANY.notApplicable">notApplicable</termref>
							</td>
							<td>
								<termref ref="dt-BL">BL</termref>
							</td>
							<td>
						A predicate indicating that this exceptional value is of
						<termref ref="prop-ANY.nullFlavor">nullFlavor</termref> not-applicable (NA), i.e., that a proper
						value is not meaningful in the given context.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-ANY.unknown">unknown</termref>
							</td>
							<td>
								<termref ref="dt-BL">BL</termref>
							</td>
							<td>
						A predicate indicating that this exceptional value is of
						<termref ref="prop-ANY.nullFlavor">nullFlavor</termref> unknown (UNK).
        			</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-ANY.other">other</termref>
							</td>
							<td>
								<termref ref="dt-BL">BL</termref>
							</td>
							<td>
						A predicate indicating that this exceptional value is of
						<termref ref="prop-ANY.nullFlavor">nullFlavor</termref> other (OTH), i.e., that the required
						value domain does not contain the appropriate value.
			        </td>
						</tr>
					</tbody>
				</table>
				<exhibit role="dtdl">
					<caption/>
					<pre>
abstract type DataValue alias ANY {
   TYPE  dataType;
   CS    nullFlavor;
   BN    nonNull;
   BN    isNull;
   BL    notApplicable;
   BL    unknown;
   BL    other;
   BL    equal(ANY x);
   protected  BN    identical(ANY x);
};</pre>
				</exhibit>
				<div3 id="prop-ANY.dataType">
					<head>Data Type (dataType) : <termref ref="dt-TYPE">TYPE</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The data type of the value. 
					</p>
					<p>
						Every proper data value implicitly carries
						information about its own data type.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(ANY x) where x.nonNull {
   x.dataType.nonNull;
};</pre>
					</exhibit>
					<p>
					Note that the type of a flavor is always the underlying type. For instance, the type of a 
					<termref ref="dt-ED.IMAGE">ED.IMAGE</termref> is always <termref ref="dt-ED">ED</termref>. The kind of flavor will be 
					identified in the flavorId property. See <specref ref="RepresentationalProperties"/> for
					further information.					
				</p>
					<p>	
					An exceptional value may not have a type specified by its context of use, either in the applicable models or the instance itself. 
					In these cases, the datatype will default to <emph>ANY</emph>. Data values with a nullFlavor that
					implies INV SHALL have a known type that is not <emph>ANY</emph>.
				</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(ANY x) 
  where x.nullFlavor.implies("INV") {
   x.dataType.nonNull;
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-ANY.nullFlavor">
					<head>Exceptional Value Detail (nullFlavor) : <termref ref="dt-CS">CS</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						  An indicator of a data value's exceptional status, sometimes also denoting the manner and rationale for that status. 
					</p>
					<p>
						A data type MAY have an exceptional value (NULL-value, or just "null") rather than
						a proper value as described by this specification, either because
						the information does not exist, is not known or available, or
						cannot be expressed in the allowed value domain. In this case, 
						the nullFlavor expresses in what way and why proper information
						is missing. 
					</p>
					<p>
						Null values are improper values that do not conform to the proper 
						or expected value domain as described by this specification. This
						specification makes many rules concerning the relationship between
						the nullFlavor property and other properties, and these rules SHALL
						always be true. Both nonNull and null values SHALL always be valid 
						according to the rules expressed in this specification.
					</p>
					<p>
						Null values are also known as exceptional values. This is to denote that the
						information contained in the value is an exception to the expected value 
						domain that applies to the type. The information may either be missing or partially 
						present, or even completely present but not valid with respect to the constraints
						imposed by the Constraining Model (see <specref ref="dt2confmodel"/>).
					</p>
					<note role="Implementer">
						<p>
							This property is named nullFlavor because of the similarities between the concept of
							null value and the concept and behaviour of null in implementation technologies,
							particularly SQL and OCL. As in SQL and OCL, the result of a comparison operation
							between a null value and some other value is always null. In this sense, null
							values propagate through operations.
						</p>
						<p> 
							However there are some notable differences between these concepts. Most notably,
							in most implementation technologies, a null instance has no further information
							associated with it (some variation of the concept of a null pointer). This is not 
							true of the HL7 concept of null, where any of the properties of a null value might
							not be null. In OCL, null is an instance of OclVoid which is a super type of all
							types. This is not true for null values in this specification where a null value
							is still a valid instance of a particular type.
							If a true null is encountered in an implementation environment, it is semantically
							equivalent to a null-value of NI, and all other properties not related to nullFlavor
							will also have nullFlavor NI.
						</p>
					</note>
					<p>
						The null concept provides a general framework for handling incomplete data which is often 
						encountered in healthcare information collection, use and analysis.
						The <emph>nullFlavor</emph> property plays a special role in the conformance framework. See 
						"Conformance" in Core Principles of V3 Models [<loc href="../coreprinciples/v3modelcoreprinciples.htm#coreP_V3_Conformance" xlink-form="simple" show="embed" actuate="auto"/>] for further information.
					</p>
					<table id="domain-NullFlavor">
						<caption>Concept Domain NullFlavor. ValueSet OID:  2.16.840.1.113883.11.10609. CodeSystem "NullFlavor", OID: 2.16.840.1.113883.5.1008, Owner: HL7</caption>
						<thead>
							<tr valign="bottom">
								<th>lvl</th>
								<th>code</th>
								<th>name</th>
								<th>definition</th>
							</tr>
						</thead>
						<tr valign="top">
							<td>1</td>
							<td>NI</td>
							<td>no information</td>
							<td>
								<p>The value is exceptional (missing, omitted, incomplete, improper). No information as to the reason for being an exceptional value is provided. This is the most general exceptional value. It is also the default exceptional value.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>2</td>
							<td> INV</td>
							<td>invalid</td>
							<td>
								<p>The value as represented in the instance is not a member of the set of permitted data values in the constrained value domain of a variable.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>3</td>
							<td>  OTH</td>
							<td>other</td>
							<td>
								<p>The actual value is not a member of the set of permitted data values in the constrained value domain of a variable. (e.g., concept not provided by required code system).</p>
							</td>
						</tr>
						<tr valign="top">
							<td>4</td>
							<td>   NINF</td>
							<td>negative infinity</td>
							<td>
								<p>Negative infinity of numbers.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>4</td>
							<td>   PINF</td>
							<td>positive infinity</td>
							<td>
								<p>Positive infinity of numbers.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>3</td>
							<td>  UNC</td>
							<td>unencoded</td>
							<td>
								<p>No attempt has been made to encode the information correctly but the raw source information is represented (usually in originalText).</p>
							</td>
						</tr>
						<tr valign="top">
							<td>3</td>
							<td>  DER</td>
							<td>derived</td>
							<td>
								<p>An actual value may exist, but it must be derived from the provided information (usually an expression is provided directly).</p>
							</td>
						</tr>
						<tr valign="top">
							<td>2</td>
							<td> UNK</td>
							<td>unknown</td>
							<td>
								<p>A proper value is applicable, but not known.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>3</td>
							<td>  ASKU</td>
							<td>asked but unknown</td>
							<td>
								<p>Information was sought but not found (e.g., patient was asked but didn't know)</p>
							</td>
						</tr>
						<tr valign="top">
							<td>4</td>
							<td>   NAV</td>
							<td>temporarily unavailable</td>
							<td>
								<p>Information is not available at this time but it is expected that it will be available later.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>3</td>
							<td>  QS</td>
							<td>sufficient quantity</td>
							<td>
								<p>The specific quantity is not known, but is known to be non-zero and is not specified because it makes up the bulk of the material.</p>
								<p>e.g. 'Add 10mg of ingredient X, 50mg of ingredient Y, and sufficient quantity of water to 100mL.' The null flavor would be used to express the quantity of water.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>3</td>
							<td>  NASK</td>
							<td>not asked</td>
							<td>
								<p>This information has not been sought (e.g., patient was not asked)</p>
							</td>
						</tr>
						<tr valign="top">
							<td>3</td>
							<td>  TRC</td>
							<td>trace</td>
							<td>
								<p>The content is greater than zero, but too small to be quantified.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>2</td>
							<td> MSK</td>
							<td>masked</td>
							<td>
								<p>There is information on this item available but it has not been provided by the sender due to security, privacy or other reasons. There may be an alternate mechanism for gaining access to this information.</p>
								<p>Note: using this null flavor does provide information that may be a breach of confidentiality, even though no detail data is provided.  Its primary purpose is for those circumstances where it is necessary to inform the receiver that the information does exist without providing any detail.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>2</td>
							<td> NA</td>
							<td>not applicable</td>
							<td>
								<p>No proper value is applicable in this context (e.g., last menstrual period for a male).</p>
							</td>
						</tr>
					</table>
					<p>
						The null flavors are a general domain extension of all normal data
						type domains ("domain" in this sense means the set of all possible values 
						for the data type, not "domain" in the more restricted sense used for 
						coded data types). So this is true not only for coded data types with specified
						vocabulary domains, but for non-coded value domains as well, e.g. integers,
						temporal intervals, infectious disease cases, etc.
					</p>
					<p>
						Note that while all these nullFlavors are considered to be exceptional values - a proper 
						value is not known, under some circumstances the nullFlavor itself may 
						be semantically useful. For instance, while the value PINF may represent an actual unknown value, it can be used as the upper limit of an 
						interval. Similarly, the value QS represents an unknown amount but may be converted to
						a real amount during the actual dispensing of a formulation.  
					</p>
					<p>
						As a general domain extension of all normal data types, the null flavors
						also extend the literal form of those data types that have a literal 
						form. In any literal form, the literal NullFlavor.X signals that the 
						data type has the assigned nullFlavor, where X is the code, such as NA.
					</p>
					<p>
						Note that the nullFlavor property isNull is reverse to that of the data type 
						itself. If the data type is not null, then the nullFlavor property itself will be null.
						If the data type is null, then the nullFlavor is not null - it will
						specify an actual nullFlavor that provides more detail as to in what
						way or why no proper value is supplied.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(ANY x) {
   x.nullFlavor.isNull.equal(x.nonNull);
};</pre>
					</exhibit>
					<p>
						The general implication of this is that in a <termref ref="dt-CD">CD</termref> or descendant 
						(usually <termref ref="dt-CS">CS</termref>), when the code for a nullFlavor is carried in the 
						code/codeSystem (code = "NI" and codeSystem = "2.16.840.1.113883.5.1008"),
						the <termref ref="dt-CD">CD</termref> itself is not null. The <termref ref="dt-CD">CD</termref> is only
						null when its nullFlavor carries this code.     
					</p>
					<p>	
						When performing operations upon null values, the semantic meaning
						of the nullFlavor SHALL be considered. This is particularly important
						for equality. The only case where non-proper (NULL) values may be equal
			           is where both values have a nullFlavor of NA. In most other 
			           cases, the outcome of comparing NULL values is also null. However, there
			           are exceptions based on the semantic meaning of nullFlavor. 
								For instance, although direct comparison of two values with 
								nullFlavor PINF is always null (NI), two intervals
								with the equal low bounds and high bounds of PINF will return true,
								since they specify the same set. Similarly, comparison of NINF
								and PINF is always False. 
					</p>
					<p>
						The "actual value" refers to the value of the 
						information itself, rather than the information as represented in 
						the type itself. These two may diverge when the information provided
						is incomplete, such as when an expression is provided.					
						The null flavor "other" is used whenever the actual value is not in
						the required value domain: this may occur, for example, when the value
						exceeds some constraints that are defined in too restrictive a manner
					</p>
					<p> 
						For example, if the value for age is 100 yrs, but the constraining 
						model specifies that the age must be less than 100 years, the age 
						may still be specified, provided that the model does not make the 
						attribute mandatory. 
					</p>
					<exhibit role="example" verbatim="yes">
						<pre>
&lt;value nullFlavor="OTH" value="120" unit="yr"/&gt;</pre>
					</exhibit>
					<p>
						Some of the null flavors are not generally applicable to all data types.
						
						The nullFlavors NINF and PINF SHALL only be associated with <termref ref="dt-QTY">QTY</termref> types
						other than <termref ref="dt-MO">MO</termref> and <termref ref="dt-RTO">RTO</termref>. The nullFlavors QS, and TRC 
						SHALL only be used with <termref ref="dt-PQ">PQ</termref>. The nullFlavor UNC SHALL only be used with 
						any type that has an originalText, and when UNC is used the originalText
						property SHALL be populated. The nullFlavor DER SHALL only be used with the 
						<termref ref="dt-EXPR">EXPR</termref> type, and an expression SHALL be provided.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(ANY x) {
  x.nullFlavor.implies(NullFlavor.PINF).implies(x.dataType.implies(QTY));
  x.nullFlavor.implies(NullFlavor.NINF).implies(x.dataType.implies(QTY));
  x.nullFlavor.implies(NullFlavor.QS).implies(x.dataType.implies(QTY));
  x.nullFlavor.implies(NullFlavor.TRC).implies(x.dataType.implies(QTY));

  /* if whatever type x is doesn't have an originalText property, 
     the invariant will be null (not true) */
  x.nullFlavor.equals(UNC).implies(((x.dataType)x).originalText.nonNull);

  x.nullFlavor.equals(DER).implies(x.dataType.implies(EXPR&lt;QTY&gt;)
    .and((EXPR&lt;QTY&gt;) x).expression.nonNull);
};</pre>
					</exhibit>
					<p>
						Note: the two nullFlavors INV and OTH draw a distinction between the actual
						value and the vlalue as represented in the instance. Some of the datatypes
						may be used to provide a representation of the value which requires subsequent
						transformation to generate the real value. For instance, an expression may be
						provided which will generate an actual value that is in the required value
						domain of the instance.
					</p>
					<note role="ITS">
						<p>
							NULL-flavors are applicable to any property of a data value or a
							higher-level object attribute. Where the null flavor is
							determited to be not significant by the core HL7 infrastrcture committees, ITS are not required to represent them. If nothing
							else is noted in this specification, ITS need not represent general
							NULL-flavors for data-value properties. In addition, there is a difference
							between semantic properties and representational "components" of data values.
							An ITS SHOULD only represent those components that are needed to <emph>infer</emph> the
							semantic properties. The null-flavor predicates <termref ref="prop-ANY.nonNull">nonNull</termref>,
							<termref ref="prop-ANY.isNull">isNull</termref>, <termref ref="prop-ANY.notApplicable">notApplicable</termref>,
							<termref ref="prop-ANY.unknown">unknown</termref>, and <termref ref="prop-ANY.other">other</termref> can
							all be inferred from the <emph>nullFlavor</emph> property.
						</p>
					</note>
					<p>
						Some of these null flavors are associated with named properties that can be
						used as simple predicates for all data values. This does not change the semantics of the property; it is done to
						simplify the formulation of invariants in the remainder of this
						specification.
					</p>
				</div3>
				<div3 id="prop-ANY.nonNull">
					<head>Proper Value (nonNull) : <termref ref="dt-BN">BN</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
					    A predicate indicating that that a property has a value, i.e.  is a non-null ("non-exceptional") value of the data type.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(ANY x) {
   x.nonNull.equal(x.isNull.not);
};</pre>
					</exhibit>
					<p>
						When a property (i.e. RIM attribute, or message field) is labeled
						<emph>mandatory</emph>, and the container is not null itself,
						then any value assigned to the property SHALL be nonNull.
			        </p>
				</div3>
				<div3 id="prop-ANY.isNull">
					<head>Exceptional Value (isNull) : <termref ref="dt-BN">BN</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						A predicate indicating that that a value is an exceptional value, or a null-value. 
						A null value means that the information does not exist, is not available, or cannot
						be expressed in the data type's normal value set.
					</p>
					<p>
						Every data element has either a proper value or it is
						considered NULL. If (and only if) it is NULL, the <termref ref="prop-ANY.nullFlavor">nullFlavor</termref> provides
						more detail as to in what way or why no proper value is supplied.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(ANY x) {
   x.isNull.equal(x.nullFlavor.implies(NullFlavor.NI));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-ANY.notApplicable">
					<head>Inapplicable Proper Value (notApplicable) : <termref ref="dt-BL">BL</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						A predicate indicating that this exceptional value is of
						<termref ref="prop-ANY.nullFlavor">nullFlavor</termref> not-applicable (NA), i.e., that a proper
						value is not meaningful in the given context.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(ANY x) {
   x.notApplicable.equal(x.nullFlavor.implies(NullFlavor.NA));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-ANY.unknown">
					<head>unknown (unknown) : <termref ref="dt-BL">BL</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						A predicate indicating that this exceptional value is of
						<termref ref="prop-ANY.nullFlavor">nullFlavor</termref> unknown (UNK).
        			</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(ANY x) {
   x.unknown.equal(x.nullFlavor.implies(NullFlavor.UNK));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-ANY.other">
					<head>Value Domain Exception (other) : <termref ref="dt-BL">BL</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						A predicate indicating that this exceptional value is of
						<termref ref="prop-ANY.nullFlavor">nullFlavor</termref> other (OTH), i.e., that the required
						value domain does not contain the appropriate value.
			        </p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(ANY x) {
   x.other.equal(x.nullFlavor.implies(NullFlavor.OTH));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-ANY.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>
					</head>
					<argument name="x" type="ANY"/>
					<p>
						<emph role="strong">Definition:     </emph>
						A reflexive, symmetric, and transitive relation between
						any two data values indicating that the two values are the same.
			        </p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(ANY x, y, z)
      where x.nonNull.and(y.nonNull).and(z.nonNull) {
   x.equal(x);                                         /* reflexivity */
   x.equal(y).equal(y.equal(x));                       /* symmetry */
   x.equal(y).and(y.equal(z)).implies(x.equal(z));      /* transitivity */
};</pre>
					</exhibit>
					<p>
						How equality is determined must be defined for each data type, and 
						care must be taken when implementing equals in a polymorphic environment.
						There is a tension between what is logical and desired, and the
						requirement for symmetry and transitivity.
						<footnote>
							<p>
						  	A typical case is where a type A has a property a, and type B extends A by
						  	adding property b. Many implementers will say A.equals(A other) is true if 
						  	this.a = other.a, and that B.equals(B other) if this.b = other.b. However
						  	in this case, given a1 of type A and b1 of type B, a.equals(b) is true, and 
						  	b.equals(a) is false. 
						  </p>
						</footnote>
						These data types and the 
						definitions of equals have been carefully constructed so that their definitions
						of equals are both symmetric and transitive. 
					</p>
					<p>
						Some of the definitions of equality exclude some of the properties of
						a data type from the equality test, where those properties are not essential to the 
						meaning of the value. In addition, some interpretation of the 
						semantics of the values may be required to determine the equality of 
						two values. For example physical quantity (<termref ref="PQ"/>) has the two semantic
						properties (1) a real number and (2) a coded unit of measure. The equality
						test, however, must account for the fact that, e.g., 1 meter equals 100
						centimeters; independent equality of the two semantic properties is
						too strong a criterion for the equality test. Therefore, physical
						quantity must override the equality definition.
					</p>
					<p>
						The requirement for understanding the meaning of the data applies to nullFlavors
						as well. Under certain circumstances the test for equality between two different
						values with different flavors of null may not be null. Consult <termref ref="prop-ANY.nullFlavor">nullFlavor</termref> 
						for more information. 	
					</p>
				</div3>
				<div3 id="prop-ANY.identical">
					<head>Identity Comparison (identical) : <termref ref="dt-BN">BN</termref>
					</head>
					<argument name="x" type="ANY"/>
					<p>
						<emph role="strong">Definition:     </emph>
						Identity comparison is a reflexive, symmetric, and transitive relation between
						any two data values. Any values can be identical, whether or not
						they are null or contain property with null values. The identity comparison
						always returns true or false. The result is never null.
			        </p>
					<p>
						The identity relationship is defined to assist in the definition of uniqueness
						constraints on <termref ref="dt-DSET">DSET</termref>s. The identity relationship SHOULD NOT
						otherwise be used as it has no other use, and is therefore given a protected
						status to indicate that it should not be used outside this specification.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(ANY x, y, z) {
   x.identical(x);                                              /* reflexivity */
   x.identical(y).equal(y.identical(x));                        /* symmetry */
   x.identical(y).and(y.identical(z)).implies(x.identical(z));  /* transitivity */
};</pre>
					</exhibit>
					<p>
						How identity is determined is the same for every data type except <termref ref="dt-BL">BL</termref>.
						If all the properties of two values are identical, the values are identical. For
						<termref ref="dt-BL">BL</termref>, the two values are identical if they have the same nullFlavor
						or if they are both true or both false.<footnote>
							<p>
								This formal definition is satisfactory to determine identity, but not 
								particularly practical in this form. Implementations of the data types
								may specify alternate methods for how identical is determined. Since the 
								primary intent of this property is to assist with uniqueness constraints 
								on sets, comparison of pointers to objects may suffice in platforms where
								this makes sense (i.e. Java = instead of equal()).
							</p>
						</footnote>
					</p>
				</div3>
			</div2>
			<div2 id="dt-TYPE">
				<anchor id="TYPE"/>
				<head>DataType (TYPE) specializes <termref ref="dt-ANY">ANY</termref>
				</head>
				<p>
					<emph role="strong">Definition:     </emph>
					The data type of a data element or property.
				</p>
				<p>					
					This property is a meta-type declared in order to allow the formal definitions to make
					invariants about the data type of a value. Any data type defined in this
					specification is a value of the type DataType.
				</p>
				<table id="dt-TYPE-prop-summary">
					<caption>Property Summary of
      DataType</caption>
					<col width="79"/>
					<col width="60"/>
					<col width="413"/>
					<thead>
						<tr>
							<th>Name</th>
							<th>Type</th>
							<th>Description</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>
								<termref ref="prop-DataType.shortName">shortName</termref>
							</td>
							<td>
								<termref ref="dt-ST">ST</termref>
							</td>
							<td>
						 The alias of the data type.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-DataType.longName">longName</termref>
							</td>
							<td>
								<termref ref="dt-ST">ST</termref>
							</td>
							<td>
						 The full name of the data type.
					</td>
						</tr>
					</tbody>
				</table>
				<exhibit role="dtdl">
					<caption/>
					<pre>
private type DataType alias TYPE specializes ANY {
   ST  shortName;
   ST  longName;
   BL  implies(TYPE that);
   BL  isComparableTo(TYPE that);
};</pre>
				</exhibit>
				<p>
					Note that the type of a flavor is always the underlying type. For instance, the type of a 
					<termref ref="dt-ED.IMAGE">ED.IMAGE</termref> is always <termref ref="dt-ED">ED</termref>. The kind of flavor will be 
					identified in the flavorId property. See <specref ref="RepresentationalProperties"/> for
					further information.					
				</p>
				<div3 id="prop-DataType.shortName">
					<head>Short Name (shortName) : <termref ref="dt-ST">ST</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						 The alias of the data type.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(DataType x)
      where x.nonNull {
   x.shortName.nonNull;
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-DataType.longName">
					<head>Long Name (longName) : <termref ref="dt-ST">ST</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						 The full name of the data type.
					</p>
				</div3>
				<div3 id="prop-DataType.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<argument name="x" type="TYPE"/>
					<p>
						Two nonNull data types are equal if they are the same type.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(DataType x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.shortName.equal(y.shortName));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-DataType.implies">
					<head>Implies (implies) : <termref ref="dt-BL">BL</termref>
					</head>
					<argument name="that" type="TYPE"/>
					<p>
						<emph role="strong">Definition:     </emph>
						A relation that indicates that a data type has the same type or is a specialization of the argument type.
					</p>
				</div3>
				<div3 id="prop-DataType.isComparableTo">
					<head>Comparable To (isComparableTo) : <termref ref="dt-BL">BL</termref>
					</head>
					<argument name="that" type="TYPE"/>
					<p>
						<emph role="strong">Definition:     </emph>
						A relation that indicates whether two types have the same equality criteria
					</p>
					<p>
						A data type is comparable to another data type if they both have the same equality 
						criteria. For instance, <termref ref="CS"/> has the same equality criteria as
						<termref ref="CD"/>, so <termref ref="CS"/> is comparable to <termref ref="CD"/>. Note that
						the fact that two data types can be compared does not mean that all instances 
						of the data types may be compared - for instance, it is not possible to compare
						the PQ values 3yr and 5m.
					</p>
				</div3>
			</div2>
			<div2 id="dt-BL">
				<anchor id="BL"/>
				<head>Boolean (BL) specializes <termref ref="dt-ANY">ANY</termref>
				</head>
				<p>
					<emph role="strong">Definition:     </emph>
					A binary value for use in boolean logic. A <emph>BL</emph>
					value can be either <emph>true</emph> or <emph>false</emph>, or, as
					any other value, MAY be NULL.
				</p>
				<values>
					<value>true</value>
					<value>false</value>
				</values>
				<exhibit role="dtdl" id="dtdl-BL">
					<anchor id="dtdl-BL"/>
					<caption/>
					<pre>
type Boolean alias BL specializes ANY
   values(true, false) {
            BL  not;
            BL  and(BL x);
            BL  or(BL x);
            BL  xor(BL x);
            BL  implies(BL x);
   literal  ST.SIMPLE;
};</pre>
				</exhibit>
				<p>
					With any data value potentially being NULL, the two-valued logic is
					effectively extended to a three-valued logic as shown in the following
					truth tables:
				</p>
				<div3>
					<!-- NOT -->
					<head>Truth tables for Boolean logic with NULL values</head>
					<table id="BL-truth-tables-not" width="1px">
						<caption>Truth Table: NOT</caption>
						<col width="0.1" span="1"/>
						<col width="0.1" span="1"/>
						<thead>
							<tr>
								<th rowspan="1" colspan="1">NOT</th>
								<th rowspan="1" colspan="1"> </th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<!-- NOT -->
								<th rowspan="1" colspan="1">true</th>
								<td rowspan="1" colspan="1">false</td>
							</tr>
							<tr>
								<!-- NOT -->
								<th rowspan="1" colspan="1">false</th>
								<td rowspan="1" colspan="1">true</td>
							</tr>
							<tr>
								<!-- NOT -->
								<th rowspan="1" colspan="1">NULL</th>
								<td rowspan="1" colspan="1">NULL</td>
							</tr>
						</tbody>
					</table>
					<!-- AND -->
					<table id="BL-truth-tables-and" width="1px">
						<caption>Truth Table: AND</caption>
						<!-- <col width="0.45"/><col width="0.45"/><col width="0.45"/><col width="0.45"/> -->
						<thead>
							<tr>
								<th rowspan="1" colspan="1">AND</th>
								<th rowspan="1" colspan="1">true</th>
								<th rowspan="1" colspan="1">false</th>
								<th rowspan="1" colspan="1">NULL</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<th rowspan="1" colspan="1">true</th>
								<td rowspan="1" colspan="1">true</td>
								<td rowspan="1" colspan="1">false</td>
								<td rowspan="1" colspan="1">NULL</td>
							</tr>
							<tr>
								<th rowspan="1" colspan="1">false</th>
								<td rowspan="1" colspan="1">false</td>
								<td rowspan="1" colspan="1">false</td>
								<td rowspan="1" colspan="1">false</td>
							</tr>
							<tr>
								<th rowspan="1" colspan="1">NULL</th>
								<td rowspan="1" colspan="1">NULL</td>
								<td rowspan="1" colspan="1">false</td>
								<td rowspan="1" colspan="1">NULL</td>
							</tr>
						</tbody>
					</table>
					<!-- OR  -->
					<table id="BL-truth-tables-or" width="1px">
						<caption>Truth Table: OR</caption>
						<!-- <col width="0.45"/><col width="0.45"/><col width="0.45"/><col width="0.45"/> -->
						<thead>
							<tr>
								<th rowspan="1" colspan="1">OR</th>
								<th rowspan="1" colspan="1">true</th>
								<th rowspan="1" colspan="1">false</th>
								<th rowspan="1" colspan="1">NULL</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<th rowspan="1" colspan="1">true</th>
								<td rowspan="1" colspan="1">true</td>
								<td rowspan="1" colspan="1">true</td>
								<td rowspan="1" colspan="1">true</td>
							</tr>
							<tr>
								<th rowspan="1" colspan="1">false</th>
								<td rowspan="1" colspan="1">true</td>
								<td rowspan="1" colspan="1">false</td>
								<td rowspan="1" colspan="1">NULL</td>
							</tr>
							<tr>
								<th rowspan="1" colspan="1">NULL</th>
								<td rowspan="1" colspan="1">true</td>
								<td rowspan="1" colspan="1">NULL</td>
								<td rowspan="1" colspan="1">NULL</td>
							</tr>
						</tbody>
					</table>
				</div3>
				<p>
					Where a boolean operation is performed upon 2 data types with different
					nullFlavors, the nullFlavor of the result SHALL be any common ancestor
					of the 2 different nullFlavors. The result SHOULD be the first common ancestor.
				</p>
				<div3 id="prop-BL.not">
					<head>Negation (not) : <termref ref="dt-BL">BL</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The opposite value. Negation of a <emph>BL</emph> turns <emph>true</emph> into <emph>false</emph>
						and <emph>false</emph> into <emph>true</emph> and is NULL for NULL
						values.
					</p>
					<exhibit role="dtdl" id="dtdl-BL.not">
						<anchor id="dtdl-BL.not"/>
						<caption/>
						<pre>
invariant(BL x) {
   true.not.equal(false);
   false.not.equal(true);
   x.isNull.equal(x.not.isNull);
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-BL.and">
					<head>Conjunction (and) : <termref ref="dt-BL">BL</termref>
					</head>
					<argument name="x" type="BL"/>
					<p>
						<emph role="strong">Definition:     </emph>
						Conjunction between a value and another value indicates that both values are true. Conjunction is associative and commutative, with
						<emph>true</emph> as a neutral element. <emph>False</emph> AND any
						Boolean value is <emph>false</emph>. These rules hold even if one or
						both of the operands are NULL. If both operands for AND are NULL,
						the result is NULL.
					</p>
					<exhibit role="dtdl" id="dtdl-BL.and">
						<anchor id="dtdl-BL.and"/>
						<caption/>
						<pre>
invariant(BL x, y) {
   x.and(true).equal(x);
   x.and(false).equal(false);
   x.isNull.implies(x.and(y).isNull);
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-BL.or">
					<head>Disjunction (or) : <termref ref="dt-BL">BL</termref>
					</head>
					<argument name="x" type="BL"/>
					<p>
						<emph role="strong">Definition:     </emph>
	                    A parametric property indicating that the value or the argument is true, or both are true.				
						The disjunction <emph>x</emph> OR <emph>y</emph> is <emph>false</emph>
						if and only if <emph>x</emph> is <emph>false</emph> and <emph>y</emph>
						is <emph>false</emph>.
					</p>
					<exhibit role="dtdl" id="dtdl-BL.or">
						<anchor id="dtdl-BL.or"/>
						<caption/>
						<pre>
invariant(BL x, y) {
   x.or(y).equal(x.not.and(y.not).not);
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-BL.xor">
					<head>Exclusive Disjunction (xor) : <termref ref="dt-BL">BL</termref>
					</head>
					<argument name="x" type="BL"/>
					<p>
						<emph role="strong">Definition:     </emph>
						A parametric property indicating that either the value or the argument is true, but not both. 
					</p>
					<exhibit role="dtdl" id="dtdl-BL.xor">
						<anchor id="dtdl-BL.xor"/>
						<caption/>
						<pre>
invariant(BL x, y) {
   x.xor(y).equal(x.or(y).and(x.and(y).not));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-BL.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<argument name="x" type="BL"/>
					<p>
						Two non null <emph>BL</emph> are equal if the have the same value.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(BL x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.equal(true).and(y.equal(true).or(x.equal(false).and(y.equal(false)))));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-BL.implies">
					<head>Implication (implies) : <termref ref="dt-BL">BL</termref>
					</head>
					<argument name="x" type="BL"/>
					<p>
						<emph role="strong">Definition:     </emph>
					    A parametric property indicating that the argument is true when the value is true, supporting rules of the form IF condition THEN conclusion
					</p>
					<p>					
						Logically, the implication is defined as the
						disjunction of the negated condition and the conclusion, meaning that
						when the condition is <emph>true</emph> the conclusion must be
						<emph>true</emph> to make the overall statement <emph>true</emph>.
						The logical implication is important to make invariant statements. 
					</p>
					<exhibit role="dtdl" id="dtdl-BL.implies">
						<anchor id="dtdl-BL.implies"/>
						<caption/>
						<pre>
invariant(BL condition, conclusion) {
   condition.implies(conclusion).equal(
      condition.not.or(conclusion));
};</pre>
					</exhibit>
					<p>
						The implication is not reversible and does not specify whether the condition is
						<emph>true</emph> when the condition is <emph>false</emph> (<emph>ex
						falso quodlibet</emph> lat. &#8220;from false follows anything&#8221;).
					</p>
				</div3>
				<div3 id="prop-BL.literal">
					<head>Literal Form</head>
					<p>
						The literal form of the Boolean is determined by the named values
						specified in the values clause, i.e., <emph>true</emph> and
						<emph>false</emph>.
					</p>
				</div3>
			</div2>
			<div2 id="dt-COLL">
				<anchor id="COLL"/>
				<head>Collection (COLL) specializes <termref ref="dt-ANY">ANY</termref>
				</head>
				<parameter name="T" type="ANY"/>
				<conformanceProperty name="min" type="INT" default="0" definition="The minimum number of a items that a collection may contain"/>
				<conformanceProperty name="max" type="INT" default="NullFlavor.PINF" definition="The maximum number of a items that a collection may contain"/>
				<p>
					<emph role="strong">Definition:     </emph>
					A collection of values which can be enumerated using an iterator.
				</p>
				<exhibit role="dtdl" id="dtdl-COLL">
					<anchor id="dtdl-COLL"/>
					<caption/>
					<pre>
template&lt;ANY T&gt;
abstract type Collection&lt;T&gt; alias COLL&lt;T&gt; specializes ANY {
  BL      isEmpty;
  BL      notEmpty;
  INT     count;
  BL      contains(T item);
};</pre>
				</exhibit>
				<p>
					<emph>COLL</emph> is introduced to represent the concept of an enumerable collection.
					Collections that are enumerable are inherently countable, though some collections
					may have an infinite number of items in the collection.
				</p>
				<p>
					RIM attributes with a collection type MAY be assigned a cardinality by the constraining
					model. In these cases, the cardinality is understood to refer to the number of items 
					in the collection. To require that a collection have at least one item, the minimum 
					multiplicity of the attribute must be constrained to 1 or more.
				</p>
				<div3 id="prop-COLL.isEmpty">
					<head>The Empty Collection (isEmpty) : <termref ref="dt-BL">BL</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>          
						 An indicator that the <emph>COLL</emph> has no elements. The return value may be null (when the collection itself is null, whether the collection is empty is not known).
						</p>
				</div3>
				<div3 id="prop-COLL.notEmpty">
					<head>Not-Empty (notEmpty) : <termref ref="dt-BL">BL</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph> 
							An indicator that the <emph>COLL</emph> contains at least one item. The return value may be null (when the collection itself is null, whether the collection is empty is not known).
						</p>
				</div3>
				<div3 id="prop-COLL.count">
					<head>Count (count) : <termref ref="dt-INT">INT</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
							The number of elements in the <emph>COLL</emph>. The return value may be null (when the collection itself is null, the number of items in the collection is not known).
						</p>
				</div3>
				<div3 id="prop-COLL.contains">
					<head>Contains Item (contains) : <termref ref="dt-BL">BL</termref>
					</head>
					<argument name="item" type="T"/>
					<p>
						<emph role="strong">Definition:     </emph>  
							An indicator that the <emph>COLL</emph> contains an item with the given item value using the equals property. If item is null, the return value will be null.
						</p>
				</div3>
			</div2>
			<div2 id="dt-BAG">
				<anchor id="BAG"/>
				<head>Bag (BAG) specializes <termref ref="dt-COLL">COLL</termref>
				</head>
				<parameter name="T" type="ANY"/>
				<p>
					<emph role="strong">Definition:     </emph>
					An unordered collection of values, where any value can occur
					more than once.
				</p>
				<exhibit role="dtdl" id="dtdl-BAG">
					<anchor id="dtdl-BAG"/>
					<caption/>
					<pre>
template&lt;ANY T&gt;
type Bag&lt;T&gt; alias BAG&lt;T&gt; specializes COLL&lt;T&gt; {
              INT     count(T item);
              BAG&lt;T&gt;  plus(BAG&lt;T&gt; x);
              BAG&lt;T&gt;  minus(BAG&lt;T&gt; x);
   literal    ST.SIMPLE;
   promotion  BAG&lt;T&gt;  (T x);
   promotion  BAG&lt;T&gt;  (DSET&lt;T&gt; x);
};</pre>
				</exhibit>
				<p>
					A bag MAY contain NULL values as items.
				</p>
				<note role="ITS">
					<p>
						A <emph>BAG</emph> can be represented in two ways: either as a simple enumeration
						of elements, including repeated elements, or as a "compressed bag"
						whereby the content of the <emph>BAG</emph> is listed in pairs of element value and
						count. A histogram showing absolute frequencies is a <emph>BAG</emph> represented
						in compressed form. <emph>BAG</emph> is therefore useful to communicate raw
						statistical data samples.
						</p>
				</note>
				<div3 id="prop-BAG.count">
					<head>Count (count) : <termref ref="dt-INT">INT</termref>, inherited from <termref ref="dt-COLL">COLL</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
							The number of elements in the bag. NULL elements are counted as
							bag elements.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(BAG&lt;T&gt; bag, INT zero)
      where bag.nonNull.and(zero.isZero) {
   bag.isEmpty.equal(bag.count.isZero);
   bag.notEmpty.equal(bag.count.greaterThan(zero));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-BAG.count">
					<head>Count Item (count) : <termref ref="dt-INT">INT</termref>
					</head>
					<argument name="item" type="T"/>
					<p>
						<emph role="strong">Definition:     </emph>
							The number of items in this bag with the given item value.
						</p>
					<p>
							This is the primitive property of a <emph>BAG</emph>, on which all
							other properties are defined.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(BAG&lt;T&gt; bag, T item)
      where bag.nonNull {
   bag.count(item).nonNegative;
   bag.isEmpty.implies(bag.count(item).isZero);
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-BAG.contains">
					<head>Contains Item (contains) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-COLL">COLL</termref>
					</head>
					<argument name="item" type="T"/>
					<p>
						<emph role="strong">Definition:     </emph>
							True if the bag contains an item with the given item value.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(BAG&lt;T&gt; bag, T item)
      where bag.nonNull {
   bag.contains(item).equal(bag.count(item).isNegative.not);
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-BAG.isEmpty">
					<head>The Empty Collection (isEmpty) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-COLL">COLL</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
							A predicate indicating that this <emph>BAG</emph> has no elements (negation of the
							<termref ref="prop-BAG.notEmpty">notEmpty</termref> predicate. The empty <emph>BAG</emph> is a
							proper value, <emph>not</emph> an exceptional (NULL) value.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(BAG&lt;T&gt; bag)
      where bag.nonNull {
   bag.isEmpty.equal(notEmpty.not);
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-BAG.notEmpty">
					<head>Not-Empty (notEmpty) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-COLL">COLL</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
							A predicate indicating that this <emph>BAG</emph> contains at least one item. The item MAY be null.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(BAG&lt;T&gt; bag)
      where bag.nonNull {
   bag.notEmpty.equal(exists(T item) {
      bag.contains(item);
      });
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-BAG.plus">
					<head>Addition (plus) : <termref ref="dt-BAG">BAG</termref>&lt;T&gt;</head>
					<argument name="x" type="BAG&lt;T&gt;"/>
					<p>
						<emph role="strong">Definition:     </emph>
							A <emph>BAG</emph> that contains all items of the operand <emph>BAG</emph>s.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(BAG&lt;T&gt; x, y, z)
      where x.nonNull.and(y.nonNull) {
   x.plus(y).equal(z).equal(
      forall(T e)
            where e.nonNull {
         z.contains(e).equal(x.contains(e)
                      .or(y.contains(e)));
         });
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-BAG.minus">
					<head>Subtraction (minus) : <termref ref="dt-BAG">BAG</termref>&lt;T&gt;</head>
					<argument name="x" type="BAG&lt;T&gt;"/>
					<p>
						<emph role="strong">Definition:     </emph>
							A <emph>BAG</emph> that contains all items of this <emph>BAG</emph> (minuend) diminished by the
							items in the other <emph>BAG</emph> (subtrahend). <emph>BAG</emph>s cannot carry deficits: When
							the subtrahend contains more items of one value than the minuend, the
							difference contains zero items of that value.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(BAG&lt;T&gt; x, y, z)
      where x.nonNull.and(y.nonNull) {
   x.minus(y).equal(z).equal(
      forall(T e)
            where e.nonNull {
               exists(INT n)
                  where n.equal(x.count(e).minus(y.count(e))) {
         n.nonNegative.equal(z.count(e));
         n.isNegative.equal(z.count(e).isZero);
         };
      });
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-BAG.literal">
					<head>Literal Form</head>
					<p>
							When the element type T has a literal form, the bag of T elements has
							a literal form, wherein the elements of the set are enumerated within
							curly braces and separated by semicolon characters.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
BAG&lt;T&gt;.literal ST.SIMPLE {
   BAG&lt;T&gt;          : "{" elements "}"   { $.equal($2); };
   BAG&lt;T&gt; elements : elements ";" T     { $.except($2).equal($1); }
                  | T                   { $.contains($1);
                                          $.except($1).isEmpty; };
};</pre>
					</exhibit>
					<note>
						<p>
								This literal form for bags is only practical for relatively small
								bags; this does not mean, however, that all bag are
								relatively small enumerations of elements.
							</p>
					</note>
					<table id="table-BAG.literal.example">
						<caption>Example</caption>
						<thead>
							<tr>
								<th rowspan="1" colspan="1">literal</th>
								<th rowspan="1" colspan="1">meaning</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td rowspan="1" colspan="1">{1; 3; 3; 5; 7; 19}</td>
								<td rowspan="1" colspan="1">a bag of integer numbers or real numbers</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">{3; 1; 5; 19; 3, 7}</td>
								<td rowspan="1" colspan="1">the same bag of integer numbers or real numbers</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">{1.2 m; 2.67 m; 17.8 m}</td>
								<td rowspan="1" colspan="1">a bag of discrete physical quantities</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">{"apple"; "orange"; "banana"; "strawberry"; "apple"}</td>
								<td rowspan="1" colspan="1">a bag of character strings (for strings, use quoted form to prevent problems with ";")</td>
							</tr>
						</tbody>
					</table>
					<note role="ITS">
						<p>
								A character-based ITS SHOULD choose a different literal
								form for bags if the Implementation Technology has a more native
								literal form for such collections.
							</p>
					</note>
				</div3>
				<div3 id="prop-BAG.promotionT">
					<head>Promotion of Item Values to Bags (promotion) : <termref ref="dt-BAG">BAG</termref>&lt;T&gt;</head>
					<argument name="x" type="T"/>
					<p>
							A data value of type T can be promoted into a trivial <emph>BAG</emph> of type T
							with that data value as its only item.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(T x) {
   ((BAG&lt;T&gt;)x).count.equal(1);
}

invariant(T x) where x.isNull {
   ((BAG&lt;T&gt;)x).count(x).isNull;
}

invariant(T x) where x.nonNull {
   ((BAG&lt;T&gt;)x).count(x).equal(1);
   
   forall(T y) where y.nonNull {
      ((BAG&lt;T&gt;)x).count(y).isZero.not
                 .implies(x.equal(y)) };
}

invariant(T x) where x.isNull {
   ((BAG&lt;T&gt;)x).count(x).unknown;
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-BAG.promotionDSET">
					<head>Promotion of Sets to Bags (promotion) : <termref ref="dt-BAG">BAG</termref>&lt;T&gt;</head>
					<argument name="x" type="DSET&lt;T&gt;"/>
					<p>
							A discrete set of items can be promoted into a <emph>BAG</emph> that contains the same items.
							No items are lost during the promotion.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(DSET&lt;T&gt; x) where x.nonNull {
   ((BAG&lt;T&gt;)x).count.equal(x.count);
};

invariant(DSET&lt;T&gt; x, T y) where x.nonNull.and(y.nonNull) {
   ((BAG&lt;T&gt;)x).contains(y).equal(x.contains(y));
};
</pre>
					</exhibit>
				</div3>
				<div3 id="prop-BAG.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<p>
							Two bags are equal if and only if they are both empty, or if they both contain the same items.
						</p>
					<p>
						It is not necessary that the two <emph>BAG</emph>s have the same type for parameter
						T; as long as the two bags have parameter types that are comparable (for instance,
						<termref ref="dt-CD">CD</termref> and <termref ref="dt-CV">CV</termref>), the bags can be equal.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(BAG&lt;T&gt; x, BAG&lt;U&gt; y)
      where x.nonNull.and(y.nonNull).and(T.datatype.compares(U.datatype)) {
   x.equal(y).equal((forall(T e) {
      x.count(e).equal(y.count(e));
    }).and(forall(U e) {
      x.count(e).equal(y.count(e));
    }));
};</pre>
					</exhibit>
				</div3>
			</div2>
			<div2 id="dt-LIST">
				<anchor id="LIST"/>
				<head>Sequence (LIST) specializes <termref ref="dt-COLL">COLL</termref>
				</head>
				<parameter name="T" type="ANY"/>
				<p>
					<emph role="strong">Definition:     </emph>
					An ordered collection of discrete (but not necessarily distinct) values.
				</p>
				<exhibit role="dtdl" id="dtdl-LIST">
					<anchor id="dtdl-LIST"/>
					<caption/>
					<pre>
template&lt;ANY T&gt;
type Sequence&lt;T&gt; alias LIST&lt;T&gt; specializes COLL&lt;T&gt; {
             T        head;
             LIST&lt;T&gt;  tail;
             T        item(INT index);
             INT      length;
             LIST&lt;T&gt;  subList(INT start, INT end);
             LIST&lt;T&gt;  subList(INT start);
  literal    ST.SIMPLE;
  promotion  LIST&lt;T&gt;  (T x);
  demotion   BAG&lt;T&gt;;
};</pre>
				</exhibit>
				<p>
					A sequence MAY contain NULL values as items.
				</p>
				<p>
					The sequence is an ordered collection of values, but no particular
					order is associated with the sequence in the definition of <emph>LIST</emph>.
					The meaning of the order of the items SHALL be defined where a 
					<emph>LIST</emph> is used. Note that in some cases, the order is fixed ( 
					e.g. <termref ref="dt-HIST">HIST</termref>), but in other cases, the order
					is not fixed: only the meaning associated with the order in the instance
					is defined (e.g. <termref ref="dt-EN">EN</termref>, <termref ref="dt-AD">AD</termref>).
				</p>
				<div3 id="prop-LIST.head">
					<head>Head Item (head) : T</head>
					<p>
						<emph role="strong">Definition:     </emph>
							The first item in this sequence.  
						</p>
				</div3>
				<div3 id="prop-LIST.tail">
					<head>Tail Sequence (tail) : <termref ref="dt-LIST">LIST</termref>&lt;T&gt;</head>
					<p>
						<emph role="strong">Definition:     </emph>
							The sequence following the first item in this sequence. 
						</p>
				</div3>
				<div3 id="prop-LIST.isEmpty">
					<head>The Empty Collection (isEmpty) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-COLL">COLL</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
							A predicate that is <emph>true</emph> if this sequence contains no items.
						</p>
					<p>
							An empty sequence is a proper sequence, not an exceptional (null) value.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(LIST&lt;T&gt; x)
      where x.isEmpty {
   x.length.isZero;
   x.head.isNull;
   x.tail.isEmpty;
};</pre>
					</exhibit>
					<p>
							In an empty sequence, the length is zero, the tail is empty, and the 
							head is null. Note that both head and tail being NULL does not mean 
							that the sequence is empty; while this is a necessary condition of 
							an empty sequence, it is not sufficient for determining an empty list, since a sequence may
							contain NULL-values as items. Therefore this condition can mean that the sequence
							has only a head item that happens to be NULL.
						</p>
				</div3>
				<div3 id="prop-LIST.notEmpty">
					<head>Not-Empty (notEmpty) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-COLL">COLL</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
							A predicate that is <emph>true</emph> if this sequence
							contains at least one element. Negation of <termref ref="prop-LIST.isEmpty">isEmpty</termref>.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(LIST&lt;T&gt; x)
      where x.nonNull {
   x.notEmpty.equal(x.isEmpty.not);
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-LIST.item">
					<head>Item by Index (item) : T</head>
					<argument name="index" type="INT"/>
					<p>
						<emph role="strong">Definition:     </emph>
							The item at the given sequential position (index) in the sequence. The
							index zero refers to the first element (head) of the sequence.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(LIST&lt;T&gt; list; INT index)
      where list.nonNull.and(index.nonNegative) {
   list.isEmpty.implies(list.item(index).isNull);
   list.notEmpty.and(index.isZero)
       .implies(list.item(index).equal(list.head));
   list.notEmpty.and(index.nonZero)
       .implies(list.item(index).equal(
          list.tail.item(index.predecessor)));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-LIST.contains">
					<head>Contains Item (contains) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-COLL">COLL</termref>
					</head>
					<argument name="item" type="T"/>
					<p>
						<emph role="strong">Definition:     </emph>
							A predicate that is <emph>true</emph> if this sequence contains the
							given item value.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(LIST&lt;T&gt; list; T item)
      where list.nonNull {
   list.isEmpty.implies(list.contains(item).not);
   
   list.nonEmpty.and(item.nonNull).implies(list.contains(item).equal(
        list.head.equal(item).or(list.tail.contains(item))));
		
   list.notEmpty.and(item.isNull).implies(list.contains(item).equal(
        list.head.isNull.or(list.tail.contains(item))));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-LIST.length">
					<head>Length (length) : <termref ref="dt-INT">INT</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
							The number of elements in the sequence. NULL elements are counted as
							sequence elements.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(LIST&lt;T&gt; list)
      where list.nonNull {
   list.isEmpty.equal(list.length.isZero);
   list.notEmpty.equal(list.length.equal(list.tail.length.successor));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-LIST.count">
					<head>Count (count) : <termref ref="dt-INT">INT</termref>, inherited from <termref ref="dt-COLL">COLL</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
							The number of elements in the list.
						</p>
					<p>
							This property is defined for consistency of definitions of collection types. The
							count of the number of elements in a discrete set always matches the length
							of the list.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(LIST&lt;T&gt; list) where list.nonNull {
   list.count.equal(list.length);
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-LIST.subListTwo">
					<head>SubList (subList) : <termref ref="dt-LIST">LIST</termref>&lt;T&gt;</head>
					<argument name="start" type="INT"/>
					<argument name="end" type="INT"/>
					<p>
						<emph role="strong">Definition:     </emph>
							A contiguous subset of the list containing the items found in the list from index start to end, inclusively.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(LIST&lt;T&gt; x, INT start, end)
   where 
     x.nonNull.and(
	 start.greaterOrEqual(0)).and(
	 start.lessThan(x.length)).and(
	 end.greaterOrEqual(0)).and(
	 end.lessThan(x.length)).and(
	 start.lessOrEqual(end)) {
   x.subList(start, end).length.equal(end.minus(start).sucessor);
   forall(INT i) where i.greaterOrEqual(0).and(i.lessThen(end.minus(start))) {
     x.subList(start, end).item(i).equal(x.item(start.plus(i)));
   }
};</pre>
					</exhibit>
					<p>
							The list starts at item 0. If the bounds are less than 0 or greater than or equal to
							the length of the list, or if end is less than start, then the result of the operation
							is undefined (i.e. null).
						</p>
				</div3>
				<div3 id="prop-LIST.subListOne">
					<head>SubList (subList) : <termref ref="dt-LIST">LIST</termref>&lt;T&gt;</head>
					<argument name="start" type="INT"/>
					<p>
						<emph role="strong">Definition:     </emph>
							A contiguous subset of the list containing the items found in the list from index start to the end of the list, inclusively.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(LIST&lt;T&gt; x, INT start)
   where 
     x.nonNull.and(
	 start.greaterOrEqual(0)).and(
	 start.lessThan(x.length)).and(
	 end.greaterOrEqual(0)) {
   x.subList(start).length.equal(x.length.minus(start));
   forall(INT i) where i.greaterOrEqual(0) {
     x.subList(start).item(i).equal(x.item(start.plus(i)));
   }
};</pre>
					</exhibit>
					<p>
							The list starts at item 0. If the bounds are less than 0 or greater than or equal to
							the length of the list, then the result of the operation is undefined.
						</p>
				</div3>
				<div3 id="prop-LIST.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<p>
							Two lists are equal if and only if they are both empty, or if both
							their head and their tail are equal.
						</p>
					<p>
						It is not necessary that the two <emph>LIST</emph>s have the same type for parameter
						T; as long as the two lists have parameter types that are comparable (for instance,
						<termref ref="dt-CD">CD</termref> and <termref ref="dt-CV">CV</termref>), the lists can be equal.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(LIST&lt;T&gt; x, LIST&lt;U&gt; y)
      where x.nonNull.and(y.nonNull).and(T.datatype.compares(U.datatype)) {
   x.isEmpty.and(y.isEmpty).implies(x.equal(y));
   
   (x.notEmpty.and(y.isEmpty)).or(x.isEmpty.and(y.notEmpty)).implies(x.equal(y).not);
   
   x.notEmpty.and(y.notEmpty).and(x.head.nonNull).implies(
      x.equal(y).equal(x.head.equal(y.head).and(x.tail.equal(y.tail))));
	  
   x.notEmpty.and(y.notEmpty).and(x.head.isNull).implies(
      x.equal(y).equal(y.head.isNull.and(x.tail.equal(y.tail))));
};</pre>
					</exhibit>
					<p>
						Note that when lists contain null items, it is usually not possible to determine whether
						the lists are equal, though it may be possible to determine that they are different. For
						example, a list containing an unknown value is not equal to a list containing another 
						unknown value, nor are two lists holding values of PINF. However a list containing a 
						value of NINF is not equal to a list holding a value of PINF.
					</p>
				</div3>
				<div3 id="prop-LIST.literal">
					<head>Literal Form</head>
					<p>
							When the element type T has a literal form, the sequence <emph>LIST</emph>
							has a literal form. List elements
							are enumerated, separated by semicolon, and enclosed in parentheses.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
LIST&lt;T&gt;.literal ST.SIMPLE {
   LIST&lt;T&gt; : "(" elements ")"        { $.equal($2); }
           | "(" ")"                 { $.isEmpty; };
   LIST&lt;T&gt; elements
           : T ";" elements          { $.head.equal($1);
                                       $.tail.equal($3); }
           | T                       { $.head.equal($1);
                                       $.tail.isEmpty; };
};</pre>
					</exhibit>
					<table id="table-LIST.literal.example">
						<caption>Examples</caption>
						<thead>
							<tr>
								<th rowspan="1" colspan="1">literal</th>
								<th rowspan="1" colspan="1">meaning</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td rowspan="1" colspan="1">(1; 3; 5; 7; 19)</td>
								<td rowspan="1" colspan="1">a sequence of integer numbers or real numbers</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">(3; 1; 5; 19; 7)</td>
								<td rowspan="1" colspan="1">a different sequence of integer numbers or real numbers</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">(1.2 m; 17.8 m; 2.67 m)</td>
								<td rowspan="1" colspan="1">a sequence of discrete physical quantities</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">(apple; orange; banana)</td>
								<td rowspan="1" colspan="1">a sequence of character strings</td>
							</tr>
						</tbody>
					</table>
					<note role="ITS">
						<p>
								a character-based ITS SHOULD choose a different literal
								form for sequences if the Implementation Technology has a more native
								literal form for such collections.
							</p>
					</note>
				</div3>
				<div3 id="prop-LIST.promotionT">
					<head>Promotion of Item Values to Sequences (promotion) : <termref ref="dt-LIST">LIST</termref>&lt;T&gt;</head>
					<argument name="x" type="T"/>
					<p>
							A data value of type T can be promoted into a trivial sequence of T with
							that data value as its only item.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(T x) {
   ((LIST&lt;T&gt;)x).head.equal(x);
   ((LIST&lt;T&gt;)x).tail.isEmpty;
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-LIST.demotionBag">
					<head>Demotion of Sequences to Bags (demotion) : <termref ref="dt-BAG">BAG</termref>&lt;T&gt;</head>
					<p>
							A sequence (an ordered collection of items) can be demoted to a bag of items (no order). All items
							are preserved in the demotion.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(LIST&lt;T&gt; x) where x.nonNull {
   ((BAG&lt;T&gt;)x).count.equal(x.count);
};

invariant(LIST&lt;T&gt; x, T y) where x.nonNull.and(y.nonNull) {
   ((BAG&lt;T&gt;)x).contains(y).equal(x.contains(y));
};
</pre>
					</exhibit>
				</div3>
			</div2>
			<div2 id="dt-SET">
				<anchor id="SET"/>
				<head>Set (SET) specializes <termref ref="dt-ANY">ANY</termref>
				</head>
				<parameter name="T" type="ANY"/>
				<parameter name="C" type="COMP" default="CEQ"/>
				<p>
					<emph role="strong">Definition:     </emph>
					A value that contains distinct values in no particular order.
				</p>
				<exhibit role="dtdl" id="dtdl-SET">
					<anchor id="dtdl-SET"/>
					<caption/>
					<pre>
template&lt;ANY T, COMP C = CEQ&gt;
abstract type Set&lt;T, C&lt;T&gt;&gt; alias SET&lt;T, C&lt;T&gt;&gt; specializes ANY {
   C&lt;T&gt;    comparator;
   BL      contains(T element);
   BL      contains(SET&lt;T&gt; subset);
   BL      isEmpty;
   BL      notEmpty;
   INT     cardinality;
   SET&lt;T&gt;  union(SET&lt;T&gt; otherset);
   SET&lt;T&gt;  union(T element);
   SET&lt;T&gt;  except(SET&lt;T&gt; otherset);
   SET&lt;T&gt;  except(T element);
   SET&lt;T&gt;  intersection(SET&lt;T&gt; otherset);
};</pre>
				</exhibit>
				<p>
					A set SHALL NOT contain items that the comparator does not differentiate. When the default 
					equals based comparator applies, a set SHALL NOT contain NULL values as items.
				</p>
				<p>
					<emph>SET</emph> is an abstract type. There are two specializations of <emph>SET</emph> that are actually used 
					in models and instances, <termref ref="dt-DSET">DSET</termref> (Discrete Sets) and 
					<termref ref="dt-QSET">QSET</termref> (Quantity Sets). <termref ref="dt-DSET">DSET</termref>
					is for collection based sets that are composed of a series of discrete elements, and corresponds
					to general computationally friendly list found in most implementation environments. <termref ref="dt-QSET">QSET</termref>
					is for quantity based sets where it makes sense to build complex sets using expressions and ranges of values. <termref ref="dt-QSET">QSET</termref>s
					correspond to the mathematical notion of a set. Both types of sets support the common operations defined
					in <emph>SET</emph> that relate to the notion of set membership and related operations. <termref ref="dt-DSET">DSET</termref>
					extends this notion to include some collection specific operations. <termref ref="dt-QSET">QSET</termref> extends the
					notion to support a number of different methods for specifying set ranges and building complex sets
					based on set operations which are not possible for non-quantity based sets.
				</p>
				<p>
					There are some complex relationships between <termref ref="dt-DSET">DSET</termref> and <termref ref="dt-QSET">QSET</termref>. For example, 
					<termref ref="dt-IVL">IVL</termref>&lt;<termref ref="dt-INT">INT</termref>&gt;
					is a type that conforms to the semantics expressed in both a <termref ref="dt-DSET">DSET</termref> and a <termref ref="dt-QSET">QSET</termref>, though for
					purposes of definition, this specification defines an <termref ref="dt-IVL">IVL</termref> as a specialization of <termref ref="dt-QSET">QSET</termref>
					and not <termref ref="dt-DSET">DSET</termref>, since all types of <termref ref="dt-IVL">IVL</termref>s are also <termref ref="dt-QSET">QSET</termref>s. 
					The situation for <termref ref="dt-TS">TS</termref> is a little more complicated. <termref ref="dt-IVL">IVL</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;
					is not a <termref ref="dt-DSET">DSET</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;, but a <termref ref="dt-DSET">DSET</termref>&lt;<termref ref="dt-TS">TS</termref>&gt; may make sense in 
					some circumstances, and if a <termref ref="dt-DSET">DSET</termref>&lt;<termref ref="dt-TS">TS</termref>&gt; is defined, it also conforms to
					the semantics expressed in <termref ref="dt-QSET">QSET</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;. 
					A <termref ref="dt-DSET">DSET</termref>&lt;<termref ref="dt-PQ">PQ</termref>&gt; may also be a <termref ref="dt-QSET">QSET</termref>&lt;<termref ref="dt-PQ">PQ</termref>&gt; but
					only if all the values are comparable (this relationship is true for all
					<termref ref="dt-DSET">DSET</termref>&lt;<termref ref="dt-QTY">QTY</termref>&gt;). 
				</p>
				<p>	
					Generally, if T is a specialization of <termref ref="dt-QTY">QTY</termref>, then a <termref ref="dt-QSET">QSET</termref>
					would be the appropriate type of <termref ref="dt-SET">SET</termref> to specify in a model or use in an instance. 
				</p>
				<div3 id="prop-SET.comparator">
					<head>Comparator (comparator) : <termref ref="dt-C">C</termref>&lt;T&gt;</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The comparator used to define uniqueness and membership in the set.
					</p>
					<p>
						The uniqueness in the set is a function of the comparator.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(SET&lt;T&gt; x)
      where x.nonNull {
 forall(T a) where a.nonNull {
   forall(T b) where b.nonNull {
     /* if the comparator cannot compare a or b,
	    both cannot be in the Set */ 
	 x.contains(a).and(x.contains(b)).implies.
	    x.comparator.compare(a, b).nonNull;  
	   
     /* if both a and b are in the set, they must be different 
       (unless they are the are the same instance)*/ 
	 x.contains(a).and(x.contains(b)).implies(
	   a.identical(b).or(x.comparator.compare(a, b).not));
	 }
   }
};</pre>
					</exhibit>
					<p>
						Because of these constraints, considerable care must be taken in 
						defining the comparator. In particular, the equals-based comparator 
						SHALL always be used for types that are specializations of <termref ref="dt-QTY">QTY</termref>. 
						Note also that where a comparator could be defined that specifies
						nonNull outcomes for null values of T, sets MAY contain null values.
					</p>
					<p>
						Implementable Static Models SHALL always fix the comparator - it must not be left to be decided at run-time.
					</p>
				</div3>
				<div3 id="prop-SET.containsElement">
					<head>Contains Element (contains) : <termref ref="dt-BL">BL</termref>
					</head>
					<argument name="element" type="T"/>
					<p>
						<emph role="strong">Definition:     </emph>
							A relation of the set with a value, true if the given value is an
							element of the set.
						</p>
					<p>
							This is the primitive semantic property of a set, based on which all
							other properties are defined. Contains is ascertained using the comparator
							for the SET, which MAY specify some different comparison than the equals property.
						</p>
					<p>
								A set SHALL only contain distinct elements.
								Values for which the comparator is unable to differentiate cannot be
								elements of a set. For normal sets, based on <termref ref="dt-CEQ">CEQ</termref>,
								exceptional values (NULL-values) cannot be elements of a set.
							</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(SET&lt;T&gt; s, T m, n)
      where s.nonNull {
   s.contains(m).and(s.contains(n)).implies(s.comparator.compare(m,n).nonNull);
};

invariant(SET&lt;T&gt; s, T n)
      where s.nonNull.and(s.comparator.implies(CEQ)).and(n.isNull) {
   s.contains(n).not;
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-SET.containsSet">
					<head>Contains Subset (contains) : <termref ref="dt-BL">BL</termref>
					</head>
					<argument name="subset" type="SET&lt;T&gt;"/>
					<p>
						<emph role="strong">Definition:     </emph>
							The relation between a set and its subsets, where each element in the
							subset is also an element of the superset.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(SET&lt;T&gt; superset, subset) 
      where superset.nonNull.and(subset.nonNull) {
         superset.contains(subset).equal(
      forall(T element) where subset.contains(element) {
         superset.contains(element);      
	     });
};</pre>
					</exhibit>
					<p>
							This implies that the empty set is a subset of every set including
							itself.
						</p>
				</div3>
				<div3 id="prop-SET.isEmpty">
					<head>The Empty Set (isEmpty) : <termref ref="dt-BL">BL</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
							A predicate indicating that this set has no elements; the negation of
							<termref ref="prop-SET.notEmpty">notEmpty</termref>. The
							empty set is a proper set value, <emph>not</emph> an exceptional
							(NULL) value.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(SET&lt;T&gt; set)
      where set.nonNull {
   set.isEmpty.equal(notEmpty.not);
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-SET.notEmpty">
					<head>Not-Empty (notEmpty) : <termref ref="dt-BL">BL</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
							A predicate indicating that this set contains elements.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(SET&lt;T&gt; set)
      where set.nonNull {
   set.notEmpty.equal(exists(T element) {
      set.contains(element);
      });
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-SET.cardinality">
					<head>Cardinality (cardinality) : <termref ref="dt-INT">INT</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
							The number of distinct elements in the set.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(SET&lt;T&gt; set)
      where set.nonNull {
   exists(T element) where set.contains(element) {
      set.cardinality.equal(set.except(element)
                     .cardinality.successor);
         };
};</pre>
					</exhibit>
					<p>
							The cardinality definition works for finite sets in this specification, but is not sufficient since it doesn't converge
							for uncountably infinite sets (<termref ref="dt-REAL">REAL</termref>, <termref ref="dt-PQ">PQ</termref>, 
							etc.) and it doesn't terminate for infinite sets. The cardinality value is an example where it would
							be necessary to distinguish the cardinality &#8501;<emph role="sub">0</emph> 
							(<emph>aleph</emph>
						<emph role="sub">0</emph>) of countably infinite sets
							(e.g., <termref ref="dt-INT">INT</termref>) from &#8501;<emph role="sub">1</emph>
							(<emph>aleph</emph>
						<emph role="sub">1</emph>), the cardinality of uncountable sets 
							(e.g., <termref ref="dt-REAL">REAL</termref>, <termref ref="dt-PQ">PQ</termref>).
						</p>
				</div3>
				<div3 id="prop-SET.union">
					<head>Union (union) : <termref ref="dt-SET">SET</termref>&lt;T&gt;</head>
					<argument name="otherset" type="SET&lt;T&gt;"/>
					<p>
						<emph role="strong">Definition:     </emph>
							 A set for which each element is an element of at least one component set.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(SET&lt;T&gt; x, y, z)
      where x.nonNull.and(y.nonNull).and(z.nonNull) {
   x.union(y).equal(z).equal(forall(T e) {
      z.contains(e).equal(x.contains(e).or(y.contains(e)));
      });
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-SET.unionElement">
					<head>Include Element (union) : <termref ref="dt-SET">SET</termref>&lt;T&gt;</head>
					<!-- FIXME what, why hide? -->
					<argument name="element" type="T"/>
					<p>
						<emph role="strong">Definition:     </emph>
							A union of a set and an element.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(SET&lt;T&gt; set, singletonset; T element)
      where set.nonNull.and(element.nonNull)
               .and(singletonset.cardinality.isOne)
               .and(singletonset.contains(element)) {
   set.union(element).equal(set.union(singleton));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-SET.difference">
					<head>Set Difference (except) : <termref ref="dt-SET">SET</termref>&lt;T&gt;</head>
					<argument name="otherset" type="SET&lt;T&gt;"/>
					<p>
						<emph role="strong">Definition:     </emph>
							 The set containing all elements of the subtracted set that are not elements of the subtracting set.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(SET&lt;T&gt; x, y, z)
      where x.nonNull.and(y.nonNull).and(z.nonNull) {
   x.except(y).equal(z).equal(forall(T e) {
      z.contains(e).equal(x.contains(e).and(y.contains(e).not));
      });
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-SET.exceptElement">
					<head>Exclude Element (except) : <termref ref="dt-SET">SET</termref>&lt;T&gt;</head>
					<argument name="element" type="T"/>
					<p>
						<emph role="strong">Definition:     </emph>
							The set that contains all elements of this set except for the subtracting element value. 
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(SET&lt;T&gt; x, z; T d)
      where x.nonNull.and(z.nonNull).and(d.nonNull) {
   x.except(d).equal(z).equal(forall(T e) {
      z.contains(e).equal(x.contains(e).and(d.equal(e).not));
      });
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-SET.intersect">
					<head>Intersection (intersection) : <termref ref="dt-SET">SET</termref>&lt;T&gt;</head>
					<argument name="otherset" type="SET&lt;T&gt;"/>
					<p>
						<emph role="strong">Definition:     </emph>
							 The set containing all and only those elements that are contained in both of the operand sets.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(SET&lt;T&gt; x, y, z)
      where x.nonNull.and(y.nonNull).and(z.nonNull) {
   x.intersection(y).equal(z).equal(forall(T e) {
      z.contains(e).equal(x.contains(e).and(y.contains(e)));
      });
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-SET.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<argument name="x" type="SET"/>
					<p>
						Two nonNull <emph>SET</emph>s are equal if they have the same elements.
						It is not necessary that the two <emph>SET</emph>s have the same type for parameter
						T; as long as the two sets have parameter types that are comparable (for instance,
						<termref ref="dt-CD">CD</termref> and <termref ref="dt-CV">CV</termref>), the sets can be equal.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(SET&lt;T&gt; x, SET&lt;U&gt; y)
      where x.nonNull.and(y.nonNull).and(T.datatype.compares(U.datatype)) {
   x.equal(y).equal((forall(T e) {
      x.contains(e).equal(y.contains(e));
    }).and(forall(U e) {
      x.contains(e).equal(y.contains(e));
    }));
};</pre>
					</exhibit>
				</div3>
			</div2>
			<div2 id="dt-COMP">
				<anchor id="COMP"/>
				<head>Comparator (COMP)</head>
				<parameter name="T" type="ANY"/>
				<p>
					<emph role="strong">Definition:     </emph>
					An abstract type that defines a comparison between two values of the same type.
				</p>
				<exhibit role="dtdl" id="dtdl-COMP">
					<anchor id="dtdl-COMP"/>
					<caption/>
					<pre>
template&lt;ANY T&gt;
abstract protected type Comparator&lt;T&gt; alias COMP&lt;T&gt; {
   TYPE  dataType;
    BL      compare(T element1, T element2);
};</pre>
				</exhibit>
				<p>
					Although every type has a clear definition of the meaning of semantic equality, this
					definition does not always fit a particular use: in these cases, a specialization of
					<emph>COMP</emph> that expresses the criteria for the comparison relationship may be used.
					The comparator type is defined to allow custom definitions of the meaning of equality
					between types. This is most useful in defining the criteria for uniqueness in a
					<termref ref="dt-SET">SET</termref> but may find other applications in implementation environments.
				</p>
				<p>
				  COMP is an abstract type, and no actual comparator is defined.
				</p>
				<note role="ITS">
					<p>
						<emph>COMP</emph> and its descendants never appear in an instance, and an ITS should not
						create a representation for them.
					</p>
				</note>
				<p>
					Because <emph>COMP</emph> never appears in the instance, new specializations of <emph>COMP</emph>
					MAY be defined outside of this specification. All new specializations SHALL
					be approved at harmonisation prior to being included in a normative specification.
				</p>
				<p>
					An example of a custom comparator might be to specify that a particular <termref ref="dt-SET">SET</termref>
					of <termref ref="dt-TEL">TEL</termref> is allowed to contain the same telecommunication address more than once if
					it has different useablePeriod properties. In this case, compare should return false if only
					one of the two <termref ref="dt-TEL">TEL</termref>s has a useablePeriod, or if they both do and they are
					different. Here is how to define such a comparator:
				</p>
				<exhibit role="dtdl">
					<caption/>
					<pre>
type MyTelephoneComparator alias MYTELCOMP specializes COMP&lt;TEL&gt;{
    BL      compare(T element1, T element2);
};

invariant(MYTELCOMP c, TEL x, y)
      where x.equal(y).nonNull {
   c.compare(x, y).equal(
     x.equal(y)
      .and(x.useablePeriod.isNull.xor(y.useablePeriod.isNull)).not
	  .or(x.useablePeriod.nonNull.implies(
	     x.useablePeriod.equals(y.useablePeriod))));
};
</pre>
				</exhibit>
				<p>
					A set that used this comparator would be defined as 
					<termref ref="dt-DSET">DSET</termref>&lt;<termref ref="dt-TEL">TEL</termref>, MYTELCOMP&gt;.
				</p>
				<div3 id="prop-COMP.dataType">
					<head>Data Type (dataType) : <termref ref="dt-TYPE">TYPE</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The data type of the comparator. 
					</p>
					<p>
						Every comparator implicitly carries
						information about its own data type.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(COMP x) {
   x.dataType.nonNull;
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-COMP.compare">
					<head>Comparison (compare) : <termref ref="dt-BL">BL</termref>
					</head>
					<argument name="element1" type="T"/>
					<argument name="element2" type="T"/>
					<p>
						<emph role="strong">Definition:     </emph>
						The result of comparing the two elements.
					</p>
					<p>
						Like the equality relationship, comparison is a reflexive, symmetric, and transitive
						relationship between any two data values.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(COMP&lt;T&gt; c, T x, y, z)
      where x.nonNull.and(y.nonNull).and(z.nonNull) {
   c.compare(x, x);                                                 /* reflexivity */
   c.compare(x, y).equal(c.compare(y, x));                          /* symmetry */
   c.compare(x, y).and(c.compare(y, z)).implies(c.compare(x, z));   /* transitivity */
};</pre>
					</exhibit>
				</div3>
			</div2>
			<div2 id="dt-CEQ">
				<anchor id="CEQ"/>
				<head>EqualComparator (CEQ) specializes <termref ref="dt-COMP">COMP</termref>
				</head>
				<parameter name="T" type="ANY"/>
				<p>
					<emph role="strong">Definition:     </emph>
					A comparator based on the equality relationship defined for all types.
				</p>
				<exhibit role="dtdl" id="dtdl-COMP">
					<anchor id="dtdl-COMP"/>
					<caption/>
					<pre>
template&lt;ANY T&gt;
type EqualComparator&lt;T&gt; alias CEQ&lt;T&gt; specializes COMP&lt;T&gt; {
    BL      compare(T element1, T element2);
};</pre>
				</exhibit>
				<p>
					This is the default concrete comparator that compares the two values based on the 
					equality relationship defined for all types.
				</p>
				<div3 id="prop-CEQ.compare">
					<head>Comparison (compare) : <termref ref="dt-BL">BL</termref>
					</head>
					<argument name="element1" type="T"/>
					<argument name="element2" type="T"/>
					<p>
						<emph role="strong">Definition:     </emph>
						The value of the equality relationship between the two values.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(CEQ&lt;T&gt; c, T x, y)
      where x.equal(y).nonNull {
   c.compare(x, y).equal(x.equal(y));
};</pre>
					</exhibit>
				</div3>
			</div2>
			<div2 id="dt-DSET">
				<anchor id="DSET"/>
				<head>DiscreteSet (DSET) specializes <termref ref="dt-SET">SET</termref> and <termref ref="dt-COLL">COLL</termref>
				</head>
				<parameter name="T" type="ANY"/>
				<parameter name="C" type="COMP"/>
				<p>
					<emph role="strong">Definition:     </emph>
					An unordered collection of values that contains discrete distinct values.
				</p>
				<p>
					A <emph>DSET</emph> differs from the general <termref ref="dt-SET">SET</termref> because it is constrained to
					contain only discrete items. The practical consequence of this is that a <emph>DSET</emph> can
					be iterated, like bag, but unlike <termref ref="dt-QSET">QSET</termref>.  
				</p>
				<exhibit role="dtdl" id="dtdl-DSET">
					<anchor id="dtdl-DSET"/>
					<caption/>
					<pre>
template&lt;ANY T, COMP C = CEQ&gt;
type DiscreteSet&lt;T, C&lt;T&gt;&gt; alias DSET&lt;T, C&lt;T&gt;&gt; specializes SET&lt;T, C&lt;T&gt;&gt;, COLL&lt;T&gt; {
   literal    ST.SIMPLE;
   promotion  DSET&lt;T&gt;  (T x);
};</pre>
				</exhibit>
				<div3 id="prop-DSET.count">
					<head>Count (count) : <termref ref="dt-INT">INT</termref>, inherited from <termref ref="dt-COLL">COLL</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
							The number of elements in the set.
						</p>
					<p>
							This property is defined for consistency of definitions of collection types. The
							count of the number of elements in a discrete set always matches the cardinality
							of the set.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(DSET&lt;T&gt; set) where set.nonNull {
   set.count.equal(set.cardinality);
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-DSET.literal">
					<head>Literal Form</head>
					<p>
							When the element type T has a literal form, the discrete set of T elements has
							a literal form, wherein the elements of the set are enumerated within
							curly braces and separated by semicolon characters.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
DSET&lt;T&gt;.literal ST.SIMPLE {
   DSET&lt;T&gt;          : "{" elements "}"   { $.equal($2); };
   DSET&lt;T&gt; elements : elements ";" T     { $.except($2).equal($1); }
                  | T                   { $.contains($1);
                                          $.except($1).isEmpty; };
};</pre>
					</exhibit>
					<note>
						<p>
								This literal form for sets is only practical for relatively small
								discrete sets; this does not mean, however, that all sets are
								relatively small enumerations of elements.
							</p>
					</note>
					<table id="table-SET.literal.example">
						<caption>Example</caption>
						<thead>
							<tr>
								<th rowspan="1" colspan="1">literal</th>
								<th rowspan="1" colspan="1">meaning</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td rowspan="1" colspan="1">{1; 3; 5; 7; 19}</td>
								<td rowspan="1" colspan="1">a set of integer numbers or real numbers</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">{3; 1; 5; 19; 7}</td>
								<td rowspan="1" colspan="1">the same set of integer numbers or real numbers</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">{1.2 m; 2.67 m; 17.8 m}</td>
								<td rowspan="1" colspan="1">a set of discrete physical quantities</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">{apple; orange; banana}</td>
								<td rowspan="1" colspan="1">a set of character strings</td>
							</tr>
						</tbody>
					</table>
					<note role="ITS">
						<p>
								A character-based ITS SHOULD choose a different literal
								form for discrete sets if the Implementation Technology has a more native
								literal form for such collections.
							</p>
					</note>
				</div3>
				<div3 id="prop-DSET.promotionT">
					<head>Promotion of Element Values to Sets (promotion) : <termref ref="dt-DSET">DSET</termref>&lt;T&gt;</head>
					<argument name="x" type="T"/>
					<p>
							A data value of type T can be promoted into a trivial discrete set of T with
							that data value as its only element.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(T x) where x.nonNull {
   ((DSET&lt;T&gt;)x).contains(x);
   ((DSET&lt;T&gt;)x).except(x).isEmpty;
};

invariant(T x) where x.isNull {
   ((DSET&lt;T&gt;)x).isNull;
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-DSET.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<argument name="x" type="SET&lt;T&gt;"/>
					<p>
						The evaluation of equality for <emph>DSET</emph> is taken from
						the <termref ref="dt-SET">SET</termref> data type: Two nonNull <termref ref="dt-SET">SET</termref>s are
						equal if they have the same elements.
					</p>
					<p>
								This means that values of the type <emph>DSET</emph> and any other kind of SET MAY be equal.
							</p>
				</div3>
			</div2>
			<div2 id="dt-HXIT">
				<anchor id="HXIT"/>
				<head>HistoryItem (HXIT) specializes T</head>
				<parameter name="T" type="ANY"/>
				<p>
					<emph role="strong">Definition:     </emph>
					A generic data type extension that adds a time range and/or link to the ControlAct 
					associated with the creation of the data on any data value whatever its data type. 
				</p>
				<p>
					<termref ref="dt-HXIT">HXIT</termref> adds the controlActIdRef property to the the base type T.
					In addition, if the base type T does not possess a validTime property, the
					<termref ref="dt-HXIT">HXIT</termref> adds that property to the base type. If, however,
					the base type T does have a valid time property (currently only <termref ref="dt-EN">EN</termref>),
					that property is mapped to the valid time property of the
					<termref ref="dt-HXIT">HXIT</termref> and the <emph>HXIT</emph> constraints on validTime apply.<footnote>.
						<p>
							Note that data types are specifications of abstract properties of
							values. This specification does not mandate how these values are
							represented in an ITS or implemented in an application. Specifically,
							it does not mandate how the represented components are named or
							positioned. In addition, the semantic generalization hierarchy may be
							different from a class hierarchy chosen for implementation (if the
							implementation technology has inheritance).  Keep the distinction
							between a type (interface) and an implementation (concrete data
							structure, class) in mind. The ITS SHALL contain a mapping of ITS
							defined features of any data type to the semantic properties defined
							here.
						</p>
					</footnote>
				</p>
				<p>
					The time range is the time in which the information	represented by the value is (or was) valid.
					The ControlAct id reference indicates the event responsible for the value of the data type.
					The time range is not the time during which any particular system considered this 
					information valid (as in, an audit trail), though the link to the control act may
					provide some information of relevance in this regard.				  
				  </p>
				<exhibit role="dtdl" id="dtdl-HXIT">
					<anchor id="dtdl-HXIT"/>
					<caption/>
					<pre>
template&lt;ANY T&gt;
type HistoryItem&lt;T&gt; alias HXIT&lt;T&gt; specializes T {
   IVL&lt;TS&gt; validTime;
   BL comesBefore(HXIT&lt;T&gt;);
   II controlActIdRef;  
};</pre>
				</exhibit>
				<div3 id="prop-HXIT.validTime">
					<head>Valid Time (validTime) : <termref ref="dt-IVL">IVL</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The time interval during which the given information was, is, or is
						expected to be valid. The interval can be closed-- i.e. finite and
						defined&#8212;or open&#8212;i.e. infinite or undefined &#8212;on either side. The interval
						cannot be just a width, nor can the width be zero
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(HXIT&lt;T&gt; x) where x.nonNull {
  x.validTime.nonNull.implies(x.validTime.low.nonNull.or(x.validTime.high.nonNull));
  x.validTime.nonNull.implies(x.validTime.width.isZero.not);
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-HXIT.comesBefore">
					<head>Comes Before (comesBefore) : <termref ref="dt-BL">BL</termref>
					</head>
					<parameter name="T" type="HXIT&lt;T&gt;"/>
					<p>
						<emph role="strong">Definition:     </emph>
						A predicate expressing a chronological order relation that is asymmetric and
						transitive, between this <emph>HXIT</emph> and another <emph>HXIT</emph>. 
					</p>
					<p>
						A <emph>HXIT</emph> comes before another in a sequence of history items (<termref ref="dt-HIST">HIST</termref>) if 
						the high boundary of the validTime is less or equal to the low boundary of the other interval.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(HXIT&lt;T&gt; x, y) where x.validTime.nonNull.and(y.validTime.nonNull) {
  x.comesBefore(y).implies(x.validTime.high.nonNull);
  x.comesBefore(y).implies(y.validTime.low.nonNull);
  x.comesBefore(y).implies(x.validTime.high.lessOrEqual(y.validTime.low));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-HXIT.controlActIdRef">
					<head>ControlAct Id Reference (controlActIdRef) : <termref ref="dt-II">II</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
					The identifier of the ControlAct associated with setting the data type to its specified value. 
					</p>
					<p>
					By referencing
					a particular ControlAct, the property links to all of the information surrounding that ControlAct, such as who
					made the change, when it was made, why it was made, what system originated the change, etc.
					</p>
				</div3>
			</div2>
			<div2 id="dt-HIST">
				<anchor id="HIST"/>
				<head>History (HIST) specializes <termref ref="dt-LIST">LIST</termref>&lt;<termref ref="dt-HXIT">HXIT</termref>&lt;T&gt;&gt;</head>
				<parameter name="T" type="ANY"/>
				<p>
					<emph role="strong">Definition:     </emph>
					A list of data values that have a valid-time property.
				</p>
				<p>
					The intent of <emph>HIST</emph> is to capture the true historical
					(and future) values of an item, rather than the audit trail of
					values any given system has held for the item.
					The history information is not limited to the past; expected future
					values MAY also appear.
				</p>
				<exhibit role="dtdl" id="dtdl-HIST">
					<anchor id="dtdl-HIST"/>
					<caption/>
					<pre>
template&lt;ANY T&gt;
type History&lt;T&gt; alias HIST&lt;T&gt; specializes LIST&lt;HXIT&lt;T&gt;&gt; {
            HXIT&lt;T&gt;  current;
            HXIT&lt;T&gt;  earliest;
            HIST&lt;T&gt;  exceptEarliest;
            HXIT&lt;T&gt;  latest;
            HIST&lt;T&gt;  exceptLatest;
  demotion  HXIT&lt;T&gt;;
};</pre>
				</exhibit>
				<p>
					All items in the list SHALL have a non-null validTime property. 
					The validTime periods on the list SHALL NOT overlap.
					The contents of <emph>HIST</emph> SHALL be ordered in ascending chronological order.
				</p>
				<exhibit role="dtdl">
					<caption/>
					<pre>
invariant(HIST x; HXIT&lt;T&gt; e)
      where x.nonNull {
  x.contains(e).implies(e.validTime.nonNull);

  forall(INT.POSITIVE i) where i.lessThan(x.length) {
      x.item(i.predecessor).comesBefore(x.item(i));
  };
};</pre>
				</exhibit>
				<p>
						If a list of historical items should allow multiple items and/or overlapping
						ranges, then the type of the attribute should be <termref ref="dt-BAG">BAG</termref>&lt;<termref ref="dt-HXIT">HXIT</termref>&lt;T&gt;&gt;.
						The type <termref ref="dt-HIST">HIST</termref>&lt;<termref ref="dt-SET">SET</termref>&lt;T&gt;&gt; actually denotes a history of the set
						values themselves. The semantics of <termref ref="dt-SET">SET</termref>&lt;<termref ref="dt-HXIT">HXIT</termref>&lt;T&gt;&gt; become
						very complicated; given that validTime is usually excluded from the equality test, this type should not be used. 
					</p>
				<div3 id="prop-HIST.current">
					<head>Current Item (current) : <termref ref="dt-HXIT">HXIT</termref>&lt;T&gt;</head>
					<p>
						<emph role="strong">Definition:     </emph>
							The item in the list whose validTime interval includes the current time.
						</p>
					<p>
							Note that the current time is not necessarily the same time as the instant
							at which an instance is being processed. The relevant current time will be 
							dictated by the context of operation.
						</p>
					<p>
							There may be no current value, in which case the value of this operation is NULL.
						</p>
				</div3>
				<div3 id="prop-HIST.earliest">
					<head>Earliest Item (earliest) : <termref ref="dt-HXIT">HXIT</termref>&lt;T&gt;</head>
					<p>
						<emph role="strong">Definition:     </emph>
							The item in the list whose <termref ref="prop-IVL.LOW">IVL.LOW</termref> boundary
							(validity start	time) is less than (i.e. before) or equal to
							that of any other history item in the list.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(HIST x; HXIT&lt;T&gt; e)
      where x.contains(e) {
   x.earliest.validTime.low.lessOrEqual(e.validTime.low);
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-HIST.exceptEarliest">
					<head>Except Earliest Item (exceptEarliest) : <termref ref="dt-HIST">HIST</termref>&lt;T&gt;</head>
					<p>
						<emph role="strong">Definition:     </emph>
							The derived history that has the earliest item excluded.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(HIST x)
      where x.nonNull {
   x.exceptEarliest.equal(x.except(x.earliest));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-HIST.latest">
					<head>Latest Item (latest) : <termref ref="dt-HXIT">HXIT</termref>&lt;T&gt;</head>
					<p>
						<emph role="strong">Definition:     </emph>
							The item in the list whose <termref ref="prop-IVL.HIGH">IVL.HIGH</termref> boundary (validity end
							time) is greater than (i.e. after) or equal to that of any other history item
							in the list.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(HIST x; HXIT&lt;T&gt; e)
      where x.contains(e) {
   x.latest.validTime.high.greaterOrEqual(e.validTime.high);
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-HIST.exceptLatest">
					<head>Except Latest Item (exceptLatest) : <termref ref="dt-HIST">HIST</termref>&lt;T&gt;</head>
					<p>
						<emph role="strong">Definition:     </emph>
							The derived history that has the latest item excluded.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(HIST x)
      where x.nonNull {
   x.exceptLatest.equal(x.except(x.latest));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-HIST.demotionHXIT">
					<head>Demotion of a History to a Single History Item (demotion) : <termref ref="dt-HXIT">HXIT</termref>&lt;T&gt;</head>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(HIST x)
      where x.nonNull {
   x.notEmpty;
   ((T)x).equal(x.current);
};</pre>
					</exhibit>
					<p>
							A type conversion between an entire history <termref ref="dt-HIST">HIST</termref>
							and a single history item <termref ref="dt-HXIT">HXIT</termref>. This conversion
							takes the current data from the history, if a current value exists.
						</p>
					<p>
							The purpose of this conversion is to allow an information producer to
							produce a history of any value instead of sending just one value.<footnote>
							<p>
									Note, from the definition of <termref ref="dt-HXIT">HXIT</termref>, that
									<termref ref="dt-HXIT">HXIT</termref> semantically specializes T. This means, that the
									information-consumer expecting a T but given an <termref ref="dt-HXIT">HXIT</termref>
									need not recognize any difference (substitutability of
									specializations).
								</p>
						</footnote>
							An information-consumer, who does not expect a history but a simple
							value, will convert the history to the current value. Note that the
							source system may only send a history of a value if the constraining
							models permits this.
						</p>
				</div3>
				<div3 id="prop-HIST.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<argument name="x" type="BL"/>
					<p>
						The evaluation of equality for <emph>HIST</emph> is the same as the <termref ref="dt-LIST">LIST</termref> data type. 
								This means that values of the type HIST and LIST may be equal.
							</p>
				</div3>
			</div2>
		</div1>
		<div1 id="datyp2bastyp">
			<head>Basic Types</head>
			<graphic source="graphics/dtUML-Text.png" alt="Overview of Text and Multimedia Data Types"/>
			<div2 id="dt-BIN">
				<anchor id="BIN"/>
				<head>BinaryData (BIN) specializes <termref ref="dt-LIST">LIST</termref>&lt;<termref ref="dt-BN">BN</termref>&gt;</head>
				<p>
					<emph role="strong">Definition:     </emph>
					A raw block of bits. 
				</p>
				<p>
					<emph>BIN</emph> is a protected type that SHALL NOT be assigned to any property outside the data type specification.
				</p>
				<p>
					A bit is semantically identical with a non-null <termref ref="dt-BL">BL</termref> value. Thus,
					all binary data is &#8212; semantically &#8212; a sequence of non-null
					<termref ref="dt-BL">BL</termref> values.
				</p>
				<exhibit role="dtdl" id="dtdl-BIN">
					<anchor id="dtdl-BIN"/>
					<caption/>
					<pre>
protected type BinaryData alias BIN specializes LIST&lt;BN&gt;;</pre>
				</exhibit>
				<note role="ITS">
					<p>
						The representation of arbitrary binary data is the responsibility of
						an ITS. How the ITS accomplishes this depends on the underlying
						Implementation Technology (whether it is character-based or binary)
						and on the represented data. Character data MAY be
						represented as binary data; however, a character-based ITS SHOULD NOT
						convert character data into arbitrary binary data and then represent
						binary data in a character encoding.  E.g., the letter "J" might be 
						encoded as ASCII "74" (or hexadecimal "4A"): these character 
						representations of numerical data should not be represented in 
						lieu of the original "J."
					</p>
				</note>
				<p>
						An empty sequence is not considered binary data but counts as a
						NULL-value. In other words, non-NULL binary data contains at least one
						bit. All bits in a non-NULL binary data value SHALL NOT be NULL.
					</p>
				<exhibit role="dtdl">
					<caption/>
					<pre>
invariant(BIN x)
      where x.nonNull {
   x.notEmpty;
   x.length.greaterThan(0);
};</pre>
				</exhibit>
				<div3 id="prop-BIN.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<argument name="x" type="BL"/>
					<p>
						The evaluation of equality for <emph>BIN</emph> is the same as the <termref ref="dt-LIST">LIST</termref> data type.
					</p>
					<p>
								This means that values of the type BIN and LIST&lt;BL&gt; may be equal.
							</p>
				</div3>
			</div2>
			<div2 id="dt-ED">
				<anchor id="ED"/>
				<head>EncapsulatedData (ED) specializes <termref ref="dt-ANY">ANY</termref>
				</head>
				<p>
					<emph role="strong">Definition:     </emph>
					Data that is primarily intended for human interpretation or for
					further machine processing outside the scope of HL7. 
				</p>
				<p>
					This includes unformatted or formatted written language, multimedia data, or
					structured information as defined by a different standard (e.g.,
					XML-signatures).  Instead of the data, an <emph>ED</emph>
					may contain only a reference (see <termref ref="dt-TEL">TEL</termref>). Note that
					<termref ref="dt-ST">ST</termref> is a specialization of 
					<emph>ED</emph> where the <termref ref="prop-ED.mediaType">mediaType</termref> is fixed to text/plain 
					and several other properties are constrained to null.
				</p>
				<table id="dt-ED-prop-summary">
					<caption>Property Summary of
      EncapsulatedData</caption>
					<col width="79"/>
					<col width="60"/>
					<col width="413"/>
					<thead>
						<tr>
							<th>Name</th>
							<th>Type</th>
							<th>Description</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>
								<termref ref="prop-ED.data">data</termref>
							</td>
							<td>
								<termref ref="dt-BIN">BIN</termref>
							</td>
							<td>
						The binary content of the <emph>ED</emph>
							</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-ED.mediaType">mediaType</termref>
							</td>
							<td>
								<termref ref="dt-CS">CS</termref>
							</td>
							<td>
						 The type of the encapsulated data. 
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-ED.charset">charset</termref>
							</td>
							<td>
								<termref ref="dt-CS">CS</termref>
							</td>
							<td>
						An Internet Assigned Numbers Authority (IANA) Charset Registered character set 
						and character encoding for character-based media types.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-ED.language">language</termref>
							</td>
							<td>
								<termref ref="dt-CS">CS</termref>
							</td>
							<td>
						  The human language of the content.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-ED.compression">compression</termref>
							</td>
							<td>
								<termref ref="dt-CS">CS</termref>
							</td>
							<td>
						 The compression algorithm, if any, used on the raw byte data.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-ED.reference">reference</termref>
							</td>
							<td>
								<termref ref="dt-TEL.URL">TEL.URL</termref>
							</td>
							<td>
						A URL the target of which is taken as the binary content of the ED.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-ED.integrityCheck">integrityCheck</termref>
							</td>
							<td>
								<termref ref="dt-BIN">BIN</termref>
							</td>
							<td>
						A checksum calculated over the binary data. 
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-ED.integrityCheckAlgorithm">integrityCheckAlgorithm</termref>
							</td>
							<td>
								<termref ref="dt-CS">CS</termref>
							</td>
							<td>
						The algorithm used to compute the integrityCheck value. 
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-ED.description">description</termref>
							</td>
							<td>
								<termref ref="dt-ST">ST</termref>
							</td>
							<td>
 					    An alternative description of the media where the context is not suitable for rendering the media.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-ED.thumbnail">thumbnail</termref>
							</td>
							<td>
								<termref ref="dt-ED">ED</termref>
							</td>
							<td>
						An abbreviated rendition of the full data.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-ED.translation">translation</termref>
							</td>
							<td>
								<termref ref="dt-DSET">DSET</termref>&lt;<termref ref="dt-ED">ED</termref>&gt;</td>
							<td>
						Alternate renditions of the same content translated into a different language or a different
						mediaType. The translation property is a set of <emph>ED</emph> that each translate the first rendition
						into a different language or use a different mediaType. Each element of the translation set SHALL
						be a translation of the <emph>ED</emph> value. Translations SHALL NOT contain translations.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-ED.length">length</termref>
							</td>
							<td>
								<termref ref="dt-INT">INT</termref>
							</td>
							<td>
						The length of the content in the <emph>ED</emph>.
					</td>
						</tr>
					</tbody>
				</table>
				<exhibit role="dtdl" id="dtdl-ED">
					<anchor id="dtdl-ED"/>
					<caption/>
					<pre>
type EncapsulatedData alias ED specializes ANY {
   BIN     data;
   CS      mediaType;
   CS      charset;
   CS      language;
   CS      compression;
   TEL.URL reference;
   BIN     integrityCheck;
   CS      integrityCheckAlgorithm;
   ST      description;
   ED      thumbnail;
   DSET&lt;ED&gt; translation;

   INT     length;
   ED      subPart(INT start, INT end);
};</pre>
				</exhibit>
				<p>   
					Encapsulated data can be present in two forms, inline or by
					reference. Inline data is communicated or moved as part of the
					encapsulated data value, whereas by-reference data may reside at a
					different (remote) location. The data is the same whether it is
					located inline or remote.
				</p>
				<div3 id="prop-ED.data">
					<head>Binary Data (data) : <termref ref="dt-BIN">BIN</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The binary content of the <emph>ED</emph>
					</p>
					<p>
						<emph>ED</emph> acts as a wrapper of binary content. Operations performed against the <emph>ED</emph>
						directly are mediated by the mediatype and, if so indicated by the mediatype, the
						character set. For example, two <termref ref="dt-BIN">BIN</termref> values are equal if they have
						the same sequence of bits in their content. However the <emph>ED</emph> are only equal if
						they have the same sequence of logical items. For instance, if the media type is a kind of
						text, then the sequence of characters indicated by the character set and the binary
						content must be equal. Similarly, the length of an ED is the number of component
						parts as indicated by the mediatype. For application and image media types, the
						length of <emph>ED</emph> is the same as the length of the <emph>data</emph>. Note that operations may also be performed directly upon
						the binary content by using <emph>data</emph>. 
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(ED x)
      where x.nonNull {
   x.data.nonNull;			
};</pre>
					</exhibit>
					<p>
						Although data SHALL be nonNull if the <emph>ED</emph> is not null, it need not be 
						contained in-line in the instance; instead, the binary content, along with some 
						other properties, MAY be defined by the <termref ref="prop-ED.reference">reference</termref>
						property. 
					</p>
				</div3>
				<div3 id="prop-ED.mediaType">
					<head>Media Type (mediaType) : <termref ref="dt-CS">CS</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						 The type of the encapsulated data. 
					</p>
					<p>
						The default mediaType is text/plain.
						The type of the encapsulated data may help identify a
						method to interpret or render the data. 
					</p>
					<p>
						<emph>mediaType</emph> is a mandatory property, i.e., every non-NULL instance of
							<emph>ED</emph> SHALL have a non-NULL <emph>mediaType</emph> property.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(ED x)
      where x.nonNull {
   x.mediaType.nonNull;
};</pre>
					</exhibit>
					<p>
						The IANA defined domain of media types is established by the Internet
						standard RFC 2045 [<loc href="http://www.ietf.org/rfc/rfc2045.txt" xlink-form="simple" show="embed" actuate="auto"/>]
						and 2046 [<loc href="http://www.ietf.org/rfc/rfc2046.txt" xlink-form="simple" show="embed" actuate="auto"/>].
						RFC 2046 defines the media type to consist of two parts:
					</p>
					<list role="ordered">
						<item>
							top level media type, and
						</item>
						<item>
							media subtype
						</item>
					</list>
					<p>
						However, this specification treats the entire media type as one atomic
						code symbol in the form defined by IANA, i.e., top level type followed
						by a slash "/" followed by media subtype. Currently defined media
						types are registered in a database
						[<loc href="http://www.iana.org/assignments/media-types/index.html" xlink-form="simple" show="embed" actuate="auto"/>]
						maintained by IANA. Currently several hundred different MIME media types are
						defined, with the list growing rapidly. In general, all those types
						defined by the IANA MAY be used.
					</p>
					<p>
						To promote interoperability, this specification prefers certain media
						types to others. This is to define a greatest common denominator on
						which interoperability is not only possible, but that is powerful
						enough to support even advanced multimedia communication needs.
					</p>
					<p>
						<tabref ref="domain-mediaType"/> below assigns a status to
						certain MIME media types, where the status means one of the following:
					</p>
					<list role="unordered">
						<item>
							<emph role="strong">required</emph>: Every HL7 application
							SHALL support at least the required media types if it supports a given
							kind of media. One required media-type for each kind of media
							exists. Some media types are required for a specific purpose, which is
							then indicated as "required for ..."
						</item>
						<item>
							<emph role="strong">recommended</emph>: Other media types are
							recommended for a particular purpose. For any given purpose there
							should be only very few additionally recommended media types and the
							rationale, conditions and assumptions of such recommendations must be
							made very clear.
						</item>
						<item>
							<emph role="strong">indifferent</emph>: This status means, HL7
							neither forbids nor endorses the use of this media type. All media
							types not mentioned in <tabref ref="domain-mediaType"/> have status indifferent by default.
							Since there are one required and several recommended media types for most
							practically relevant use cases, media types of this status should be used
							very conservatively.
						</item>
						<item>
							<emph role="strong">deprecated</emph>: Deprecated media types
							SHOULD NOT be used, because these media types are flawed, because
							there are better alternatives, or because of certain risks. Such risks
							could be security risks, for example, the risk that such a media type
							could spread computer viruses. Not every flawed media type is marked
							as deprecated, though. A media type that is not mentioned in Table 6,
							and thus has status indifferent, may well be flawed.
						</item>
					</list>
					<table id="domain-MediaType">
						<caption>Concept Domain MediaType. ValueSet OID:  2.16.840.1.113883.11.14824. CodeSystem "MediaType", OID: 2.16.840.1.113883.5.79, Owner: IANA</caption>
						<thead>
							<tr valign="bottom">
								<th>code</th>
								<th>name</th>
								<th>status</th>
								<th>definition</th>
							</tr>
						</thead>
						<tbody>
							<tr valign="top">
								<td>text/plain </td>
								<td>Plain Text </td>
								<td>required </td>
								<td>For any plain text.  This is the default and is used for a character string (ST) data type. </td>
							</tr>
							<tr valign="top">
								<td>text/x-hl7-ft </td>
								<td>HL7 Text </td>
								<td>recommended </td>
								<td>For compatibility, this represents the HL7 v2.x FT data type.  Its use is recommended only for backward compatibility with HL7 v2.x systems. </td>
							</tr>
							<tr valign="top">
								<td>text/html </td>
								<td>HTML Text </td>
								<td>recommended </td>
								<td>For marked-up text according to the Hypertext Mark-up Language.  HTML markup is sufficient for typographically marking-up most written-text documents.  HTML is platform independent and widely deployed. </td>
							</tr>
							<tr valign="top">
								<td>application/pdf </td>
								<td>PDF </td>
								<td>recommended </td>
								<td>The Portable Document Format is recommended for written text that is completely laid out and read-only.  PDF is a platform independent, widely deployed, and open specification with freely available creation and rendering tools. </td>
							</tr>
							<tr valign="top">
								<td>text/xml </td>
								<td>XML Text </td>
								<td>indifferent </td>
								<td>For structured character based data.  There is a risk that general SGML/XML is too powerful to allow a sharing of general SGML/XML documents between different applications. </td>
							</tr>
							<tr valign="top">
								<td>text/x-hl7-text+xml </td>
								<td>HL7 Sturctured Narrative </td>
								<td>recommended </td>
								<td>The content described by the CDA Narrative Block (not just used by CDA). </td>
							</tr>
							<tr valign="top">
								<td>multipart/x-hl7-cda-level1 </td>
								<td>CDA Level 1 Multipart </td>
								<td>recommended </td>
								<td>The HL7 clinical document Architecture, Level 1 MIME package. </td>
							</tr>
							<tr valign="top">
								<td>text/rtf </td>
								<td>RTF Text </td>
								<td>indifferent </td>
								<td>The Rich Text Format is widely used to share word-processor documents.  However, RTF does have compatibility problems, as it is quite dependent on the word processor.  May be useful if word processor edit-able text should be shared. </td>
							</tr>
							<tr valign="top">
								<td>application/msword </td>
								<td>MSWORD </td>
								<td>deprecated </td>
								<td>This format is very prone to compatibility problems.  If sharing of edit-able text is required, text/plain, text/html or text/rtf should be used instead. </td>
							</tr>
							<tr valign="top">
								<td>audio/basic </td>
								<td>Basic Audio </td>
								<td>required </td>
								<td>This is a format for single channel audio, encoded using 8bit ISDN mu-law [PCM] at a sample rate of 8000 Hz.  This format is standardized by: CCITT, Fascicle III.4 -Recommendation G.711.  Pulse Code Modulation (PCM) of Voice Frequencies.  Geneva, 1972. </td>
							</tr>
							<tr valign="top">
								<td>audio/mpeg </td>
								<td>MPEG audio layer 3 </td>
								<td>required </td>
								<td>MPEG-1 Audio layer-3 is an audio compression algorithm and file format                       defined in ISO 11172-3 and ISO 13818-3. MP3 has an adjustable sampling frequency for highly compressed telephone to CD quality audio. </td>
							</tr>
							<tr valign="top">
								<td>audio/k32adpcm </td>
								<td>K32ADPCM Audio </td>
								<td>indifferent </td>
								<td>ADPCM allows compressing audio data.  It is defined in the Internet specification RFC 2421 [ftp://ftp.isi.edu/in-notes/rfc2421.txt].  Its implementation base is unclear. </td>
							</tr>
							<tr valign="top">
								<td>image/png </td>
								<td>PNG Image </td>
								<td>required </td>
								<td>Portable Network Graphics (PNG) [http://www.cdrom.com/pub/png] is a widely supported lossless image compression standard with open source code available. </td>
							</tr>
							<tr valign="top">
								<td>image/gif </td>
								<td>GIF Image </td>
								<td>indifferent </td>
								<td>GIF is a popular format that is universally well supported. However GIF is patent encumbered and should therefore be used with caution. </td>
							</tr>
							<tr valign="top">
								<td>image/jpeg </td>
								<td>JPEG Image </td>
								<td>required </td>
								<td>This format is required for high compression of high color photographs.  It is a "lossy" compression, but the difference to lossless compression is almost unnoticeable to the human vision. </td>
							</tr>
							<tr valign="top">
								<td>application/dicom </td>
								<td>DICOM </td>
								<td>recommended </td>
								<td>Digital Imaging and Communications in Medicine (DICOM) MIME type defined in RFC3240 [http://ietf.org/rfc/rfc3240.txt]. </td>
							</tr>
							<tr valign="top">
								<td>image/g3fax </td>
								<td>G3Fax Image </td>
								<td>recommended </td>
								<td>This is recommended only for fax applications. </td>
							</tr>
							<tr valign="top">
								<td>image/tiff </td>
								<td>TIFF Image </td>
								<td>indifferent </td>
								<td>Although TIFF (Tag Image File Format) is an international standard it has many interoperability problems in practice.  Too many different versions that are not handled by all software alike. </td>
							</tr>
							<tr valign="top">
								<td>video/mpeg </td>
								<td>MPEG Video </td>
								<td>required </td>
								<td>MPEG is an international standard, widely deployed, highly efficient for high color video; open source code exists; highly interoperable. </td>
							</tr>
							<tr valign="top">
								<td>video/x-avi </td>
								<td>X-AVI Video </td>
								<td>deprecated </td>
								<td>The AVI file format is just a wrapper for many different codecs; it is a source of many interoperability problems. </td>
							</tr>
							<tr valign="top">
								<td>model/vrml </td>
								<td>VRML Model </td>
								<td>recommended </td>
								<td>This is an openly standardized format for 3D models that can be useful for virtual reality applications such as anatomy or biochemical research (visualization of the steric structure of macromolecules) </td>
							</tr>
						</tbody>
					</table>
					<p>
						The set of required media types is very small so that no undue
						requirements are forced on HL7 applications, especially legacy
						systems. In general, no HL7 application is forced to support any given
						kind of media other than written text. For example, many systems just
						do not want to receive audio data, because those systems can only show
						written text to their users. It is a matter of application conformance
						statements to say: "I will not handle audio". Only if a system claims
						to handle audio media, then it must support the required media type for
						audio.
					</p>
				</div3>
				<div3 id="prop-ED.charset">
					<head>Charset (charset) : <termref ref="dt-CS">CS</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						An Internet Assigned Numbers Authority (IANA) Charset Registered character set 
						and character encoding for character-based media types.
					</p>
					<!-- EDNOTE the bibliography references are a problem if taken out
     of this document and copied into schemas etc the references
     are left dangling. Consider the citations in full in line.
     Perhaps should make a "cite" tag that contains all bibliographic
     data and can then be rendered either inline, with href or as
     a bibliography endnote reference. If we do bibrefs we need
     a bibliography post-processing step like bibTeX or refer(1).
 -->
					<p>
						The charset SHALL be
						identified by an Internet Assigned Numbers Authority (IANA) 
						Charset Registration [<loc href="http://www.iana.org/assignments/character-sets" xlink-form="simple" show="embed" actuate="auto"/>] 
						in accordance with RFC 2978 [<loc href="http://www.ietf.org/rfc/rfc2978.txt" xlink-form="simple" show="embed" actuate="auto"/>].
						The IANA source specifies names and multiple aliases for most character
						sets. For HL7's purposes, use of multiple alias names is not
						allowed. The standard name for HL7 is the one marked by IANA as
						"preferred for MIME."  If IANA has not marked one of the aliases as
						"preferred for MIME" the main name SHALL be the one used for HL7.
					</p>
					<p>
						<tabref ref="domain-Charset"/> lists a few of the IANA defined
						character sets that are of interest to current HL7 members.
<!--
						<hide>
							The definition of the "status" column is as given for <tabref
							ref="domain-mediaType"/>.
						</hide>
  -->
					</p>
					<table id="domain-Charset">
						<caption>Concept Domain Charset. ValueSet OID:  2.16.840.1.113883.11.14853. CodeSystem "CharSet", OID: 2.16.840.1.113883.5.21, Owner: IANA</caption>
						<thead>
							<tr valign="bottom">
								<th>lvl</th>
								<th>code</th>
								<th>name</th>
								<th>definition</th>
							</tr>
						</thead>
						<tr valign="top">
							<td>1</td>
							<td>EBCDIC</td>
							<td>EBCDIC</td>
							<td>
								<p>HL7 is indifferent to the use of this Charset.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>ISO-10646-UCS-2</td>
							<td>ISO-10646-UCS-2</td>
							<td>
								<p>Deprecated for HL7 use.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>ISO-10646-UCS-4</td>
							<td>ISO-10646-UCS-4</td>
							<td>
								<p>Deprecated for HL7 use.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>ISO-8859-1</td>
							<td>ISO-8859-1</td>
							<td>
								<p>HL7 is indifferent to the use of this Charset.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>ISO-8859-2</td>
							<td>ISO-8859-2</td>
							<td>
								<p>HL7 is indifferent to the use of this Charset.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>ISO-8859-5</td>
							<td>ISO-8859-5</td>
							<td>
								<p>HL7 is indifferent to the use of this Charset.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>JIS-2022-JP</td>
							<td>JIS-2022-JP</td>
							<td>
								<p>HL7 is indifferent to the use of this Charset.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>US-ASCII</td>
							<td>US-ASCII</td>
							<td>
								<p>Required for HL7 use.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>UTF-7</td>
							<td>UTF-7</td>
							<td>
								<p>HL7 is indifferent to the use of this Charset.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>UTF-8</td>
							<td>UTF-8</td>
							<td>
								<p>Required for Unicode support.</p>
							</td>
						</tr>
					</table>
					<note>
						<p>
							The above list is not complete let alone exclusive. In particular,
							international HL7 affiliates may make special recommendations about
							charsets to be used in their realm. These recommendations MAY add
							additional charsets and MAY reassign the recommendations status of a
							listed charset.
						</p>
					</note>
					<p>
						The charset property needs to be known where the data of <emph>ED</emph> is character type
						data in any form. If the data is provided in-line, then the charset SHALL be 
						clearly conveyed. If the data is provided as a reference, and the access method does not provide
						the charset for the data, typically as a mime header, then the charset SHALL be 
						conveyed as part of the <emph>ED</emph>. 
					</p>
					<p>
						Interested readers may also want to consult the "Character Model for
						the World Wide Web" [<loc href="http://www.w3.org/TR/charmod" xlink-form="simple" show="embed" actuate="auto"/>] for a more complete
						discussion of character set and related issues.
					</p>
				</div3>
				<div3 id="prop-ED.language">
					<head>Language (language) : <termref ref="dt-CS">CS</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						  The human language of the content.
					</p>
					<p role="defense">
						The need for a language code for text data values is documented in RFC
						2277, IETF Policy on Character Sets and Languages
						[<loc href="http://www.ietf.org/rfc/rfc2277.txt" xlink-form="simple" show="embed" actuate="auto"/>]. Further background
						information can be found in Using International Characters in Internet
						Mail [<loc href="http://www.imc.org/mail-i18n.html" xlink-form="simple" show="embed" actuate="auto"/>], a memo by the
						Internet Mail Consortium.
					</p>
					<p>
						The principles of the code domain of this attribute are specified by
						the Internet standard RFC 3066 [<loc href="http://www.ietf.org/rfc/rfc3066.txt" xlink-form="simple" show="embed" actuate="auto"/>].
						The RFC 3066 coding scheme is principally constructed from a primary subtag component 
						encoded using the language codes of ISO 639, with an optional second subtag component
						encoded using the two letter country codes of ISO 3166. Where this scheme does not 
						provide a suitable code, RFC 3066 allows for other codes, mostly as defined by ISO or 
						the Internet Assigned Names Authority [<loc href="http://www.iana.org/assignments/language-tags" xlink-form="simple" show="embed" actuate="auto"/>].<footnote>
							<p>
								RFC 3066 [<loc href="http://www.ietf.org/rfc/rfc3066.txt" xlink-form="simple" show="embed" actuate="auto"/>] is
								the HL7-approved coding system for all reference to human languages,
								in data types and elsewhere.
							</p>
						</footnote>
						This code domain is assigned the OID 2.16.840.1.113883.6.121.
					</p>
					<p>
						While Language tags usually alter the meaning of the text, the language does
						not alter the meaning of the characters in the text.<footnote>
							<p>
								For this reason, a system or site that does not deal with multilingual
								text or names in the real world MAY safely ignore the language
								property.
							</p>
						</footnote>
					</p>
					<note role="ITS">
						<p>
							Representation of language tags to text is highly dependent on the
							ITS. An ITS MAY use the native way of language tagging provided by
							its target implementation technology. Some may have language
							information in a separate component, e.g., XML has the xml:lang tag
							for strings. Others may rely on language tags as part of the binary
							character string representation, e.g., ISO 10646 (Unicode) and its
							"plane-14" language tags.
						</p>
					</note>
					<!-- FIXME: consider dropping this language tag once and for all -->
					<p>
						The language tag SHOULD NOT be mandatory if it is not mandatory in the
						implementation technology. Semantically, language tagging of strings
						follows a default-logic. In circumstances where a realm may support
						multiple langauges, it is up to the realm to define rules to handle
						language where none is specified when no language is specified. If no
						other rule is specified, the local language of the reader is assumed.
						If a language is set for an entire message or document, that language
						is the default. If any information element or value that is superior in
						the syntax hierarchy specifies a language, that language is the default
						for all subordinate text values.
					</p>
					<p>
						If language tags are present in the beginning of the encoded binary
						text (e.g., through Unicode's plane-14 tags) this is the source of the
						language property of the encapsulated data value.
					</p>
				</div3>
				<div3 id="prop-ED.compression">
					<head>Compression (compression) : <termref ref="dt-CS">CS</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						 The compression algorithm, if any, used on the raw byte data.
					</p>
					<table id="domain-CompressionAlgorithm">
						<caption>Concept Domain CompressionAlgorithm. ValueSet OID:  2.16.840.1.113883.11.10620. CodeSystem "CompressionAlgorithm", OID: 2.16.840.1.113883.5.1009, Owner: HL7</caption>
						<thead>
							<tr valign="bottom">
								<th>code</th>
								<th>name</th>
								<th>status</th>
								<th>definition</th>
							</tr>
						</thead>
						<tbody>
							<tr valign="top">
								<td>DF </td>
								<td> </td>
								<td>required </td>
								<td> </td>
							</tr>
							<tr valign="top">
								<td>GZ </td>
								<td> </td>
								<td>indifferent </td>
								<td> </td>
							</tr>
							<tr valign="top">
								<td>ZL </td>
								<td> </td>
								<td>indifferent </td>
								<td> </td>
							</tr>
							<tr valign="top">
								<td>Z </td>
								<td> </td>
								<td>deprecated </td>
								<td> </td>
							</tr>
							<tr valign="top">
								<td>BZ </td>
								<td> </td>
								<td>indifferent </td>
								<td> </td>
							</tr>
							<tr valign="top">
								<td>Z7 </td>
								<td> </td>
								<td>indifferent </td>
								<td> </td>
							</tr>
						</tbody>
					</table>
					<list role="unordered">
						<item>
							<emph role="strong">required</emph>: Every HL7 application
							SHALL support at least the required compression types.
						</item>
						<item>
							<emph role="strong">indifferent</emph>: This status means, HL7
							neither forbids nor endorses the use of this compression algorithm.
						</item>
						<item>
							<emph role="strong">deprecated</emph>: Deprecated compression algorithms
							SHOULD NOT be used, because they are flawed, because
							there are better alternatives, or because of certain risks.
						</item>
					</list>
					<p>
						The compression applies to the data applied in line, not to data provided by reference,
						even if there is no data provided in line. 
						Note that some compression formats allow multiple archive files to be embedded within
						a single compressed volume. Applications SHALL ensure that the decompressed form of
						the data conforms to the stated media type. The stated media type applies to the uncompressed data.
					</p>
				</div3>
				<div3 id="prop-ED.reference">
					<head>Reference (reference) : <termref ref="dt-TEL.URL">TEL.URL</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						A URL the target of which is taken as the binary content of the ED.
					</p>
					<p>
						A telecommunication address (<termref ref="dt-TEL">TEL</termref>) is a URL (i.e. for HTTP or FTP)
						which will resolve to precisely the same binary data that could as
						well have been provided as inline data.
						The semantic value of an encapsulated data value is the same,
						regardless whether the data is present inline data or just
						by-reference. However, an encapsulated data value without inline data
						behaves differently, since any attempt to examine the data requires
						the data to be downloaded from the reference. An encapsulated data
						value MAY have both inline data and a reference.
					</p>
					<p>
						If both reference and inline data are provided, the reference SHALL 
						point to data identical to that provided inline. It is an error if 
						the data resolved through the reference does not match either the 
						integrity check or the in-line data.
					</p>
					<p>
						The reference may contain a usablePeriod to indicate that the
						data may only be available for a limited period of time. Whether
						the reference is limited by a usablePeriod or not, the content of
						the reference SHALL be fixed for all time. Any application using the
						reference SHALL always receive the same data, or an error. The reference cannot
						be reused to send a different version of the same data, or different
						data.
					</p>
					<p>
						By-reference encapsulated data may not be allowed depending on the
						attribute or component that is declared encapsulated data.
						Values of type <termref ref="dt-ST">ST</termref> SHALL always be inline.
					</p>
				</div3>
				<div3 id="prop-ED.integrityCheck">
					<head>Integrity Check (integrityCheck) : <termref ref="dt-BIN">BIN</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						A checksum calculated over the binary data. 
					</p>
					<p>
						The integrity check is a short binary value representing a
						cryptographically strong checksum that is calculated over the binary
						data. The purpose of this property, when communicated with a reference
						is for anyone to validate later whether the reference still resolved
						to the same data that the reference resolved to when the encapsulated
						data value with reference was created. 
						It is an error if the data resolved through the reference does not match
						the integrity check.
					</p>
					<p>
						The integrity check is calculated according to the
						<termref ref="prop-ED.integrityCheckAlgorithm">integrityCheckAlgorithm</termref>. By default,
						the <emph>Secure Hash Algorithm-1</emph> (SHA-1) shall be used.
						The integrity check is binary encoded according to the rules of
						the integrity check algorithm.
					</p>
					<p>
						The integrity check is calculated over the raw binary data that is
						contained in the data component, or that is accessible through the
						reference. No transformations are made before the integrity check is
						calculated. If the data is compressed, the Integrity Check is
						calculated over the compressed data.
					</p>
				</div3>
				<div3 id="prop-ED.integrityCheckAlgorithm">
					<head>Integrity Check Algorithm (integrityCheckAlgorithm) : <termref ref="dt-CS">CS</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The algorithm used to compute the integrityCheck value. 
					</p>
					<p>
						The default	value is SHA-1.<footnote>
							<p>
								The cryptographically strong checksum algorithm Secure Hash
								Algorithm-1 (SHA-1) is currently the industry standard. It has
								superseded the MD5 algorithm only a couple of years ago, when certain
								flaws in the security of MD5 were discovered. Currently the SHA-1 hash
								algorithm is the default choice for the integrity check algorithm.
								Note that SHA-256 is also entering widespread usage.
							</p>
						</footnote>
					</p>
					<table id="domain-IntegrityCheckAlgorithm">
						<caption>Concept Domain IntegrityCheckAlgorithm. ValueSet OID:  2.16.840.1.113883.11.17385. CodeSystem "IntegrityCheckAlgorithm", OID: 2.16.840.1.113883.5.1010, Owner: HL7</caption>
						<thead>
							<tr valign="bottom">
								<th>lvl</th>
								<th>code</th>
								<th>name</th>
								<th>definition</th>
							</tr>
						</thead>
						<tr valign="top">
							<td>1</td>
							<td>SHA-1</td>
							<td>secure hash algorithm - 1</td>
							<td>
								<p>This algorithm is defined in FIPS PUB 180-1: Secure Hash Standard.  As of April 17, 1995.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>SHA-256</td>
							<td>secure hash algorithm - 256</td>
							<td>
								<p>This algorithm is defined in FIPS PUB 180-2: Secure Hash Standard.</p>
							</td>
						</tr>
					</table>
				</div3>
				<div3 id="prop-ED.description">
					<head>Description (description) : <termref ref="dt-ST">ST</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
 					    An alternative description of the media where the context is not suitable for rendering the media.
					</p>
					<p>
					    E.g. Short text description of an image or sound clip, etc.  
					    This attribute is not intended to be a complete substitute for the original.  
					    For complete substitutes, use the "translation" property.
						The intent of this property is allow compliance with disability requirements
						such as those expressed in American's with Disability Act (also known as "Section 508"),
						where there is a requirement to provide a short text description of included media in
						some form that can be read by a screen reader. This is similar to a very short thumbnail with mediaType = text/plain.
					</p>
				</div3>
				<div3 id="prop-ED.thumbnail">
					<head>Thumbnail (thumbnail) : <termref ref="dt-ED">ED</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						An abbreviated rendition of the full data.
					</p>
					<p>
						 A thumbnail requires
						significantly fewer resources than the full data, while still
						maintaining some distinctive similarity with the full data. A
						thumbnail is typically used with by-reference encapsulated data. It
						allows a user to select data more efficiently before actually
						downloading through the reference.
						Originally, the term thumbnail refers to an image in a lower
						resolution (or smaller size) than another image. However, the
						thumbnail concept can be metaphorically used for media types other
						than images. For example, a movie may be represented by a shorter
						clip; an audio-clip may be represented by another audio-clip that is
						shorter, has a lower sampling rate, or a lossy compression; or an abstract
						provided for a long document.
					</p>
					<p>
							Thumbnails may not be allowed depending on the attribute or component
							that is declared encapsulated data. Values of type <termref ref="dt-ST">ST</termref>
							SHALL NOT have thumbnails, and a thumbnail itself SHALL NOT
							contain a thumbnail.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(ED x)
      where x.thumbnail.nonNull {
   x.thumbnail.thumbnail.isNull;
};</pre>
					</exhibit>
					<note role="ITS">
						<p>
							ITS's SHOULD consider the case where the thumbnail and the original
							both have the same properties of type, charset and compression. In
							this case, these properties need not be represented explicitly for the
							thumbnail but might be "inherited" from the main encapsulated data
							value to its thumbnail.
						</p>
					</note>
				</div3>
				<div3 id="prop-ED.translation">
					<head>Translation (translation) : <termref ref="dt-DSET">DSET</termref>&lt;<termref ref="dt-ED">ED</termref>&gt;</head>
					<p>
						<emph role="strong">Definition:     </emph>
						Alternate renditions of the same content translated into a different language or a different
						mediaType. The translation property is a set of <emph>ED</emph> that each translate the first rendition
						into a different language or use a different mediaType. Each element of the translation set SHALL
						be a translation of the <emph>ED</emph> value. Translations SHALL NOT contain translations.
					</p>
					<p>
						The translations SHALL convey the same information, but in a different language or mediaType.
						The translations do not take part in the test for equality, so SHALL NOT introduce any new semantics
						to the value.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(ED x)
      where x.nonNull {
   forall(ED t) where x.translation.contains(t) {
     t.description.isNull;
	 t.language.equals(x.language).not.or(t.mediaType.equals(x.mediaType).not);
	 t.translation.isEmpty;
   }
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-ED.length">
					<head>Length (length) : <termref ref="dt-INT">INT</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The length of the content in the <emph>ED</emph>.
					</p>
					<p>
							  The length of the <emph>ED</emph> may not be the same as the length of the binary
							  content of the <emph>ED</emph> in the <termref ref="dt-ED.data">data</termref> property. The
							  length is the number of items in the content where the kind of item is determined
							  by the <termref ref="dt-ED.mediaType">mediaType</termref>. For instance, if the mediatype is a type
							  of text, then the length of the <emph>ED</emph> is the number of characters found in
							  the binary content, as specified by the <termref ref="dt-ED.charset">charset</termref>. For
							  application, video, audio and image mediatypes, the length is the same as the length of the
							  binary content.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(ED x, INT y)
      where x.nonNull.and(y.isZero) {
   x.length.greaterThan(y);
};</pre>
					</exhibit>
					<p>
							nonNull <emph>ED</emph> SHALL always have some content, and <emph>length</emph> is greater than 0. 
						</p>
				</div3>
				<div3 id="prop-ED.subPart">
					<head>SubPart (subPart) : <termref ref="dt-ED">ED</termref>
					</head>
					<argument name="start" type="INT"/>
					<argument name="end" type="INT"/>
					<p>
						<emph role="strong">Definition:     </emph>
						A contiguous sublist of the <emph>ED</emph> containing the content found from index start to end, inclusively.
					</p>
					<p>
							As with length, the subPart of an ED may be different to a subList of the 
							<termref ref="dt-ED.data">data</termref>. The offsets are determined based on the logical
							contents as determined by the <termref ref="dt-ED.mediaType">mediaType</termref>. For 
							application, video, audio and image mediatypes, the offsets are the same 
							as the offsets in the binary content. The content 
							must then the re-rendered into some binary representation.
						</p>
					<p>
							The <termref ref="dt-ED.mediaType">mediaType</termref> and the <termref ref="dt-ED.charset">charset</termref> of 
							the return value are usually of the same type as the <emph>ED</emph>, but this may not
							always be the case.  
						</p>
					<p>
							If the internal content has some structure which makes the specified range inappropriate,
							the return value MAY be NULL.
						</p>
				</div3>
				<div3 id="prop-ED.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<p>
						Two nonNull values of type <emph>ED</emph> are equal if and only if their mediaType
						and data are equal. For those <emph>ED</emph> values
						with compressed data or referenced data, only the de-referenced and
 						uncompressed data counts for the equality test. The compression, thumbnail, translation
						and reference property themselves are excluded from the equality test.
						In addition the language property is excluded from the test, due to the
						problems this would introduce values of type <emph>ED</emph> where the language is not
						specified. If the <termref ref="prop-ED.mediaType">mediaType</termref> is character based and the charset property
						is not equal, the charset property must be resolved through mapping of the
						data between the different character sets.<footnote>
							<p>
								This means that values of the type ED and BIN may never be equal. ED, may, however,
								be equal with ST, SC, UID, OID, UUID, and RUID values.
							</p>
						</footnote>
					</p>
				</div3>
			</div2>
			<div2 id="dt-ST">
				<anchor id="ST"/>
				<head>CharacterString (ST) specializes <termref ref="dt-ED">ED</termref>
				</head>
				<p>
					<emph role="strong">Definition:     </emph>
					Text data, primarily
					intended for machine processing (e.g., sorting, querying, indexing, presentation,
					etc.). 
				</p>
				<p>
					<termref ref="dt-ST">ST</termref> is primarily used for names, symbols, and formal expressions.
					<termref ref="dt-ST">ST</termref> is a restricted <termref ref="dt-ED">ED</termref>,
					whose <termref ref="prop-ED.mediaType">ED.mediaType</termref> property is fixed to <emph>text/plain</emph>,
					and whose data SHALL be inlined and not compressed. Thus, the properties compression, reference,
					integrity check, algorithm, and thumbnail are not applicable. The character
					string data type is used when the visual presentation of text does not affect its meaning,
					which is true for formalized text and all kinds of names.
				</p>
				<table id="dt-ST-prop-summary">
					<caption>Property Summary of
      CharacterString</caption>
					<col width="79"/>
					<col width="60"/>
					<col width="413"/>
					<thead>
						<tr>
							<th>Name</th>
							<th>Type</th>
							<th>Description</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>
								<termref ref="prop-ST.data">data</termref>
							</td>
							<td>
								<termref ref="dt-BIN">BIN</termref>
							</td>
							<td>
						The sequence of characters that make up the content of the string.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-ST.mediaType">mediaType</termref>
							</td>
							<td>
								<termref ref="dt-CS">CS</termref>
							</td>
							<td>
						Identifies the type of the <emph>ST</emph> and identifies a
						method to interpret or render the data. The fixed mediaType
						is text/plain.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-ST.charset">charset</termref>
							</td>
							<td>
								<termref ref="dt-CS">CS</termref>
							</td>
							<td>
						An Internet Assigned Numbers Authority (IANA) Charset Registered character set 
						and character encoding for character-based media types.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-ST.language">language</termref>
							</td>
							<td>
								<termref ref="dt-CS">CS</termref>
							</td>
							<td>
						  The human language of the content.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-ST.headCharacter">headCharacter</termref>
							</td>
							<td>
								<termref ref="dt-ST.NT">ST.NT</termref>
							</td>
							<td/>
						</tr>
						<tr>
							<td>
								<termref ref="prop-ST.tailString">tailString</termref>
							</td>
							<td>
								<termref ref="dt-ST.NT">ST.NT</termref>
							</td>
							<td/>
						</tr>
						<tr>
							<td>
								<termref ref="prop-ST.translation">translation</termref>
							</td>
							<td>
								<termref ref="dt-DSET">DSET</termref>&lt;<termref ref="dt-ST.NT">ST.NT</termref>&gt;</td>
							<td>
						Alternate renditions of the same content translated into a different
						language. The translation property is a set of ST.NT that each translate
						the first rendition into a different language. Each element of the
						translation set SHALL be a translation of the ST value. Translations
						SHALL NOT contain translations.
					</td>
						</tr>
					</tbody>
				</table>
				<p>
					<emph>ST</emph> data type interprets the encapsulated data
					as character data (as opposed to bits), depending on the charset
					property of the encapsulated data type.
				</p>
				<exhibit role="dtdl" id="dtdl-ST">
					<anchor id="dtdl-ST"/>
					<caption/>
					<pre>
type CharacterString alias ST specializes ED {
   ST.NT     headCharacter;
   ST.NT     tailString;
   DSET&lt;ST.NT&gt; translation;
   literal  ST.SIMPLE;
};</pre>
				</exhibit>
				<note role="ITS">
					<p>
						Because many of the properties of the encapsulated data are bound to a
						default value, an ITS need not represent these properties at all. In
						fact, if the character encoding is also fixed, the ITS only represents
						the encoded character data and language.
					</p>
				</note>
				<p>
					The headCharacter and tailString properties define <emph>ST</emph> as a sequence
					of entities each of which uniquely identifies one character from the
					joint set of all characters known by any language of the world.<footnote>
						<p>
							ISO/IEC 10646-1: 1993 defines a character as "A member of a set of
							elements used for the organization, control, or representation of
							data."  ISO/IEC TR 15285 - An operational model for characters and
							glyphs. Discusses the problems involved in defining
							characters. Notably, characters are abstract entities of information,
							independent of type font or language. The ISO 10646 (UNICODE
							[http://www.unicode.org]) - or in Japan, JIS X0221 - is a globally
							applicable character set that uniquely identifies all characters of
							any language in the world.
						</p>
						<p>
							In this specification, ISO 10646 serves as a semantic model for
							character strings. The important point is that for semantic purposes,
							there is no notion of separate character sets and switching between
							character sets. Character set and character encoding are ITS layer
							considerations. The formal definition gives indication to this effect
							because each character is by itself an <emph>ST</emph> value that
							has a charset property. Thus, the binary encoding of each character is
							always understood in the context of a certain character set. This does
							not mean that the ITS should represent a character string as a
							sequence of full blown <termref ref="dt-ED">ED</termref> values. What it means is that
							on the application layer the notion of character encoding is
							irrelevant when we deal with character strings.
						</p>
					</footnote>
				</p>
				<p>
					The head of an <emph>ST</emph> is a string of only one character. An <emph>ST</emph>
					SHALL have at least one character or else be NULL. A
					zero-length <emph>ST</emph> is an exceptional value (NULL), not a proper
					value.
				</p>
				<exhibit role="dtdl">
					<caption/>
					<pre>
invariant(ST x)
      where x.nonNull {
   x.headCharacter.notEmpty;
   x.headCharacter.length.equal(1);
   x.headCharacter.tailString.isEmpty;
   x.tailString.isEmpty.implies(x.length.equal(1));
   x.tailString.notEmpty.implies(x.length.equal(x.tailString.length.successor));
};</pre>
				</exhibit>
				<p>
					The length of an <emph>ST</emph> is the number of characters, not the number of
					encoded bytes, in the string. Byte encoding is an ITS issue and is not relevant on
					the application layer.
				</p>
				<p>
					The following rules apply to whitespace contained within values of type <emph>ST</emph>:
				</p>
				<list role="unordered">
					<item>
						TAB, space and end-of-line are all considered whitespace characters.
					</item>
					<item>
						Both preceding and trailing whitespace is significant.
					</item>
					<item>
						Different whitespace characters are not interchangable.
					</item>
					<item>
						Different representations of end-of-line are normalised according to the
						method described in the XML specification, regardless of ITS
						[<loc href="http://www.w3.org/TR/2000/REC-xml-20001006#sec-line-ends" xlink-form="simple" show="embed" actuate="auto">Section 2.11 End-of-Line Handling</loc>]
					</item>
					<item>
						Sequences of whitespace cannot be compressed to shorter sequences.
					</item>
				</list>
				<exhibit role="requirement">
					<emph role="strong">Requirement</emph>
					<p>
						<emph>ST</emph> is a specialization of <termref ref="dt-ED">ED</termref> so that any RIM attribute which has the type
						<termref ref="dt-ED">ED</termref> can be constrained to a <emph>ST</emph>. The most important case is Act.text, which is
						an <termref ref="dt-ED">ED</termref> to cater for the use of references and multimedia data, but is often
						constrained to plain text.
					</p>
				</exhibit>
				<div3 id="prop-ST.data">
					<head>Binary Data (data) : <termref ref="dt-BIN">BIN</termref>, inherited from <termref ref="dt-ED">ED</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The sequence of characters that make up the content of the string.
					</p>
					<p>
						The data is constrained to be a valid sequence of characters represented in the chosen character set.
						It SHALL be contained in-line - the <termref ref="prop-ED.reference">ED.reference</termref> property cannot be used. 
					</p>
				</div3>
				<div3 id="prop-ST.mediaType">
					<head>Media Type (mediaType) : <termref ref="dt-CS">CS</termref>, inherited from <termref ref="dt-ED">ED</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						Identifies the type of the <emph>ST</emph> and identifies a
						method to interpret or render the data. The fixed mediaType
						is text/plain.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(ST x)
      where x.nonNull {
   x.mediaType.code.equal("text/plain");
};</pre>
					</exhibit>
					<p>
						Fixed to be "text/plain".
					</p>
				</div3>
				<div3 id="prop-ST.charset">
					<head>Charset (charset) : <termref ref="dt-CS">CS</termref>, inherited from <termref ref="dt-ED">ED</termref>
					</head>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(ST x)
      where x.nonNull {
   x.charset.nonNull;
};</pre>
					</exhibit>
					<p>
						Values of type <emph>ST</emph> SHALL have a known charset. 
					</p>
				</div3>
				<div3 id="prop-ST.language">
					<head>Language (language) : <termref ref="dt-CS">CS</termref>, inherited from <termref ref="dt-ED">ED</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						  The human language of the content.
					</p>
					<p role="defense">
						The need for a language code for text data values is documented in RFC
						2277, IETF Policy on Character Sets and Languages
						[<loc href="http://www.ietf.org/rfc/rfc2277.txt" xlink-form="simple" show="embed" actuate="auto"/>]. Further background
						information can be found in Using International Characters in Internet
						Mail [<loc href="http://www.imc.org/mail-i18n.html" xlink-form="simple" show="embed" actuate="auto"/>], a memo by the
						Internet Mail Consortium.
					</p>
					<p>
						The principles of the code domain of this attribute are specified by
						the Internet standard RFC 3066 [<loc href="http://www.ietf.org/rfc/rfc3066.txt" xlink-form="simple" show="embed" actuate="auto"/>].
						The RFC 3066 coding scheme is principally constructed from a primary subtag component 
						encoded using the language codes of ISO 639, with an optional second subtag component
						encoded using the two letter country codes of ISO 3166. Where this scheme does not 
						provide a suitable code, RFC 3066 allows for other codes, mostly as defined by ISO or 
						the Internet Assigned Names Authority [<loc href="http://www.iana.org/assignments/language-tags" xlink-form="simple" show="embed" actuate="auto"/>].<footnote>
							<p>
								RFC 3066 [<loc href="http://www.ietf.org/rfc/rfc3066.txt" xlink-form="simple" show="embed" actuate="auto"/>] is
								the HL7-approved coding system for all reference to human languages,
								in data types and elsewhere.
							</p>
						</footnote>
						This code domain is assigned the OID 2.16.840.1.113883.6.121.
					</p>
					<p>
						While Language tags usually alter the meaning of the text, the language does
						not alter the meaning of the characters in the text.<footnote>
							<p>
								For this reason, a system or site that does not deal with multilingual
								text or names in the real world MAY safely ignore the language
								property.
							</p>
						</footnote>
					</p>
					<note role="ITS">
						<p>
							Representation of language tags to text is highly dependent on the
							ITS. An ITS MAY use the native way of language tagging provided by
							its target implementation technology. Some may have language
							information in a separate component, e.g., XML has the xml:lang tag
							for strings. Others may rely on language tags as part of the binary
							character string representation, e.g., ISO 10646 (Unicode) and its
							"plane-14" language tags.
						</p>
					</note>
					<p>
						The language tag SHOULD NOT be mandatory if it is not mandatory in the
						implementation technology. Semantically, language tagging of strings
						follows a default-logic. In circumstances where a realm may support
						multiple langauges, it is up to the realm to define rules to handle
						language where none is specified when no language is specified. If no
						other rule is specified, the local language of the reader is assumed.
						If a language is set for an entire message or document, that language
						is the default. If any information element or value that is superior in
						the syntax hierarchy specifies a language, that language is the default
						for all subordinate text values.
					</p>
					<p>
						If language tags are present in the beginning of the encoded binary
						text (e.g., through Unicode's plane-14 tags) this is the source of the
						language property of the encapsulated data value.
					</p>
				</div3>
				<div3 id="prop-ST.compression">
					<head>Compression (compression) : <termref ref="dt-CS">CS</termref>, (fixed)</head>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(ST x)
      where x.nonNull {
   x.compression.notApplicable;
};</pre>
					</exhibit>
					<p>
						Values of type <emph>ST</emph> SHALL NOT be compressed.
					</p>
				</div3>
				<div3 id="prop-ST.reference">
					<head>Reference (reference) : <termref ref="dt-TEL.URL">TEL.URL</termref>, (fixed)</head>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(ST x)
      where x.nonNull {
   x.reference.notApplicable;
};</pre>
					</exhibit>
					<p>
						Values of type <emph>ST</emph> SHALL NOT reference content from some other location.
					</p>
				</div3>
				<div3 id="prop-ST.integrityCheck">
					<head>Integrity Check (integrityCheck) : <termref ref="dt-BIN">BIN</termref>, (fixed)</head>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(ST x)
      where x.nonNull {
   x.integrityCheck.notApplicable;
};</pre>
					</exhibit>
					<p>
						Integrity check code SHALL NOT be used with values of type <emph>ST</emph>.
					</p>
				</div3>
				<div3 id="prop-ST.integrityCheckAlgorithm">
					<head>Integrity Check Algorithm (integrityCheckAlgorithm) : <termref ref="dt-CS">CS</termref>, (fixed)</head>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(ST x)
      where x.nonNull {
   x.integrityCheckAlgorithm.notApplicable;
};</pre>
					</exhibit>
					<p>
						Integrity check algorithm SHALL NOT be used with values of type <emph>ST</emph>.
					</p>
				</div3>
				<div3 id="prop-ST.thumbnail">
					<head>Thumbnail (thumbnail) : <termref ref="dt-ED">ED</termref>, (fixed)</head>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(ST x)
      where x.nonNull {
   x.thumbnail.notApplicable;
};</pre>
					</exhibit>
					<p>
						Values of type <emph>ST</emph> SHALL NOT have thumbnails.
					</p>
				</div3>
				<prop id="prop-ST.headCharacter" longname="HeadCharacter" shortname="headCharacter" type="ST.NT" render="false"/>
				<prop id="prop-ST.tailString" longname="TailString" shortname="tailString" type="ST.NT" render="false"/>
				<div3 id="prop-ST.translation">
					<head>Translation (translation) : <termref ref="dt-DSET">DSET</termref>&lt;<termref ref="dt-ST.NT">ST.NT</termref>&gt;, inherited from <termref ref="dt-ED">ED</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						Alternate renditions of the same content translated into a different
						language. The translation property is a set of ST.NT that each translate
						the first rendition into a different language. Each element of the
						translation set SHALL be a translation of the ST value. Translations
						SHALL NOT contain translations.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(ST x)
      where x.nonNull {
   x.translation.dataType.implies(DSET&lt;ST&gt;);
};</pre>
					</exhibit>
					<p>
						All translations SHALL also be <emph>ST</emph>. Since the translations 
						are not allowed to have translations, they are also <termref ref="dt-ST.NT">ST.NT</termref>.
					</p>
				</div3>
				<div3 id="prop-ST.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<argument name="x" type="ED"/>
					<p>
						The evaluation of equality for <emph>ST</emph> is the same as the <termref ref="dt-ED">ED</termref> data type.<footnote>
							<p>
								This means that values of the type ED and ST may be equal.
							</p>
						</footnote>
					</p>
				</div3>
				<div3 id="prop-ST.literal">
					<head>Literal Form</head>
					<p>
						Two variations of <emph>ST</emph> literals are defined, a token form
						and a quoted string.<footnote>
							<p>
								An <emph>ST</emph> literal is a conversion from a character string to
								another data type. Obviously, <emph>ST</emph> literals for character
								strings is a cyclical if not redundant feature. This literal form,
								therefore, mainly specifies how character strings are parsed in the
								data type specification language.
							</p>
						</footnote>
						The token form consists only of the lower case and upper case Latin
						alphabet, the ten decimal digits and the underscore. The quoted string
						can contain any character between double-quotes. The double quotes
						prevent a character string from being interpreted as some other
						literal. The token form allows keywords and names to be parsed from
						the data type specification language.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
ST.literal ST.SIMPLE {
   ST : /"[^]+"/         { $.equal($1); }  /* quoted string */
      | /[a-zA-Z0-9_]+/  { $.equal($1); }; /* token form */
};</pre>
					</exhibit>
					<note role="ITS">
						<p>
							Since <emph>ST</emph> literals are so fundamental to implementation
							technology, most ITS will specify some modified character string
							literal form. However, ITS designers must be aware of the interaction
							between the <emph>ST</emph> literal form and the literal forms
							defined for other data types. This is particularly critical if the
							other data type's literal form is structured with major components
							separated by break-characters (e.g., real number, physical quantity,
							set, and list literals, etc.).
						</p>
					</note>
				</div3>
			</div2>
			<div2 id="dt-SC">
				<anchor id="SC"/>
				<head>CharacterStringWithCode (SC) specializes <termref ref="dt-ST">ST</termref>
				</head>
				<p>
					<emph role="strong">Definition:     </emph>
					A character string that optionally may have a code attached.
				</p>
				<p>
					The text SHALL always be present if a code is present.  The code is often a
					local code.
				</p>
				<table id="dt-SC-prop-summary">
					<caption>Property Summary of
      CharacterStringWithCode</caption>
					<col width="79"/>
					<col width="60"/>
					<col width="413"/>
					<thead>
						<tr>
							<th>Name</th>
							<th>Type</th>
							<th>Description</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>
								<termref ref="prop-SC.code">code</termref>
							</td>
							<td>
								<termref ref="dt-CV">CV</termref>
							</td>
							<td>
						A code representing the string data. For example, the string data may
						be a user-message out of a message-catalog where the code represents
						the identifier of the message in the message catalog.
					</td>
						</tr>
					</tbody>
				</table>
				<exhibit role="dtdl" id="dtdl-SC">
					<anchor id="dtdl-SC"/>
					<caption/>
					<pre>
type CharacterStringWithCode alias SC specializes ST {
   CV code;
   
  promotion  SC (ST x);
   
};</pre>
				</exhibit>
				<p>
					<emph>SC</emph> is used in cases where coding is exceptional (e.g.,
					user text messages are essentially text messages, and a printable
					message is the important content. Yet sometimes messages come from a
					catalog of canned messages, which <emph>SC</emph> allows to reference.
				</p>
				<p>
						Any non-null <emph>SC</emph> value MAY have a code, however, a code SHALL NOT be
						given without the text.
					</p>
				<exhibit role="dtdl">
					<caption/>
					<pre>
invariant(SC x)
      where x.nonNull {
   x.code.nonNull.implies(x.notEmpty);
};</pre>
				</exhibit>
				<p>
						The original text of the code, if provided, is the content of the string.<footnote>
						<p>Implementations will generally not have duplication between the content of the SC and the originalText of the code property.</p>
					</footnote>
				</p>
				<exhibit role="dtdl">
					<caption/>
					<pre>
invariant(SC x)
      where x.nonNull {
   x.code.nonNull.implies(x.code.originalText.equals(x));
};</pre>
				</exhibit>
				<div3 id="prop-SC.code">
					<head>Code (code) : <termref ref="dt-CV">CV</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						A code representing the string data. For example, the string data may
						be a user-message out of a message-catalog where the code represents
						the identifier of the message in the message catalog.
					</p>
				</div3>
				<div3 id="prop-SC.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<argument name="x" type="ED"/>
					<p>
						The evaluation of equality for <emph>SC</emph> is the same as the <termref ref="dt-ED">ED</termref> data type.
						The code property is not included in the equality test.<footnote>
							<p>
								This means that values of the type SC, ED and ST may be equal.
							</p>
						</footnote>
					</p>
				</div3>
			</div2>
			<graphic source="graphics/dtUML-Concepts.png" alt="The Concept Descriptor information model."/>
			<div2 id="dt-CD">
				<anchor id="CD"/>
				<head>ConceptDescriptor (CD) specializes <termref ref="dt-ANY">ANY</termref>
				</head>
				<p>
					<emph role="strong">Definition:     </emph>
					A reference to a concept defined in a code system
				</p>
				<conformanceProperty name="ConceptDomain" type="ST" definition="The concept domain from which proper values must be drawn"/>
				<p>
					A <emph>CD</emph> may contain a simple code - that is, a reference to a
					concept defined directly by the referenced code system, or it may
					contain an expression in some syntax defined by the referenced
					code system that can be meaningfully evaluated. e.g., the
					concept of a "left foot" as a postcoordinated term built from the
					primary code "FOOT" and the qualifier "LEFT".
				</p>
				<p>
					A <emph>CD</emph> may also contain an original text or phrase that
					served as the basis of the coding. This is preserved to allow for validation of the representation
					of the concept in various fashions. 
				</p>
				<p>
					A <emph>CD</emph> can contain one or more translations into multiple coding systems.
					The translations are all representations of the same concept in various
					code systems (note that there may be more than on representation in a single 
					code system where code systems allow multiple representations, such as Snomed-CT). 
					There is only one concept, and only the first <emph>CD</emph> may
					contain an original text. It is possible to represent the translation
					chain - which <emph>CD</emph> was translated from which - if desired, using 
					the source attribute. Each <emph>CD</emph> may also carry a rationale to indicate why it is represented.
				</p>
				<p>
					A non-exceptional <emph>CD</emph> value SHALL have a non-NULL <termref ref="prop-CD.code">code</termref> or
					<termref ref="prop-CD.originalText">originalText</termref> property. Conversely, a
					<emph>CD</emph> value without a value for both the <termref ref="prop-CD.code">code</termref> and <termref ref="prop-CD.originalText">originalText</termref> properties,
					or with a value that is not from the specified coding system is an exceptional
					value (NULL of flavor <emph>other</emph>). If the concept (the intent of the
					original text) cannot be properly represented within the set of codes to which 
					the attribute is constrained (the value set), then the nullFlavor of
					the <emph>CD</emph> should be set to "OTH" (other) and either a reference
					to a code system or a value set (which may refer to multiple code
					systems) SHALL be provided.
				</p>
				<p>
				   Note that sending a <emph>CD</emph> with a nullFlavor of <emph>other</emph> and a 
				   code system says that no appropriate code could be found in the entire code
				   system. If this statement can only be made about a a subset of the code system,
				   or about multiple code systems, then a value set should be used instead.     
				</p>
				<exhibit role="dtdl">
					<caption/>
					<pre>
invariant(CD x)
      where x.nonNull {
   x.code.nonNull.or(x.originalText.nonNull);
};</pre>
				</exhibit>
				<p>
					Attributes with type <emph>CD</emph> are generally bound to a domain that is used to constrain
					the coded concepts to which a <emph>CD</emph> may refer. Domains are bound to value sets that 
					define the codes and code systems that may be used in the <emph>CD</emph>. The binding process is discussed
					in depth in the "Core Principles of V3 Models" specification under "Vocabulary Binding" 
					([<loc href="../coreprinciples/v3modelcoreprinciples.htm#coreP_V3_Conformance-Vocabulary-Binding" xlink-form="simple" show="embed" actuate="auto"/>]). 
					Domains are bound with a qualifier that specifies with the
					domains are extensible or not. If a domain is not extensible (CNE), then 
					a non-exceptional root <emph>CD</emph> SHALL contain a code that exists in the domain with
					which the attribute is associated<footnote>
						<p>
					 	There is no formal definition for this extra constraint as there is no machinery
					 	for the formal language to refer to externally specified constraints.
					</p>
					</footnote>. If a domain is extensible (CWE) then 
					a non-exceptional <emph>CD</emph> SHALL contain a code that exists in the domain with
					which the attribute is associated, a code from a locally defined code system,
					or some originalText that describes the concept. If the code is taken from a 
					locally defined code system, then the <termref ref="prop-CD.codeSystem">codeSystem</termref>
					property SHALL specify the local code system.
				</p>
				<p>
					For both CNE and CWE domain bindings, the translations may contain <emph>CD</emph> values 
					with nullFlavors from any domain unless otherwise specified by the constraining model. 
				</p>
				<table id="dt-CD-prop-summary">
					<caption>Property Summary of
      ConceptDescriptor</caption>
					<col width="79"/>
					<col width="60"/>
					<col width="413"/>
					<thead>
						<tr>
							<th>Name</th>
							<th>Type</th>
							<th>Description</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>
								<termref ref="prop-CD.code">code</termref>
							</td>
							<td>
								<termref ref="dt-ST.SIMPLE">ST.SIMPLE</termref>
							</td>
							<td>
						The plain code symbol defined by the code system, or an expression in a syntax
						defined by the code system which describes the concept.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-CD.codeSystem">codeSystem</termref>
							</td>
							<td>
								<termref ref="dt-UID">UID</termref>
							</td>
							<td>
						The code system that defines the code.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-CD.codeSystemName">codeSystemName</termref>
							</td>
							<td>
								<termref ref="dt-ST.NT">ST.NT</termref>
							</td>
							<td>
						The common name of the coding system.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-CD.codeSystemVersion">codeSystemVersion</termref>
							</td>
							<td>
								<termref ref="dt-ST.SIMPLE">ST.SIMPLE</termref>
							</td>
							<td>
						If applicable, a version descriptor defined specifically for the given
						code system.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-CD.valueSet">valueSet</termref>
							</td>
							<td>
								<termref ref="dt-UID">UID</termref>
							</td>
							<td>
						 The value set that applied when this <emph>CD</emph> was created.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-CD.valueSetVersion">valueSetVersion</termref>
							</td>
							<td>
								<termref ref="dt-ST.SIMPLE">ST.SIMPLE</termref>
							</td>
							<td>
						 The version of the value set that applied when this <emph>CD</emph> was created.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-CD.displayName">displayName</termref>
							</td>
							<td>
								<termref ref="dt-ST">ST</termref>
							</td>
							<td>
					    A name, title, or representation for the code or expression as it exists in the code system identified by
						the value of <termref ref="prop-CD.codeSystem">codeSystem</termref>. 
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-CD.originalText">originalText</termref>
							</td>
							<td>
								<termref ref="dt-ED.TEXT">ED.TEXT</termref>
							</td>
							<td>
					    The text as seen and/or selected by the user who entered the data which represents the intended meaning of the user. 
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-CD.codingRationale">codingRationale</termref>
							</td>
							<td>
								<termref ref="dt-SET">SET</termref>&lt;<termref ref="dt-CS">CS</termref>&gt;</td>
							<td>
					     The reason a particular <emph>CD</emph> has been provided.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-CD.translation">translation</termref>
							</td>
							<td>
								<termref ref="dt-DSET">DSET</termref>&lt;<termref ref="dt-CD">CD</termref>&gt;</td>
							<td>
					    A set of other CDs that each represent a translation of this CD into equivalent codes within
						the same code system or into corresponding concepts from other code systems.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-CD.source">source</termref>
							</td>
							<td>
								<termref ref="dt-CD">CD</termref>
							</td>
							<td>
					    The <emph>CD</emph> from which this <emph>CD</emph> was translated, if it was
						translated from another <emph>CD</emph>.
					</td>
						</tr>
					</tbody>
				</table>
				<exhibit role="dtdl" id="dtdl-CD">
					<anchor id="dtdl-CD"/>
					<caption/>
					<pre>
type ConceptDescriptor alias CD specializes ANY {
    ST.SIMPLE       code;
    UID             codeSystem;
    ST.NT           codeSystemName;
    ST.SIMPLE       codeSystemVersion;
    UID             valueSet;
    ST.SIMPLE       valueSetVersion;
    ST              displayName;
    ED.TEXT         originalText;
    SET&lt;CS&gt;         codingRationale;
    DSET&lt;CD&gt;        translation;
    CD              source;
    BL              implies(CD x);
};</pre>
				</exhibit>
				<div3 id="prop-CD.code">
					<head>Code (code) : <termref ref="dt-ST.SIMPLE">ST.SIMPLE</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The plain code symbol defined by the code system, or an expression in a syntax
						defined by the code system which describes the concept.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(CD x)
      where x.nonNull {
   x.code.nonNull.or(x.originalText.nonNull);
};</pre>
					</exhibit>
					<p>
						If the <emph>CD</emph> is a proper value (non-null), then it SHALL contain either a code or an originalText.
						If the <emph>CD</emph> is bound to a domain or value set with a CNE constraint, then a code from the bound
						domain or value set SHALL be used.
					</p>
					<p>
					  If provided, the code SHALL be an exact match to a plain code symbol or expression defined by the <termref ref="prop-CD.codeSystem">codeSystem</termref>.
					  If the code system defines a code or expression that includes whitespace, the <emph>code</emph> SHALL
					  include the whitespace.
					</p>
					<p>
						An expression can only be used where the codeSystem either defines an 
						expression syntax, or there is a generally accepted syntax for the codeSystem.
						A code system may be defined that only defines a syntax and binding to other 
						code Systems.
					</p>
					<note>
						<p>
							In HL7 defined vocabulary codeSystems, a Mnemonic is defined for all 
							codes. These are the correct values for use in the code
							property. HL7 does not define any expression syntaxes for HL7 defined
							vocabulary codeSystems.
						</p>
					</note>
					<p>
						It is at the discretion of the interpreting system whether to check for an
						expression instead of a simple code and evaluate the expression instead of 
						treating the expression as a code. In some cases, it may be unclear whether
						the code represents a single symbol or an expression. This usually arises where
						the code system defines an expression language and then defines pre-coordinated
						concepts with symbols which match their expression, e.g. UCUM. In other cases,
						it is safe to treat the expression as a symbol. There is no guarantee that this
						is always safe: the definitions of the codeSystem should always be consulted to
						determine how to handle potential expressions. 
					</p>
					<p>
						Where the requirements for handling expressions and post-coordinated concepts
						are deemed unreasonable and/or impractical for a particular application, the
						valueset and/or codeSystems assigned to the <emph>CD</emph> in the applicable design
						models should be used to prohibit them to the degree desired.<footnote>
							<p>
							In Release 1 of the data types, expressions were handled in qualifiers, and
							there were specific data types (CE) that prohibited some use of expressions. The
							problem with this was that there were mismatches between the choice of data type
							and the value set. In particular, there are cases where a single concept may be 
							represented by a mix of valuesets both allowing and prohibiting expressions, and
							using the data type to constrain expressions was not possible.  
						</p>
						</footnote>
					</p>
				</div3>
				<div3 id="prop-CD.codeSystem">
					<head>Code System (codeSystem) : <termref ref="dt-UID">UID</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The code system that defines the code.
					</p>
					<p>
						Code systems SHALL be referred to by a <termref ref="dt-UID">UID</termref>, which allows unambiguous
						reference to standard HL7 codes, other standard code systems, as well as local
						codes. Where HL7 has assigned an identifier to a code system, this identifier
						SHALL be used. Otherwise implementations SHALL use an appropriate ISO Object Identifier
						(<termref ref="dt-OID">OID</termref>) or <termref ref="dt-UUID">UUID</termref> to construct a globally unique local coding
						system identifier.
					</p>
					<p>
						A CD that has a code attribute SHALL have a codeSystem specifying the system of concepts that defines the code.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(CD x)
      where x.code.nonNull {
   x.codeSystem.nonNull;
};</pre>
					</exhibit>
					<p>
						An exceptional <emph>CD</emph> of NULL-flavor <emph>other</emph> indicates that
						a concept could not be coded in the coding system or value set specified. Thus, for
						these coding exceptions, the code system or value set that did not contain the
						appropriate concept SHALL be provided in <emph>codeSystem</emph> or <termref ref="prop-CD.valueSet">valueSet</termref>.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(CD x)
      where x.other {
   x.code.other;
   x.codeSystem.nonNull.or(x.valueSet.nonNull);
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-CD.codeSystemName">
					<head>Code System Name (codeSystemName) : <termref ref="dt-ST.NT">ST.NT</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The common name of the coding system.
					</p>
					<p>
						The code system name has no computational value. The purpose of a code
						system name is to assist an unaided human interpreter of a code value to
						interpret <termref ref="prop-CD.codeSystem">codeSystem</termref>.
						It is suggested &#8212; though
						not absolutely required &#8212; that ITS provide for <emph>codeSystemName</emph> in
						order to annotate the <termref ref="dt-UID">UID</termref> for human comprehension.
					</p>
					<p>
						HL7 systems SHALL NOT functionally rely on <emph>codeSystemName</emph>. <emph>codeSystemName</emph> can
						never modify the meaning of <termref ref="prop-CD.codeSystem">codeSystem</termref> and
						cannot exist without <termref ref="prop-CD.codeSystem">codeSystem</termref>. Conformant
						systems MAY choose not to implement <emph>codeSystemName</emph> but SHALL NOT reject
						instances because <emph>codeSystemName</emph> is present.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(CD x) {
   x.codeSystemName.nonNull.implies(x.codeSystem.nonNull);
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-CD.codeSystemVersion">
					<head>Code System Version (codeSystemVersion) : <termref ref="dt-ST.SIMPLE">ST.SIMPLE</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						If applicable, a version descriptor defined specifically for the given
						code system.
					</p>
					<p>
								Note that by definition a code symbol SHALL have the same meaning throughout all
								versions of a code system. Between versions, codes may be retired but not withdrawn
								or reused. Where the definition of the meaning of a code symbol changes, it must
								still be compatible (equal) between different code system versions.
							</p>
					<p>
						HL7 will specify how these version strings are formed for each
						external code system. If HL7 has not specified how version strings are
						formed for a particular coding system, version designations have no
						defined meaning for such coding system. HL7 will publish the applicable
						version when internal HL7 code systems are published.
					</p>
					<p>
						Different versions of one code system must be compatible. Whenever a
						code system changes in an incompatible way, it will constitute a new
						code system, not simply a different version, regardless of how the
						vocabulary publisher calls it.
					</p>
					<p>
						For example, the publisher of ICD-9 and ICD-10 calls these code
						systems, "revision 9" and "revision 10" respectively. However, ICD-10
						is a complete redesign of the ICD code, not a backward compatible
						version. Therefore, for the purpose of this data type specification,
						ICD-9 and ICD-10 are different code systems, not just different
						versions. By contrast, when LOINC updates from revision "1.0j" to
						"1.0k", HL7 would consider this to be just another version of LOINC,
						since LOINC revisions are backwards compatible.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(CD x) {
   x.codeSystemVersion.nonNull.implies(x.codeSystem.nonNull);
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-CD.valueSet">
					<head>Value Set (valueSet) : <termref ref="dt-UID">UID</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						 The value set that applied when this <emph>CD</emph> was created.
					</p>
					<p>
						In many cases, a <emph>CD</emph> is created from a value set - either a code/code system 
						pair is chosen from a valueSet, or one is not chosen and the <emph>CD</emph> has the 
						exceptional value of <emph>NullFlavor.OTH</emph>. If no code is chosen, it is 
						generally inappropriate to reference the code system from which the code was 
						chosen as the value set may not match the code system (may include a subset of
						the codeSystem, or additional terms from other code systems); instead, the value 
						set should be provided. In addition, there are some known use cases where the 
						value set that a user or system was offered when choosing a code affects the 
						interpretation of the code.
					</p>
					<p>
						Note that if a code is provided, the meaning of the code must come from the
						definition of the code in the code system. The meaning of the code SHALL NOT 
						depend on the value set. Applications SHALL NOT be required to interpret 
						the code in light of the valueSet. Applications SHALL NOT reject an instance 
						because of the presence or absence of any or a particular value set. 
					</p>
					<p>
						Value sets SHALL be referred to by a <termref ref="dt-UID">UID</termref>, which allows unambiguous 
						reference to standard HL7 value sets, and other value sets. Where HL7 has assigned an 
						identifier to a value set, this identifier SHALL be used. Otherwise implementations 
						SHALL use an appropriate ISO Object Identifier (<termref ref="dt-OID">OID</termref>) or 
						<termref ref="dt-UUID">UUID</termref> to construct a globally unique local value set identifier.
					</p>
					<p>
						When ever a value set is provided, the version of the value set SHALL also be 
						provided.
					</p>
				</div3>
				<div3 id="prop-CD.valueSetVersion">
					<head>Value Set Version (valueSetVersion) : <termref ref="dt-ST.SIMPLE">ST.SIMPLE</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						 The version of the value set that applied when this <emph>CD</emph> was created.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(CD x)
      where x.valueSet.nonNull {
   x.valueSetVersion.nonNull;
};</pre>
					</exhibit>
					<p>
						<emph>valueSetVersion</emph> SHALL be provided when a valueSet is provided, and otherwise SHALL be null. 
						The value of the <emph>valueSetVersion</emph> must properly identify a particular version of the value 
						set following the rules defined by the value set or its publisher. For HL7 defined
						value sets, the version SHALL be the date/time that the value set was published.
						For further information,
						see in the "Core Principles of V3 Models" specification under "Value Set Versioning" ([<loc href="../coreprinciples/v3modelcoreprinciples.htm" xlink-form="simple" show="embed" actuate="auto"/>])
					</p>
				</div3>
				<div3 id="prop-CD.displayName">
					<head>Display Name (displayName) : <termref ref="dt-ST">ST</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
					    A name, title, or representation for the code or expression as it exists in the code system identified by
						the value of <termref ref="prop-CD.codeSystem">codeSystem</termref>. 
					</p>
					<p>
						Normally, the <emph>displayName</emph> would be the human
						readable representation of the concept that the sending system shows to its users. The displayName
						is included so that an unaided human interpreter of a code value has a human readable
						description of what the concept meant within the code system at the time of data entry.
					</p>
					<p>
						If populated, <emph>displayName</emph> SHALL be a valid human readable representation of the
						concept as defined by the code system at the time of data entry. The <emph>displayName</emph> SHALL conform to any rules
						defined by the codingSystem; if the codeSystem does not define a human representation for the code or
						expression, then none can be provided.
						<emph>displayName</emph> is included both as a courtesy to an unaided human
						interpreter of a code value and as a documentation of the name used to
						display the concept to the user. The display name has no functional
						meaning; it SHALL never exist without a code; and it SHALL never
						modify the meaning of <termref ref="prop-CD.code">code</termref>. A display name may
						not be present if the code is an expression for which no
						display name has been assigned or can be derived. Conformant
						systems MAY choose not to implement <emph>displayName</emph> but SHALL NOT reject
						instances because <emph>displayName</emph> is present.
					</p>
					<note>
						<p>
							HL7 offers a "print name" in its predefined vocabulary domains. These
							values are suitable for use in the displayName.
						</p>
					</note>
					<note>
						<p>
							Display names may not alter the meaning of the code value. Therefore,
							display names SHOULD NOT be presented to the user on a receiving
							application system without ascertaining that the display name
							adequately represents the concept referred to by the code
							value. Communication SHALL NOT simply rely on the display name. The
							display name's main purpose is to support debugging of HL7 protocol
							data units (e.g., messages).
						</p>
					</note>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(CD x) {
   x.displayName.nonNull.implies(x.code.nonNull);
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-CD.originalText">
					<head>Original Text (originalText) : <termref ref="dt-ED.TEXT">ED.TEXT</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
					    The text as seen and/or selected by the user who entered the data which represents the intended meaning of the user. 
					</p>
					<p>
						Original text can be used in a structured user
						interface to capture what the user saw as a representation of the code or expression on the data input screen, or in a situation
						where the user dictates or directly enters text, it is the text entered or uttered by the user. It is a common exceptional case to use
						the CD data type to store only the text that the user entered or uttered. In this situation, original text will
						exist without a code, and the nullFlavor OTH will apply. In a situation where the code is assigned sometime after the text was entered, originalText
						is the text or phrase used as the basis for assigning the code.
					</p>
					<p>
						The original text exists in a scenario where an originator of the
						information does not assign a code, but where the code is assigned
						later by a coder (post-coding).  In the production of a concept
						descriptor, original text may thus exist without a code.
					</p>
					<p>
							Note that although post-coding is often performed from free text information,
							such as documents, scanned images or dictation, multi-media data is
							explicitly not permitted as original text. Also, the original text
							property is not meant to be a link into the entire source
							document. The link between different artifacts of medical information
							(e.g., document and coded result) is outside the scope of this
							specification and is maintained elsewhere in the HL7 standards. The
							original text SHALL be an excerpt of the relevant information in the
							original sources, rather than a pointer or exact reproduction. Thus
							the original text SHALL be represented in plain text form. In specific
							circumstances, as described in other HL7 specifications, the originalText
							may be a reference to some other text artefact for which the resolution
							scope is clearly described.
						</p>
					<p>
						Values of type <emph>CD</emph> MAY have a non-NULL original text
						property despite having a NULL <termref ref="prop-CD.code">code</termref>. Any <emph>CD</emph> value
						with <termref ref="prop-CD.code">code</termref> of NULL signifies a coding exception. In this case,
						<emph>originalText</emph> is a name or description of the concept that was
						not coded. Such exceptional <emph>CD</emph> values MAY also contain <termref ref="prop-CD.translation">translation</termref>s.
						Such translations directly encode the concept described in <emph>originalText</emph>.
					</p>
					<p>
						The originalText represents the originalText of the concept itself. Translations
						SHALL NOT have an originalText of their own.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(CD x) {
  forall(CD translation) where x.translation.contains(translation) {
         translation.originalText.isNull;
         };
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-CD.codingRationale">
					<head>Coding Rationale (codingRationale) : <termref ref="dt-SET">SET</termref>&lt;<termref ref="dt-CS">CS</termref>&gt;</head>
					<p>
						<emph role="strong">Definition:     </emph>
					     The reason a particular <emph>CD</emph> has been provided.
					</p>
					<table id="domain-CodingRationale">
						<caption>Concept Domain CodingRationale. ValueSet OID:  2.16.840.1.113883.11.19250. CodeSystem "CodingRationale", OID: 2.16.840.1.113883.5.1074, Owner: HL7</caption>
						<thead>
							<tr valign="bottom">
								<th>lvl</th>
								<th>code</th>
								<th>name</th>
								<th>definition</th>
							</tr>
						</thead>
						<tr valign="top">
							<td>1</td>
							<td>O</td>
							<td>Original</td>
							<td>
								<p>Originally produced code</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>P</td>
							<td>Post-coded</td>
							<td>
								<p>Post-coded from free text source</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>R</td>
							<td>Required</td>
							<td>
								<p>Required standard code for HL7</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>OR</td>
							<td>Original &amp; Required</td>
							<td>
								<p>Originally produced code, required by HL7</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>PR</td>
							<td>Post-coded &amp; Required</td>
							<td>
								<p>Post-coded from free text source, required by HL7</p>
							</td>
						</tr>
					</table>
					<p>
						The values O and P are mutually exclusive &#8211; only one of these two values SHALL be part 
						of codingRationale at any given time.  A code is deemed to be post-coded if the user 
						does not assign a code when they first enter the data (i.e. when coding occurs 
						subsequently using the <termref ref="prop-CD.originalText">originalText</termref>). codingRationale is 
						not expected to act as a quality review marker on the quality of the coding or the 
						translation processes.
					</p>
					<p>
						A code is required when it is present in the instance to meet some constraints imposed 
						on the instance by the context of use. Applications SHALL not be required to mark a 
						particular translation as required even though it is required by the context of use, 
						but MAY do so. Applications SHALL not reject instances because of the presence or 
						absence of any particular codingRationale flag.					
					</p>
				</div3>
				<div3 id="prop-CD.translation">
					<head>Translation (translation) : <termref ref="dt-DSET">DSET</termref>&lt;<termref ref="dt-CD">CD</termref>&gt;</head>
					<p>
						<emph role="strong">Definition:     </emph>
					    A set of other CDs that each represent a translation of this CD into equivalent codes within
						the same code system or into corresponding concepts from other code systems.
					</p>
					<note>
						<p>
							The translations are quasi-synonyms of one real-world concept. Every
							translation in the set is supposed to express the same meaning "in
							other words."  However, exact synonymy rarely exists between two
							structurally different coding systems. For this reason, not all of the
							translations will be equally exact.
						</p>
					</note>
					<p>
						Translations SHALL NOT contain translations. The root <emph>CD</emph> has one set of translations
						which lists all the translations.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(CD x) {
  forall(CD t) where x.translation.contains(t) {
         t.translation.isEmpty;
         };
};</pre>
					</exhibit>
					<p>
						The root translation is generally the one that best meets the conformance criteria for the
						<emph>CD</emph>. No implication about lineage of the translations can be drawn from the selection
						of the root code. Instead the properties <termref ref="prop-CD.codingRationale">codingRationale</termref> and 
						<termref ref="prop-CD.source">source</termref> is used to trace lineage.
					</p>
					<p>
						In the absence of a constraining model that makes constraints on the value domain of
						the <emph>CD</emph>, any of the translations MAY be the root <emph>CD</emph>. If the constraining
						model makes constraints on the value domain of the <emph>CD</emph> and there is a translation
						that meets the constraints, that translation SHOULD be the root <emph>CD</emph>. If the
						constraining model makes constraints on the value domain of the <emph>CD</emph> and there is 
						no translation that meets the constraints, then any of the translations MAY be the root,
						as long as they are assigned a nullFlavor. An alternative is to put none of the translations
						in the root, and give it a nullFlavor of choice, and put all the translations in the translation
						property of the root.
					</p>
					<note role="Implementer">
						<p>
					 		There are a number of open issues about the full details of the interactions between
					 		constraining models and translations. These will be clarified in a future version of this 
					 		specification.  
					 	</p>
					</note>
				</div3>
				<div3 id="prop-CD.source">
					<head>Source (source) : <termref ref="dt-CD">CD</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
					    The <emph>CD</emph> from which this <emph>CD</emph> was translated, if it was
						translated from another <emph>CD</emph>.
					</p>
					<p>
						A <emph>CD</emph> consists of a single root code and a set of translations, which do not
						have translations. Using the <termref ref="prop-CD.codingRationale">codingRationale</termref> property, a
						sender can indicate which is the original code. There are some circumstances
						in which it is useful to know which <emph>CD</emph> was translation from which <emph>CD</emph>.
						The <emph>source</emph> allows for the translation sequence from one translation to another
						to be represented.
					</p>
					<p>
						Each element of the translation set was translated from the
						original <emph>CD</emph>. Each translation may, however, also have
						translations. Thus, when a code is translated multiple times the
						information about which code served as the input to which translation
						will be preserved.
					</p>
					<p>
						The source SHALL also be contained within the same <emph>CD</emph> cluster (a <emph>CD</emph> and its translations).
					</p>
					<note role="ITS">
						<p>
							Since the source must be found independently as the root code, or in
							the list of translations, some sort of referential implementation is
							appropriate for the source property in ITSs.
							</p>
					</note>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(CD x) where x.nonNull.and(x.source.nonNull) {
  x.translation.contains(x.source).or(x.source.translation.contains(x));
};
</pre>
					</exhibit>
				</div3>
				<!--  to be removed once R2 passes ballot. I have been informed that there is a risk that qualifiers will come back......
				
				<prop id="prop-CD.qualifier" type="LIST&lt;CR&gt;" shortname="qualifier" longname="Qualifier">
					<definition>
						Specifies additional codes that increase the specificity of the the
						primary code.
					</definition>
					<p>
						The primary code and all the qualifiers together, including groups of qualifiers, make up one
						concept. A <dtname/> with qualifiers is also called a
						<emph>code phrase</emph> or <emph>postcoordinated expression</emph>.
					</p>
					<p>
						Qualifiers constrain the meaning of the primary code, but cannot negate
						it or change its meaning to that of another value in the primary coding
						system.
					</p>
					<p>
						Qualifiers can only be used according to well-defined rules of
						post-coordination. A value of type <dtname/> may only have qualifiers if its
						code system defines the use of such qualifiers or if there is a third
						code system that specifies how other code systems may be combined.
					</p>
					<p>
						For example, SNOMED CT allows constructing concepts as a combination
						of multiple codes. SNOMED CT defines a concept "cellulitis (disorder)"
						(128045006) an attribute "finding site" (363698007) and another
						concept "foot structure (body structure)" (56459004). SNOMED CT allows
						one to combine these codes in a code phrase:
					</p>
					<example><![CDATA[
<observation>
   ...
   <value code="128045006" codeSystem="&amp;SNOMED-CT;" displayName="cellulitis (disorder)">
      <qualifier code="56459004" displayName="foot structure">
         <name code="363698007" displayName="finding site"/>
      </qualifier>
   </value>
   ...
</observation>]]></example>
					<p>
						The next two pairs of examples are provided courtesy of David Markwell, and are
						based on SNOMED CT Core Edition 2007-01-31.
					</p>
					<p>
						This first pair of examples shows grouping and nesting (see example 1.2).
						Strictly speaking (in normal form) a "fracture of left tibia" is not
						a "left fracture" of a "tibia bone" but is a "fracture" of the "left"
						"tibia bone" (that is the qualification of "left" applies to the bone
						not to the fracture). Also note in this example that the fracture and
						bone are grouped - this may look irrelevant but is potentially significant
						for combined fractures where different morphology may apply to different
						bones. It may be recommended for general clinical communications to
						use the close-to-user form which has no nesting (see example 1.1 below).
						Example 1.2 is the normal form that results when transformations
						are applied to Example 1.1.
					</p>
					<example><![CDATA[
<!-!- example 1.1: Close-to-user form of "fracture of left tibia". -!->
<!-!- scgExpression: 31978002|fracture of tibia|: 272741003|laterality|=7771000|left| -!->
<code codeSystem="2.16.840.1.113883.6.96" code="31978002" displayName="fracture of tibia">
  <qualifier>
    <name code="272741003" displayName="laterality" /> 
    <value code="7771000" displayName="left" /> 
  </qualifier>
</code>]]></example>
					<example><![CDATA[
<!-!- example 1.2: Normal form representation of "fracture of left tibia". Automatically generated
    by CliniClue from close-to-user form 1.1 following published SNOMED Transformation rules. -!->
<!-!- scgExpression: 64572001|disease|:{116676008|associated morphology|=72704001|fracture|,
    363698007|finding site|=(12611008|bone structure of tibia|:272741003|laterality|=7771000|left|)} -!->
<code codeSystem="2.16.840.1.113883.6.96" code="64572001" displayName="disease">
  <group>
    <qualifier>
      <name code="116676008" displayName="associated morphology" /> 
      <value code="72704001" displayName="fracture" /> 
    </qualifier>
    <qualifier>
      <name code="363698007" displayName="finding site" /> 
      <value code="12611008" displayName="bone structure of tibia">
        <qualifier>
          <name code="272741003" displayName="laterality" /> 
          <value code="7771000" displayName="left" /> 
        </qualifier>
      </value>
    </qualifier>
  </group>
</code>]]></example>
					<p>
						This second example pair shows grouping and nesting even in close-to-user form. The SNOMED
						CT expression for "past history of fracture of left tibia" includes nesting even in
						close-to-user form because the laterality does not apply to the past history but rather to
						the disorder (see example 2.1). In the normal form the nesting gets a little deeper
						(see example 2.2).
					</p>
					<example><![CDATA[
<!-!- example 2.1: Close-to-user form of "past history of fracture of left tibia". -!->
<!-!- scgExpression: 417662000|past history of clinical finding|:246090004|associated 
     finding|=(31978002|fracture of tibia|: 272741003|laterality|=7771000|left|) -!->
<code codeSystem="2.16.840.1.113883.6.96" code="417662000" displayName="past history of clinical finding">
  <qualifier>
    <name code="246090004" displayName="associated finding" /> 
    <value code="31978002" displayName="fracture of tibia">
      <qualifier>
        <name code="272741003" displayName="laterality" /> 
        <value code="7771000" displayName="left" /> 
      </qualifier>
    </value>
  </qualifier>
</code>]]></example>
					<example><![CDATA[
<!-!- example 2.2: Normal form representation of "past history of fracture of
   left tibia". Automatically generated by CliniClue from close-to-user form
   2.1 following published SNOMED Transformation rules -!->
<!-!- scgExpression: 243796009|situation with explicit context|:246090004|associated
     finding|= (64572001|disease|:{116676008|associated morphology|=72704001|fracture|,
	 363698007|finding site|=(12611008|bone structure of tibia|:272741003|laterality|=7771000|left|)}),
	 408729009|finding context|=410515003|known present|,408731000|temporal context|=410513005|past|,
	 408732007|subject relationship context|=410604004|subject of record| -!->
<code codeSystem="2.16.840.1.113883.6.96" code="243796009" displayName="situation with explicit context">
  <qualifier> 
    <name code="246090004" displayName="associated finding" /> 
    <value code="64572001" displayName="disease">
      <group>
        <qualifier>
          <name code="116676008" displayName="associated morphology" /> 
          <value code="72704001" displayName="fracture" /> 
        </qualifier>
        <qualifier>
           <name code="363698007" displayName="finding site" /> 
           <value code="12611008" displayName="bone structure of tibia">
             <qualifier>
               <name code="272741003" displayName="laterality" /> 
               <value code="7771000" displayName="left" /> 
             </qualifier>
           </value>
        </qualifier>
      </group>
    </value>
  </qualifier>
  <qualifier>
    <name code="408729009" displayName="finding context" /> 
    <value code="410515003" displayName="known present" /> 
  </qualifier>
  <qualifier>
    <name code="408731000" displayName="temporal context" /> 
    <value code="410513005" displayName="past" /> 
  </qualifier>
  <qualifier>
    <name code="408732007" displayName="subject relationship context" /> 
    <value code="410604004" displayName="subject of record" /> 
  </qualifier>
</code>]]></example>
					<p>
						It is important to note that the allowable qualifiers are specified by
						the code system. For instance, in SNOMED CT, there is a defined set of
						qualifying attributes, and only Findings and Disorders can be
						qualified with the "finding site" attribute. Use of qualifiers outside
						the boundaries specified by the code system is a non-conformant use of
						the <dtname/> data type. Adherence to the rules specified by the code system
						enables post-coordinated expressions to be compared with
						pre-coordinated concepts (such as where one might compare the above
						code phrase to the pre-coordinated concept "cellulitis of foot
						(disorder)" (128276007), which is defined within SNOMED CT as having a
						finding site of foot structure).   <dtname/> does not provide
						for normalization of compositional expressions, therefore it is
						possible to create ambiguous expressions.  Users should understand
						that they must provide the additional constraints necessary to assure
						unambiguous data representation, if they are planning to create
						compositional expressions using <dtname/>.  Otherwise, they risk
						the inability to retrieve a complete set of all records corresponding
						to any given query.
					</p>
					<p>
						Another common example is the U.S. Centers for Medicare and Medicaid
						Services (CMS) (previously known as the Health Care Financing
						Administration, HCFA) procedure codes. CMS procedure codes (HCPCS) are
						based on CPT-4 and add additional qualifiers to it. For example, the
						patient with above finding (plus peripheral arterial disease, diabetes
						mellitus, and a chronic skin lesion at the left great toe) may have an
						amputation of that toe. The CPT-4 concept is "Amputation, toe
						metatarsophalangeal joint" (28820) and a HCPCS qualifier needs to be
						added to indicate "left foot, great toe" (TA). Thus we code:
					</p>
					<example><![CDATA[
<procedure>
   ...
   <cd code="28820" codeSystem="&amp;CP4;" displayName="Amputation, toe metatarsophalangeal joint">
      <qualifier code="TA" codeSystem="&amp;HCP;" displayName="left foot, great toe"/>
   </cd>
   ...
</procedure>]]></example>
					<p>
						In this example, the code system of the qualifier (HCPCS) is different
						than the code system of the primary code (CPT-4). It is only because
						there are well-defined rules that define how these codes can be
						combined, that the qualifier may be used. Note also, that the role
						name is optional, and for HCPCS codes there are no distinguished role
						names.
					</p>
					<p>
						The order of qualifiers is preserved, particularly for the case where
						the coding system allows post-coordination but defines no role
						names. (e.g., some ICD-9CM codes, or the old SNOMED "multiaxial"
						coding).
					</p>
				</prop>
				<prop id="prop-CD.group" type="LIST&lt;LIST&lt;CR&gt;&gt;" shortname="group" longname="Qualifier Group" >
					<definition>
						A group of logically related qualifiers.
					</definition>
					<p>
						The logical grouping of qualifiers must be defined by the coding system of the CD containing the concept qualifier. For
						example some post-coordinated expressions in SNOMED CT group qualifiers to add clarity to concepts with multiple name/value
						pairs, such as:
					</p>
					<list role="unordered">
						<item>
							<p>Cholecystectomy and exploration of bile duct</p>
							<list role="unordered">
								<item>
									<p>Group</p>
									<list role="unordered">
										<item><p>Method = Exploration</p></item>
										<item><p>Procedure site = Bile duct structure</p></item>
									</list>
								</item>
							</list>
							<list role="unordered">
								<item>
									<p>Group</p>
									<list role="unordered">
										<item><p>Method = Excision</p></item>
										<item><p>Procedure site = Gall bladder structure</p></item>
									</list>
								</item>
							</list>
						</item>
					</list>
					<p>
						The group property is an extension of the qualifier system to allow
						for logical group of qualifiers. All of the rules and meanings associated
						with qualifiers are equally applicable to qualifiers in groups.
					</p>
				</prop>-->
				<!-- 				<prop id="prop-CD.isCompositional" type="BL" shortname="isCompositional" longname="Is Compositional">
					<definition>
						An indicator that the code refers directly to more than one concept in the codingSystem.
					</definition>
					<p>
						This property is defined to assist in conformance statements regarding the use of 
						post-coordination and other forms of terminology expressions. Note that the value set machinery
						can also be used to constrain the use of these expressions. In some code systems, it may be 
						ambiguous whether a particular code/expression refers directly
						to more than one concept in the codeSystem, as the codeSystem may not define concepts
						in terms that map directly to this language. In such cases, isCompositional will return
						a null flavor (NI), and so care must be taken when using this property.
					</p>
					<p>
						If the code system is Snomed-CT, then the code is always an expression. The expression is 
						compositional if more than one concept identifier is contained in the expression. A Ucum
						expression is compositional if the combination of terms is not listed directly in the Ucum
						specification.
					</p>
					<note role="ITS">
						<p>
							This is a derived property - it SHOULD NOT normally be carried in an instance
							when used for interoperability between systems.
							<footnote>
								<p>
									If this property is carried between systems, then instead of the receiving system
									carrying the cost of determining whether an expression is compositional when it
									needs to know, the sending system will have to carry that cost for all codes, on
									the chance that the receiver will want to know. Note that the systems may not
									actually care whether the code carries an expression or not.
								</p>
							</footnote>
						</p>
					</note>
				</prop> -->
				<div3 id="prop-CD.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<p>
						The main use of concept descriptors is for the purpose of indexing,
						querying and decision-making based on a coded value. A semantically
						unambiguous specification of coded values therefore requires a clear
						definition of what equality of concept descriptor values means and how
						<emph>CD</emph> values should be compared.<footnote>
							<p> (For more details on
						comparing pre- and post-coordinated SNOMED expressions, see Dolin RH,
						Spackman KA, Markwell D. Selective Retrieval of Pre- and
						Post-coordinated SNOMED Concepts. Fall AMIA 2002; 210-14, or the July
						2007 SNOMED CT Implementation Guide, or see SNOMED CT Transformations to
						Normal Forms at http://www.ihtsdo.org/our-standards/technical-documents/).
							</p>
						</footnote>
					</p>
					<p>
						The equality of two <emph>CD</emph> values is determined solely
						based upon <termref ref="prop-CD.code">code</termref> and <termref ref="prop-CD.codeSystem">codeSystem</termref>.
						<termref ref="prop-CD.codeSystemVersion">codeSystemVersion</termref> is
						excluded from the equality test.<footnote>
							<p>
								<termref ref="prop-CD.codeSystemVersion">codeSystemVersion</termref> does not count in the equality test since by
								definition a code symbol must have the same meaning throughout all
								versions of a code system. Between versions, codes may be retired but
								not withdrawn or reused.
							</p>
						</footnote>
						Translations are not included in the equality test.<footnote>
							<p>
								Translations are not included in the equality test of concept
								descriptors for safety reasons. An alternative would have been to
								consider two <emph>CD</emph> values equal if any of their
								translations are equal. However, some translations may be equal
								because the coding system of that translation is very
								coarse-grained. More sophisticated comparisons between concept
								descriptors are application considerations that are not covered by
								this specification.
							</p>
						</footnote>
						Exceptional <emph>CD</emph> values are not equal even if they have
						the same NULL-flavor or the same original text.<footnote>
							<p>
								NULL-values are exceptional values, not proper concepts. It would be unsafe to
								equate two values merely on the basis that both are exceptional (e.g., not
								codable or unknown).  Likewise there is no guarantee that original text
								represents a meaningful or unique description of the concept so that equality
								of that original text does not constitute concept equality. The reverse is
								also true: since there is more than one possible original text for a concept,
								the fact that original text differs does not constitute a difference of the
								concepts.
							</p>
						</footnote>
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(CD x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.code.equal(y.code)
             .and(x.codeSystem.equal(y.codingSystem)));
};</pre>
					</exhibit>
					<p>
						Some code systems define certain style options to their code
						values or expression syntaxes. For example, the U.S. National Drug Code (NDC) has a dash and
						a non-dash form. An example for the dash form may be 1234-5678-90 when
						the non-dash form is 01234567890. Another example for this problem is
						when certain ISO or ANSI code tables define optional alphanumeric and
						numeric forms of two or three character lengths all in one standard.
					</p>
					<p>
						In the case where code systems provide for multiple representations,
						HL7 wil make a ruling about which is the preferred form. HL7 will
						document that ruling where that respective external coding system is
						recognized. HL7 will decide upon the preferred form based on criteria
						of practicality and common use. In absence of clear criteria of
						practicality and common use, the safest, most extensible, and least
						stylized (the least decorated) form shall be given
						preference.<footnote>
							<p>
								This ruling at design-time is necessary to prevent HL7 interfaces from
								being burdened by code literal style conversions at runtime. This is
								notwithstanding the fact that some applications may require mapping
								from one form into another if that application has settled with the
								representation option that was not chosen by HL7.
							</p>
						</footnote>
					</p>
				</div3>
				<div3 id="prop-CD.implies">
					<head>Implies (implies) : <termref ref="dt-BL">BL</termref>
					</head>
					<argument name="x" type="CD"/>
					<p>
						<emph role="strong">Definition:     </emph>
						Specifies whether this <emph>CD</emph> is a specialization of
						the operand <emph>CD</emph>.
					</p>
					<p>
						Naturally, concepts can be narrowed and widened to include or exclude
						other concepts. Many coding systems have an explicit notion of concept
						specialization and generalization. The HL7 vocabulary principles also
						provide for concept specialization for HL7 defined value sets.
						<emph>implies</emph> is a predicate that compares whether one
						concept is a specialization of another concept, and therefore implies
						that other concept.
					</p>
					<p>
						When writing predicates (e.g., conditional statements) that compare
						two codes, one SHOULD usually test for implication not equality of
						codes.
					</p>
					<p>
						For example, in <tabref ref="domain-TelecommunicationAddressUse"/> the
						"telecommunication use" concepts: work (W), home (H), primary home
						(HP), and vacation home (HV) are defined, where both HP and HV imply
						H. When selecting any home phone number, one should test whether the
						given use-code <emph>c</emph> <emph>implies</emph> H. Testing for
						<emph>c</emph> <emph>equal</emph> H would only find unspecified home
						phone numbers, but not the primary home phone number.
<!-- fixme: why are &nbsp; required above? - seems very crude -->
					</p>
					<p>
						Operationally, implication can be evaluated in one of two ways. The
						code system literals may be designed such that one single hierarchy is
						reflected in the code literal itself (e.g., ICD-9). Apart from such
						special cases, however, a terminological knowledge base and an
						appropriate subsumption algorithm will be required to evaluate
						implication statements. For post-coordinated coding systems, designing
						such a subsumption algorithm is a non-trivial task.<footnote>
							<p>
								This is one reason why expressions should be used sparingly 
								and with caution. An additional problem of post-coordinated coding 
								is that a general rule for equality may not exist at all.
							</p>
						</footnote>
					</p>
				</div3>
				<div3 id="CDexamples">
					<head>CD Examples</head>
					<p>
					    A simple example for code is the ICD-9 code for headache, which is "784.0". 
					</p>
					<exhibit role="example" verbatim="yes">
						<pre>
&lt;example code="784.0" codeSystem="2.16.840.1.113883.6.42" codeSystemName="ICD-9"&gt;
	&lt;displayName value="Headache"/&gt;
	&lt;originalText value="general headache"/&gt;
&lt;/example&gt;</pre>
					</exhibit>
					<p>
					    A possible ICD-10 equivalent is "G44.1" (the ICD-10 classifications are slightly different). 
					</p>
					<exhibit role="example" verbatim="yes">
						<pre>
&lt;example code="G44.1" codeSystem="2.16.840.1.113883.6.3" codeSystemName="ICD-10"&gt;
	&lt;displayName value="Headache"/&gt;
	&lt;originalText value="general headache"/&gt;
&lt;/example&gt;</pre>
					</exhibit>
					<div4 id="CD.examples.null">
						<head>Coding Failure Examples</head>
						<p>
							A common situation with <emph>CD</emph> is when the actual concept cannot be 
							properly represented in a particular coding system. Usually this circumstance
							arises where the concept is expected to be represented in a particular coding
							system. For the purposes of these examples, we assume that all these example
							values are for an observation value of type <emph>CD</emph> that is found in the full Snomed-CT valueset
							(Example OID for the value set = 2.16.840.1.113883.19.11.1 as published 11-June 2007, Real OID for the SNOMED-CT code system = 2.16.840.1.113883.6.96).
							<emph role="bold">Important Note: The OID root 2.16.840.1.113883.19 is used for example-only OIDs, and OIDs in 
							this space are never valid in real instances. The OIDs used in these examples that in the OID space
							2.16.840.1.113883.6, 2.16.840.1.113883.5 and 2.16.840.1.113883.11 are the correct OIDs to use in
							production instances.</emph>
						</p>
						<p>
							The simplest case is where the <emph>CD</emph> is not represented in the instance 
							at all, or simply represented as no information.
						</p>
						<exhibit role="example" verbatim="yes">
							<pre>
&lt;value nullFlavor="NI"/&gt;</pre>
						</exhibit>
						<p>
							However this isn't a very useful representation - frequently the source system
							knows more information, and it is still useful to convey that information to 
							the destination system, while still labelling the coding as incomplete.
						</p>
						<exhibit role="example" verbatim="yes">
							<pre>
&lt;value nullFlavor="OTH" codeSystem="2.16.840.1.113883.6.96"/&gt;</pre>
						</exhibit>
						<p>
							or it may be encoded as 
						</p>
						<exhibit role="example" verbatim="yes">
							<pre>
&lt;value nullFlavor="OTH" valueSet="2.16.840.1.113883.19.11.1" valueSetVersion="20070711"/&gt;</pre>
						</exhibit>
						<p>
							Both examples say that the concept cannot be coded in SNOMED. Even more useful
							is to convey some specific information about the concept, even though it cannot
							be represented in SNOMED:
						</p>
						<exhibit role="example" verbatim="yes">
							<pre>
&lt;value nullFlavor="OTH" codeSystem="2.16.840.1.113883.6.96"&gt;
	&lt;originalText value="Burnt ear with iron. Burnt other ear calling for ambulance"/&gt;
&lt;/value&gt;</pre>
						</exhibit>
						<p>
							It is also possible that the content was first encoded in some other 
							code system than SNOMED, and the source system was unable to encode 
							the value in SNOMED. In this case, there is two forms of representation.
							The first is when the binding to SNOMED is labelled as CWE: local 
							extensions are allowed: 
						</p>
						<exhibit role="example" verbatim="yes">
							<pre>
&lt;value code="burn" codeSystem="2.16.840.1.113883.19.5.2"&gt;
	&lt;originalText value="Burnt ear with iron. Burnt other ear calling for ambulance"/&gt;
&lt;/value&gt;</pre>
						</exhibit>
						<p>
							In this case, because the binding is CWE, local extensions are allowed,
							and the source system can simply use it is own codeSystem (here identified
							by the OID "2.16.840.1.113883.19.5.2", which is an example OID) to extend
							the other code system. In fact, the source system can also use a code from
							another well known code system, such as ICD-9. If ICD-9 had a code "A10.1"
							which stood for this same concept, then this would be valid: 
						</p>
						<exhibit role="example" verbatim="yes">
							<pre>
&lt;value code="A10.1" codeSystem="2.16.840.1.113883.6.42"&gt;
	&lt;originalText value="Burnt ear with iron. Burnt other ear calling for ambulance"/&gt;
&lt;/value&gt;</pre>
						</exhibit>
						<p>
							If, however, the binding to the SNOMED-CT valueset is labelled CNE, then the
							code must come from SNOMED. The same information as the case above 
							must be conveyed differently:
						</p>
						<exhibit role="example" verbatim="yes">
							<pre>
&lt;value nullFlavor="OTH" codeSystem="2.16.840.1.113883.6.96"&gt;
	&lt;originalText value="Burnt ear with iron. Burnt other ear calling for ambulance"/&gt;
    &lt;translation code="burn" codeSystem="2.16.840.1.113883.19.5.2"&gt;
&lt;/value&gt;</pre>
						</exhibit>
						<p>
							Now the code is clearly marked as OTH: the code cannot be represented in
							SNOMED-CT, but a translation from another system is provided. Though it is
							pretty redundant in this case, the source system could indicate which translation
							comes from which using the source property: 
						</p>
						<exhibit role="example" verbatim="yes">
							<pre>
&lt;value nullFlavor="OTH" codeSystem="2.16.840.1.113883.6.96" source="s1"&gt;
	&lt;originalText value="Burnt ear with iron. Burnt other ear calling for ambulance"/&gt;
    &lt;translation id="s1" code="burn" codeSystem="2.16.840.1.113883.19.5.2"&gt;
&lt;/value&gt;</pre>
						</exhibit>
						<p>
							All these examples have assumed that the attribute is bound to the 
							fictitious value set 2.16.840.1.113883.19.11.1 which is all of SNOMED-CT.
							If the value set was extended to include the LOINC codes as well, it would
							no longer be appropriate to encode a failure to code like this:
						</p>
						<exhibit role="example" verbatim="yes">
							<pre>
&lt;value nullFlavor="OTH" codeSystem="2.16.840.1.113883.6.96"/&gt;</pre>
						</exhibit>
						<p>
							since it is not true that the concept could not be coded from SNOMED-CT - it 
							could not be coded in either SNOMED-CT or LOINC. For this reason, it is appropriate
							to encode the failure to code in the valueSet form:
						</p>
						<exhibit role="example" verbatim="yes">
							<pre>
&lt;value nullFlavor="OTH" valueSet="2.16.840.1.113883.19.11.1" valueSetVersion="20070711"/&gt;</pre>
						</exhibit>
					</div4>
					<div4 id="CD.examples.expr">
						<head>Expression examples</head>
						<p>
					    Expressions generally arise with complex medical terminologies such as SNOMED.
						For example, SNOMED CT defines a concept "cellulitis (disorder)"
						(128045006) an attribute "finding site" (363698007) and another
						concept "foot structure (body structure)" (56459004). SNOMED CT allows
						these codes to be combined in a code phrase:
					</p>
						<exhibit role="example" verbatim="yes">
							<pre>
128045006|cellulitis (disorder)|:{363698007|finding site|=56459004|foot structure|}</pre>
						</exhibit>
						<!--  old...<observation>
   ...
   <value code="128045006" codeSystem="&amp;SNOMED-CT;" displayName="">
      <qualifier code="56459004" displayName="">
         <name code="363698007" displayName=""/>
      </qualifier>
   </value>
   ...
</observation>]] -->
						<p>
						The full CD form for this is:
					</p>
						<exhibit role="example" verbatim="yes">
							<pre>
&lt;value code="128045006:{363698007=56459004}" codeSystem="2.16.840.1.113883.6.42" codeSystemName="Snomed-CT"&gt;
	&lt;originalText value="Cellulitis of the foot"/&gt;
&lt;/value&gt;</pre>
						</exhibit>
						<p>
						The SNOMED compositional expression language allows for the inclusion of the term
						in the expression, as shown in the first example. These make the expression more
						readable for humans, and so are used throughout this section in the standalone 
						expressions. However the terms are optional and do not improve readability for 
						computers; instead, their optional presence creates needless processing complexity, such as for testing equality. For this reason HL7 recommends that the 
						expressions in CD instances SHOULD NOT include the terms, and no CD examples include the terms 
						in the expressions in this specification. Value sets may make rules about the presence or absense of the
						terms in the expressions. 						
					</p>
						<p>
						The SNOMED compositional expression language is currently undergoing comment, 
						and may be found at 
						[<loc href="http://www.ihtsdo.org/fileadmin/user_upload/Docs_01/Technical_Docs/abstract_models_and_representational_forms.pdf" xlink-form="simple" show="embed" actuate="auto"/>].
						The next two examples are provided courtesy of David Markwell, and are
						based on SNOMED CT Core Edition 2007-01-31. 
					</p>
						<p>
						This first example is the SNOMED code for "fracture of left tibia". It shows 
						issues associated with grouping and nesting.
					</p>
						<exhibit role="example" verbatim="yes">
							<pre>
31978002|fracture of tibia|: 272741003|laterality|=7771000|left|</pre>
						</exhibit>
						<p>
						Strictly speaking (in normal form) a "fracture of left tibia" is not
						a "left fracture" of a "tibia bone" but is a "fracture" of the "left"
						"tibia bone" (that is, the qualification of "left" applies to the bone
						not to the fracture). Also note in this example that the fracture and
						bone are grouped - this may look irrelevant but is potentially significant
						for combined fractures where different morphology may apply to different
						bones. An alternative rendering for this same concept is:
					</p>
						<exhibit role="example" verbatim="yes">
							<pre>
64572001|disease|:{116676008|associated morphology|=72704001|fracture|,
     363698007|finding site|=(12611008|bone structure of tibia|:272741003|laterality|=7771000|left|)}</pre>
						</exhibit>
						<p>
						The second example shows a more complicated grouping and nesting structure. The SNOMED
						CT expression for "past history of fracture of left tibia" includes nesting even in
						its simplest form because the laterality does not apply to the past history but rather to
						the disorder.
					</p>
						<exhibit role="example" verbatim="yes">
							<pre>
417662000|past history of clinical finding|:246090004|associated finding|=
     (31978002|fracture of tibia|: 272741003|laterality|=7771000|left|)</pre>
						</exhibit>
						<p>
						The alternative rendering is even more nested:
					</p>
						<exhibit role="example" verbatim="yes">
							<pre>
243796009|situation with explicit context|:246090004|associated finding|=
     (64572001|disease|:{116676008|associated morphology|=72704001|fracture|,
     363698007|finding site|=(12611008|bone structure of tibia|:
     272741003|laterality|=7771000|left|)}),408729009|finding context|=
     410515003|known present|,408731000|temporal context|=410513005|past|,
     408732007|subject relationship context|=410604004|subject of record|</pre>
						</exhibit>
						<p>
     					These are provided as examples of SNOMED expression syntaxes. A full discussion the 
     					merits of the different forms, their relationship and how to work with them can be 
     					found in the SNOMED compositional expression language definition referred to above. 
     				</p>
						<p>
						It is important to note that the expression syntax and semantic rules are specified by
						the code system. For instance, in SNOMED CT, there are a defined set of
						qualifying attributes, and only Findings and Disorders can be
						qualified with the "finding site" attribute. <emph>CD</emph> does not provide
						for normalization of compositional expressions, therefore it is
						possible to create ambiguous expressions.  Users should understand
						that they must provide the additional constraints necessary to assure
						unambiguous data representation, if they are planning to create
						compositional expressions using <emph>CD</emph>. Otherwise, they risk
						the inability to retrieve a complete set of all records corresponding
						to any given query.
					</p>
						<p>
						ICD-10 allows dual coding. Refer to Section 3.1.3 of the ICD-10 Instruction 
						Manual (2nd Edition, [<loc href="http://www.who.int/entity/classifications/icd/ICD-10_2nd_ed_volume2.pdf" xlink-form="simple" show="embed" actuate="auto"/>]).
						While ICD-10 clearly establishes the semantic basis for the dual coding, 
						it does not define an actual literal expression form suitable for use with
						CD. In such cases, HL7 defines a suitable literal expression form and assigns
						an OID to that. The OID for this ICD-10 expression is 2.16.840.1.113883.6.260, and specifies
						that the two ICD-10 codes are separated by a space.  <!-- OID Key: 10: 4648  9:4649 -->
						</p>
						<exhibit role="example" verbatim="yes">
							<pre>
&lt;value code="J21.8 B95.6" codeSystem="2.16.840.1.113883.6.260" codeSystemName="ICD-10 Dual Code Expression"&gt;
	&lt;originalText value="Staph aureus bronchiolitis"/&gt;
&lt;/value&gt;</pre>
						</exhibit>
						<p>
						The ICD-10 code J21.8 is "Acute bronchiolitis due to other specified organisms" and
						the code B95.6 is "Staphylococcus aureus as the cause of diseases classified to other chapters".
					</p>
					</div4>
				</div3>
			</div2>
			<!-- delete once R2 passes ballot .... 
			<dt id="dt-CR" extends="dt-ANY" longname="Concept Role" shortname="CR" access="protected">
				<definition>
					A concept qualifier code with optionally named role.  Both qualifier
					role and value codes must be defined by the coding system of the <dtref ref='dt-CD'/>
					containing the concept qualifier.  For example, if SNOMED CT defines a concept "leg", a
					role relation "has-laterality", and another concept "left", the concept role
					relation allows to add the qualifier "has-laterality: left" to a
					primary code "leg" to construct the meaning "left leg".
				</definition>
				<prop-summary-table/>
				<p>
					The use of qualifiers is strictly governed by the code system
					used. <dtref ref="dt-CD"/> does not permit using code
					qualifiers with code systems that do not provide for qualifiers
					(e.g. pre-coordinated systems, such as LOINC, ICD-10 PCS).
				</p>
				<dtdl id="dtdl-CR" for="dt-CR" xml:space="preserve">
protected type ConceptRole alias CR specializes ANY {
   CV  name;
   BN  inverted;
   CD  value;
};</dtdl>
				<prop id="prop-CR.name" type="CV" shortname="name" longname="Name" >
					<definition>
						Specifies the manner in which the concept role value contributes to
						the meaning of a code phrase.  For example, if SNOMED CT defines a
						concept "leg", a role relation "has-laterality", and another concept
						"left", the concept role relation allows to add the qualifier
						"has-laterality: left" to a primary code "leg" to construct the
						meaning "left leg".  In this example, <propname/> is "has-laterality".
					</definition>
					<p>
						If the parent <propref ref='prop-CD.codeSystem'/> allows postcoordination
						but no role names (e.g. SNOMED) then <propname/> can be NULL.
					</p>
					<p>
						The <propname/> property of a nonNull CR may be NULL, in which case the
						<propref ref='prop-CR.value'/> is the complete qualifier. If
						the value alone is not a complete qualifier, but the name is not
						known, then the <dtname/> must have a null value even if the value is
						populated.
					</p>
					<constraint>
                                        <dtdl xml:space="preserve">
invariant(CR x) {
   x.name.originalText.isNull;
};</dtdl></constraint>
					<p>
						Qualifiers cannot have originalText on either name or value.
					</p>
				</prop>
				<prop id="prop-CR.value" type="CD" shortname="value" longname="Value" >
					<definition>
						The concept that modifies the primary code of a code phrase through
						the role relation.  For example, if SNOMED CT defines a concept "leg",
						a role relation "has-laterality", and another concept "left", the
						concept role relation allows adding the qualifier "has-laterality:
						left" to a primary code "leg" to construct the meaning "left leg".  In
						this example, <propref ref='prop-CR.value'/> is "left".
					</definition>
					<p>
						<propname/> is of type <dtref ref='dt-CD'/> and thus can in turn have
						qualifiers. This allows qualifiers to nest. Qualifiers can only be
						used as far as the underlying code system defines them. It is not
						allowed to use any kind of qualifiers for code systems that do not
						explicitly allow and regulate such use of qualifiers.
					</p>
					<constraint>
                                        <dtdl xml:space="preserve">
invariant(CR x)
      where x.nonNull {
   x.value.nonNull;
};</dtdl></constraint>
					<p>
						A non-null qualifier must have a non-null <propname/>.
					</p>
					<constraint>
                                        <dtdl xml:space="preserve">
invariant(CR x) {
   x.value.originalText.isNull;
};</dtdl></constraint>
					<p>
						Qualifiers cannot have originalText on either name or value.
					</p>
					<constraint>
                                        <dtdl xml:space="preserve">
invariant(CR x) {
   x.value.translation.isNull;
};</dtdl></constraint>
					<p>
						Qualifiers cannot have translations to the same or other code systems.
					</p>
				</prop>
				<prop id="prop-CR.inverted" type="BN" shortname="inverted" longname="Inversion Indicator" >
					<definition>
						Indicates if the sense of <propref ref='prop-CR.name'/> is inverted.  This can be used
						in cases where the underlying code system defines inversion but does
						not provide reciprocal pairs of role names. By default, inverted is
						<emph>false</emph>.
					</definition>
					<p>
						For example, a code system may define the role relation "causes"
						and the concepts "Streptococcus pneumoniae" and "Pneumonia". If
						that code system allows its roles to be inverted, one can construct
						the post-coordinated concept "Pneumococcus pneumonia" through
						"Pneumonia - causes, inverted - Streptococcus pneumoniae."
					</p>
					<p>
						Roles may only be inverted if the underlying coding system allows such
						inversion. Notably, if a coding system defines roles in inverse pairs
						or intentionally does not define certain inversions, the appropriate
						role code (e.g. "caused-by") must be used rather than inversion. It
						must be known whether the inverted property is <emph>true</emph> or
						<emph>false</emph>, since if it is NULL, the role cannot be interpreted.
					</p>
					<note role="ITS">
						<p>
							<propname/> should be conveyed in an indicator attribute,
							whose default value is <emph>false</emph>. That way the inverted
							indicator does not have to be sent when the role is not inverted.
						</p>
					</note>
				</prop>
				<prop id="prop-CR.equal" base="prop-ANY.equal">
					<argument name="x" type="CR"/>
					<definition>
						Two nonNull <dtname/>s are equal if they have the values same value and inversion code.
						If name is not null, it must also be equal.
					</definition>
					<constraint>
                                        <dtdl xml:space="preserve">
invariant(CR x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.value.equal(y.value)
	 .and(x.inverted.equal(y.inverted))
     .and(x.name.isNull.and(y.name.isNull).or(x.name.equal(y.name))));
};</dtdl></constraint>
				</prop>
			</dt>
-->
			<!--			<dt id="dt-CE" restricts="dt-CD" longname="Coded With Equivalents" shortname="CE" access="public">
				<definition>
					Coded data that consists of a coded value and, optionally, coded
					value(s) from other coding systems that identify the same
					concept. Used when alternative codes may exist, but when full
					post-coordination support is not required.
				</definition>
				<prop-summary-table/>
				<dtdl id="dtdl-CE" for="dt-CE" xml:space="preserve">
type CodedWithEquivalents alias CE specializes CD {
   ST       code;
   UID      codeSystem;
   ST       codeSystemName;
   ST       codeSystemVersion;
   ST       displayName;
   ED       originalText;

   DSET&lt;CD&gt; translation;
   /*see note on qualifier attribute. If
    alternate constraint, is accepted, this would be

   DSET&lt;CE&gt; translation;
   */
};</dtdl>
				<p>
					<dtname/> is used when the use case indicates that alternative
					codes may exist and where it is useful to communicate these.
					<dtname/> provides for a primary code value, plus a set of
					alternative or equivalent representations.
				</p>
				<prop id="prop-CE.code" base="prop-CD.code"/>
				<prop id="prop-CE.codeSystem" base="prop-CD.codeSystem"/>
				<prop id="prop-CE.codeSystemName" base="prop-CD.codeSystemName"/>
				<prop id="prop-CE.codeSystemVersion" base="prop-CD.codeSystemVersion"/>
				<prop id="prop-CE.displayName" base="prop-CD.displayName"/>
				<prop id="prop-CE.originalText" base="prop-CD.originalText"/>
				<prop id="prop-CE.translation" base="prop-CD.translation"/>
				<prop id="prop-CE.qualifier" base="prop-CD.qualifier" role="exclude" fixedValue="NullFlavor.NA">
					<p>
						Qualifiers are not allowed to be used on a <dt-name/> - the
						concept is not allowed to be qualified or post-coordinated.<footnote>
				<p>
					This constraint used to specify that the that the qualifier
					had a nullFlavor of notApplicable. There are two reasons why
					this was changed. The first is technical, that the definition
					of equality meant that any comparison of CE's would be return
					null since the qualifiers were fixed to a nullFlavor. Secondly,
					its not that the concept of qualifiers is not applicable - codes
					can always be qualified, its that there is not allowed to be any.
				</p>
				</footnote>
					</p>
					<dtdl xml:space="preserve">
invariant(CE x) {
   x.qualifier.length.isZero;
};</dtdl>
				<p>
					There has been much discussion about the status of qualifiers on 
					translations, and this issue is not as yet resolved. The alternative
					proposal is: 
				</p>
					<dtdl xml:space="preserve">
invariant(CE x) {
   x.qualifier.length.isZero;
   forall(CD c) where x.translation.contains(c) {
      c.qualifier.length.isZero;
   }
};</dtdl>
				<p>
					The implication of this is that translations of CEs are also CEs. The problem
					with this proposal is that it prohibits qualifiers that may be required to perform
					a proper translation. The advantage is that is underscores the intent of CE, which
					is that implementers to not need to deal with post-coordination. As it is, CE does
					not really achieve this goal. The problem is to balance between the competing 
					concerns of allowing proper translations and reducing the load on the implementers.
					As this issue is as yet unresolved, comments from balloters are solicited.
				</p>
				</prop>
				<prop id="prop-CE.equal" base="prop-ANY.equal">
					<argument name="x" type="CD"/>
					<definition>
						The definition of equality for the <dtname/> is taken from the <dtref ref="dt-CD"/> data type.<footnote>
							<p>
								This means that values of the type CE and CD may be equal.
							</p>
						</footnote>
					</definition>
				</prop>
			</dt> -->
			<!-- moved to a flavor. Delete if the move is successful			
			<dt id="dt-CV" longname="Coded Value" shortname="CV" restricts="dt-CE" access="protected">
				<definition>
					Coded data, specifying only a code, code system, and optionally
					display name and original text. Used only as the type of
					properties of other	data types.
				</definition>
				<prop-summary-table/>
				<dtdl id="dtdl-CV" for="dt-CV" xml:space="preserve">
type CodedValue alias CV specializes CE {
   ST   code;
   UID  codeSystem;
   ST   codeSystemName;
   ST   codeSystemVersion;
   ST   displayName;
   ED   originalText;
};</dtdl>
				<p>
					<dtname/> is used when any reasonable use case will require only a
					single code value to be sent. Thus, it should not be used in
					circumstances where multiple alternative codes for a given value are
					desired. This type may be used with both the CNE (<emph>coded,
					non-extensible</emph>) and the CWE (<emph>coded, with
					extensibility</emph>) domain qualifiers.
				</p>
				<prop id="prop-CV.code" base="prop-CD.code"/>
				<prop id="prop-CV.codeSystem" base="prop-CD.codeSystem"/>
				<prop id="prop-CV.codeSystemName" base="prop-CD.codeSystemName"/>
				<prop id="prop-CV.codeSystemVersion" base="prop-CD.codeSystemVersion"/>
				<prop id="prop-CV.displayName" base="prop-CD.displayName"/>
				<prop id="prop-CV.originalText" base="prop-CD.originalText"/>
				<prop id="prop-CV.translation" base="prop-CD.translation" role="exclude" fixedValue="NullFlavor.NA">
					<dtdl xml:space="preserve">
invariant(CV x) {
   x.translation.isEmpty;
};</dtdl>
				</prop>
				<prop id="prop-CV.qualifier" base="prop-CD.qualifier" role="exclude" fixedValue="NullFlavor.NA">
					<dtdl xml:space="preserve">
invariant(CV x) {
   x.qualifier.isEmpty;
};</dtdl>
				</prop>
				<prop id="prop-CV.equal" base="prop-ANY.equal">
					<argument name="x" type="CD"/>
					<definition>
						The definition of equality for the <dtname/> is taken from the <dtref ref="dt-CD"/> data type.<footnote>
							<p>
								This means that values of the type CV, CE and CD may be equal.
							</p>
						</footnote>
					</definition>
				</prop>
			</dt>
			-->
			<div2 id="dt-CO">
				<anchor id="CO"/>
				<head>CodedOrdinal (CO) specializes <termref ref="dt-CD">CD</termref>
				</head>
				<p>
					<emph role="strong">Definition:     </emph>
					 Coded data, where the coding system from which the code comes defines a 
					 partial or complete order on some or all of the codes in the system. 
				</p>
				<p>
					Codes may be assigned a numerical value, but this is not required. <emph>CO</emph> adds semantics
					related to ordering and/or numerical values so that models that make use of such domains may
					introduce model elements that involve statements about the order of the terms in a domain.
				</p>
				<exhibit role="dtdl" id="dtdl-CO">
					<anchor id="dtdl-CO"/>
					<caption/>
					<pre>
type CodedOrdinal alias CO specializes CD {
   REAL value;
   BL  lessOrEqual(CO o);
   BL  lessThan(CO o);
   BL  greaterThan(CO o);
   BL  greaterOrEqual(CO o);
};</pre>
				</exhibit>
				<p>
					The relative order of <emph>CO</emph> values need not be independently
					obvious in their literal representation. It is expected that an
					application will look up the ordering of these values from some
					table. Some of the values will have directly assigned numerical 
					value suitable for some mathematical operations.
				</p>
				<p>
				    The translations of the code, if present, SHALL not imply a different 
				    order from that implied by the <emph>CO</emph>. Translations MAY NOT imply any order.
					Translations SHALL not be considered when the ordering of the code
					system is determined. 
				</p>
				<p>
					Although <termref ref="prop-CO.value">value</termref> has a type <termref ref="dt-REAL">REAL</termref>,
					<emph>CO</emph> is provided to represent a series of concepts that have an 
					associated order, and sometimes a value. Likert scales are one such
					use case. <emph>CO</emph> should not be used to model an observation or 
					physical measurement which has value along with a set of value
					interpretations, sometimes called reference ranges.  
				</p>
				<div3 id="prop-CO.value">
					<head>Value (value) : <termref ref="dt-REAL">REAL</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The value assigned to this code in the code System. 
					</p>
					<p>
						<emph>value</emph> SHALL only be nonNull if the code system explicitly
						assigns a value to the concept.
					</p>
				</div3>
				<div3 id="prop-CO.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<argument name="x" type="CD"/>
					<p>
						The evaluation of equality for <emph>CO</emph> is the same as the <termref ref="dt-CD">CD</termref> data type.
						<emph>The value property is not included in the equality test.</emph>
						<footnote>
							<p>
								This means that values of the type CO, CS, CV and CD may be equal.
							</p>
						</footnote>
					</p>
				</div3>
				<div3 id="prop-CO.lessOrEqual">
					<head>Less-or-equal (lessOrEqual) : <termref ref="dt-BL">BL</termref>
					</head>
					<argument name="o" type="CO"/>
					<p>
						<emph role="strong">Definition:     </emph>
						A predicate expressing an order relation that is reflexive, asymmetric
						and transitive, between this concept and another concept.
					</p>
					<p>
						<emph>lessOrEqual</emph> is taken as
						primitive in this specification;
						all other order relations can be derived from this one.
						Since <emph>lessOrEqual</emph> is primitive, this accommodates partial orderings.
					</p>
					<p>
						Order relationships typically hold only within a single coding system.
						The terminology defines the order relationship for the concepts. While
						the definition of order is not based upon the value, the value, if provided,
						SHALL be consistent with the defined order.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(CO x, y)
      where x.nonNull.and(y.nonNull)
	    .and(x.value.nonNull).and(y.value.nonNull) {
   x.lessOrEqual(y).equal(x.value.lessOrEqual(y.value));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-CO.lessThan">
					<head>Less-than (lessThan) : <termref ref="dt-BL">BL</termref>
					</head>
					<argument name="o" type="CO"/>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(CO x, y)
      where x.nonNull.and(y.nonNull) {
   x.lessThan(y).equal(y.lessOrEqual(x).and(x.equal(y).not));
};

invariant(CO x, y)
      where x.nonNull.and(y.nonNull)
	    .and(x.value.nonNull).and(y.value.nonNull) {
   x.lessThan(y).equal(x.value.lessThan(y.value));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-CO.greaterThan">
					<head>Greater-than (greaterThan) : <termref ref="dt-BL">BL</termref>
					</head>
					<argument name="o" type="CO"/>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(CO x, y)
      where x.nonNull.and(y.nonNull) {
   x.greaterThan(y).equal(y.lessThan(x));
};

invariant(CO x, y)
      where x.nonNull.and(y.nonNull)
	    .and(x.value.nonNull).and(y.value.nonNull) {
   x.greaterThan(y).equal(x.value.greaterThan(y.value));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-CO.greaterOrEqual">
					<head>Greater-or-equal (greaterOrEqual) : <termref ref="dt-BL">BL</termref>
					</head>
					<argument name="o" type="CO"/>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(CO x, y)
      where x.nonNull.and(y.nonNull) {
   x.greaterOrEqual(y).equal(y.lessOrEqual(x));
};

invariant(CO x, y)
      where x.nonNull.and(y.nonNull)
	    .and(x.value.nonNull).and(y.value.nonNull) {
   x.greaterOrEqual(y).equal(x.value.greaterOrEqual(y.value));
};</pre>
					</exhibit>
				</div3>
			</div2>
			<div2 id="dt-CS">
				<anchor id="CS"/>
				<head>CodedSimpleValue (CS) specializes <termref ref="dt-CV">CV</termref>
				</head>
				<p>
					<emph role="strong">Definition:     </emph>
					Coded data in its simplest form, where only the code is not predetermined.
					The code system and code system version are fixed by the context in which
					<emph>CS</emph> value occurs. <emph>CS</emph> is used for coded attributes that have a single
					HL7-defined value set.
				</p>
				<table id="dt-CS-prop-summary">
					<caption>Property Summary of
      CodedSimpleValue</caption>
					<col width="79"/>
					<col width="60"/>
					<col width="413"/>
					<thead>
						<tr>
							<th>Name</th>
							<th>Type</th>
							<th>Description</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>
								<termref ref="prop-CS.code">code</termref>
							</td>
							<td>
								<termref ref="dt-ST.SIMPLE">ST.SIMPLE</termref>
							</td>
							<td>
						The plain code symbol defined by the code system, or an expression in a syntax
						defined by the code system which describes the concept.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-CS.codeSystem">codeSystem</termref>
							</td>
							<td>
								<termref ref="dt-UID">UID</termref>
							</td>
							<td>
						The code system that defines the code.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-CS.codeSystemName">codeSystemName</termref>
							</td>
							<td>
								<termref ref="dt-ST.NT">ST.NT</termref>
							</td>
							<td>
						The common name of the coding system.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-CS.codeSystemVersion">codeSystemVersion</termref>
							</td>
							<td>
								<termref ref="dt-ST.SIMPLE">ST.SIMPLE</termref>
							</td>
							<td>
						If applicable, a version descriptor defined specifically for the given
						code system.
					</td>
						</tr>
					</tbody>
				</table>
				<exhibit role="dtdl" id="dtdl-CS">
					<anchor id="dtdl-CS"/>
					<caption/>
					<pre>
type CodedSimpleValue alias CS specializes CV {
   literal  ST.SIMPLE;
};</pre>
				</exhibit>
				<p>
					<emph>CS</emph>
					<footnote>
						<p>
							CS is a data type rather than a flavor because as well as defining 
							a literal form, it also is associated with the introduction of
							default values to codeSystem and codeSystemVersion in an ITS.
						</p>
					</footnote> SHALL only be used in either of the following cases:
				</p>
				<list role="ordered">
					<item>
						for a coded attribute which has a single HL7-defined code system, and
						where code additions to that value set require formal HL7 action (such
						by Harmonization). Such coded attributes SHALL have type <emph>CS</emph> in
						the RIM definition of the attribute. 
					</item>
					<item>
						for a property in this specification that is assigned to a single code
						system defined either in this specification or defined outside HL7 by a body
						that has authority over the concept and the maintenance of that code system.
					</item>
				</list>
				<p>
					For example, since <termref ref="dt-ED">ED</termref> subscribes to the MIME
					design, it trusts IETF to manage the media type. This includes that this
					specification subscribes to the extension mechanism built into the MIME media
					type code (e.g., "application/x-myapp").
				</p>
				<p>
					For <emph>CS</emph> values, the designation of the domain qualifier
					SHALL always be CNE (<emph>coded, non-extensible</emph>) and the
					context will determine which values to use.<footnote>
						<p>
							This is not withstanding the fact that an external referenced domain,
							such as the IETF MIME media type may include an extension
							mechanism. These extended MIME type codes would not be considered
							"extensions" in the sense of violating the CNE provision. The CNE
							provision is only violated if an attempt is made in using a different
							code system (by means of <termref ref="prop-CD.codeSystem">CD.codeSystem</termref>), which is not
							possible with <emph>CS</emph>, or to use extensions that do not conform to the 
							external codeSystem.
						</p>
					</footnote>
				</p>
				<div3 id="prop-CS.code">
					<head>Code (code) : <termref ref="dt-ST.SIMPLE">ST.SIMPLE</termref>, inherited from <termref ref="dt-CD">CD</termref>
					</head>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(CS x)
      where x.nonNull {
   x.code.nonNull;
};</pre>
					</exhibit>
					<p>
						<emph/> SHALL only contain characters that are either 
						a letter, a digit, or one of '.', '-', '_' or ':'. 
						Code systems that are used with <emph>CS</emph> SHALL NOT define 
  					 	code symbols or expression syntaxes that contain whitespace or any
  					 	other characters not in this list.
					</p>
				</div3>
				<div3 id="prop-CS.codeSystem">
					<head>Code System (codeSystem) : <termref ref="dt-UID">UID</termref>, inherited from <termref ref="dt-CD">CD</termref>
					</head>
					<p>
						Every non-NULL <emph>CS</emph> value has a defined codeSystem.  The
						ITS representation of <emph>CS</emph> need not explicitly mention
						the code system, because the context mandates one and only one code
						system to be used. Specifying the code system explicitly would be
						redundant. However, codeSystem assumes the
						context-specific default value and is not NULL. This same logic applies
						to codeSystemName and codeSystemVersion.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(CS x)
      where x.code.nonNull {
   x.codeSystem.nonNull;
   x.codeSystem.equal(CONTEXT.codeSystem);
};</pre>
					</exhibit>
					<p>
						An exceptional <emph>CS</emph> of NULL-flavor <emph>other</emph> indicates that a
						concept could not be coded in the coding system specified. In these cases,
						<termref ref="prop-CS.code">code</termref> SHALL be Null.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(CS x)
      where x.other {
   x.code.isNull;
   x.codeSystem.nonNull;
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-CS.codeSystemName">
					<head>Code System Name (codeSystemName) : <termref ref="dt-ST.NT">ST.NT</termref>, inherited from <termref ref="dt-CD">CD</termref>
					</head>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(CS x) {
   x.codeSystemName.equal(CONTEXT.codeSystemName);
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-CS.codeSystemVersion">
					<head>Code System Version (codeSystemVersion) : <termref ref="dt-ST.SIMPLE">ST.SIMPLE</termref>, inherited from <termref ref="dt-CD">CD</termref>
					</head>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(CS x) {
   x.codeSystemVersion.equal(CONTEXT.codeSystemVersion);
};</pre>
					</exhibit>
					<p>
						For the properties with type <emph>CS</emph> defined in this specification that
						are associated with external codeSystems, the codeSystemVersion has the 
						nullFlavor NA.
					</p>
				</div3>
				<div3 id="prop-CS.displayName">
					<head>Display Name (displayName) : <termref ref="dt-ST">ST</termref>, (fixed)</head>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(CS x) {
   x.displayName.notApplicable;
};</pre>
					</exhibit>
					<p>
						<emph/> is not applicable when <emph>CS</emph> is used in exchanging
						data between systems. However the recipient system may be able to 
						derive an appropriate displayName from the code and codeSystem 
						information. Note that conformant systems MAY choose not to implement <emph/>
					</p>
				</div3>
				<div3 id="prop-CS.originalText">
					<head>Original Text (originalText) : <termref ref="dt-ED.TEXT">ED.TEXT</termref>, (fixed)</head>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(CS x) {
   x.originalText.notApplicable;
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-CS.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<argument name="x" type="CD"/>
					<p>
						The evaluation of equality for <emph>CS</emph> is the same as the <termref ref="dt-CD">CD</termref> data type.
						The value property is not included in the equality test.<footnote>
							<p>
								This means that values of the type CO, CS, CV, and CD may be equal.
							</p>
						</footnote>
					</p>
				</div3>
				<div3 id="prop-CS.literal">
					<head>Literal Form</head>
					<exhibit role="dtdl">
						<caption/>
						<pre>
CS.literal ST.SIMPLE {
   CS : /[a-zA-Z0-9_]+/  { $.equal($1); };
};</pre>
					</exhibit>
					<p>
						The string literal form of <emph>CS</emph> is primarily defined for the purposes of
						this specification. The literal form is a string representation of the code
						for the codeSystem for the context of the <emph>CS</emph>. You
						cannot determine <termref ref="prop-CS.codeSystem">codeSystem</termref> or
						<termref ref="prop-CS.codeSystemVersion">codeSystemVersion</termref> from the literal itself,
						so the literal only has use where the context is known.
					</p>
				</div3>
			</div2>
			<graphic source="graphics/dtUML-Identifiers.png" alt="Instance Identifier data types."/>
			<div2 id="dt-UID">
				<anchor id="UID"/>
				<head>UniqueIdentifierString (UID) specializes <termref ref="dt-ST.SIMPLE">ST.SIMPLE</termref>
				</head>
				<p>
					<emph role="strong">Definition:     </emph>
					A unique identifier string is a character string which identifies an
					object in a globally unique and timeless manner. The allowable formats
					and values and procedures of this data type are strictly controlled by
					HL7. At this time, user-assigned identifiers SHALL only be certain character
					representations of ISO Object Identifiers (<termref ref="dt-OID">OID</termref>) and DCE Universally
					Unique Identifiers (<termref ref="dt-UUID">UUID</termref>). In addition, HL7 reserves the right to assign other
					forms of <emph>UID</emph>s (<termref ref="dt-RUID">RUID</termref>), such as mnemonic identifiers for code systems.
				</p>
				<p>
					The sole purpose of <emph>UID</emph> is to be a globally and timelessly unique
					identifier. The form of <emph>UID</emph>, whether it is an <termref ref="dt-OID">OID</termref>,
					a <termref ref="dt-UUID">UUID</termref> or a <termref ref="dt-RUID">RUID</termref>, is entirely irrelevant.
					As far as HL7 is concerned, the
					only thing one can do with a <emph>UID</emph> is denote to the object for which it
					stands. Comparison of <emph>UID</emph>s is literal, i.e. if two <emph>UID</emph>s are literally
					identical, they are assumed to denote to the same object. If two <emph>UID</emph>s
					are not literally identical they <emph>may</emph> not denote to the
					same object. Note that this comparison is case sensitive; (<termref ref="dt-OID">OID</termref>)s
					do not have letters subject to case, (<termref ref="dt-UUID">UUID</termref>)s are fixed to
					uppercase, and (<termref ref="dt-RUID">RUID</termref>)s have a fixed case.
				</p>
				<exhibit role="dtdl" id="dtdl-UID">
					<anchor id="dtdl-UID"/>
					<caption/>
					<pre>
protected type UniqueIdentifierString alias UID specializes ST.SIMPLE;
</pre>
				</exhibit>
				<p>
					No difference in semantics is recognized between the different
					allowed forms of <emph>UID</emph>. The different forms are not distinguished
					by a component within or aside from the identifier string itself.
				</p>
				<p>
					Even though this specification recognizes no semantic difference
					between the different forms of the unique identifier forms, there are
					differences of how these identifiers are built and managed, which is
					the sole reason to define subtypes of <emph>UID</emph> for each of the
					variants.
				</p>
				<div3 id="prop-UID.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<argument name="x" type="ED"/>
					<p>
						The evaluation of equality for <emph>UID</emph> is the same as the <termref ref="dt-ED">ED</termref> data type.<footnote>
							<p>
								This means that values of the type UID, OID, UUID, RUID, ST, SC, and ED may be equal.
							</p>
						</footnote> This means that equality is determined be a case sensitive comparison of the string representation of the <emph>UID</emph>.
					</p>
				</div3>
			</div2>
			<div2 id="dt-OID">
				<anchor id="OID"/>
				<head>ObjectIdentifier (OID) specializes <termref ref="dt-UID">UID</termref> and <termref ref="dt-LIST">LIST</termref>&lt;<termref ref="dt-INT">INT</termref>&gt;</head>
				<p>
					<emph role="strong">Definition:     </emph>
					A globally unique string representing an ISO Object Identifier
					(OID) in a form that consists only of numbers and dots (e.g.,
					"2.16.840.1.113883.3.1"). According to ISO, <emph>OID</emph>s are paths in a tree
					structure, with the left-most number representing the root and the
					right-most number representing a leaf.
				</p>
				<p> 
					Each branch under the root corresponds to an assigning authority. Each
					of these assigning authorities may, in turn, designate its own set of
					assigning authorities that work under its auspices, and so on down the
					line. Eventually, one of these authorities assigns a unique (to it as
					an assigning authority) number that corresponds to a leaf node on the
					tree. The leaf may represent an assigning authority (in which case the
					root <emph>OID</emph> identifies the authority), a class of particlar objects, 
					or an instance of an object. An assigning authority owns a namespace,
					consisting of its sub-tree.
				</p>
				<p>
					<emph>OID</emph>s are the preferred scheme for unique identifiers. <emph>OID</emph>s SHOULD
					always be used except if one of the inclusion criteria for other
					schemes apply.
				</p>
				<p>
					ISO/IEC 8824:1990(E) clause 28 defines the Object Identifier as
				</p>
				<quote>
					<p>
						<emph role="strong">28.9</emph> The semantics of an
						object identifier value are defined by reference to an <emph role="strong">
						object identifier tree</emph>. An object identifier tree is a tree whose root
						corresponds to [the ISO/IEC 8824 standard] and whose vertices [i.e. nodes]
						correspond to administrative authorities responsible for allocating arcs [i.e.
						branches] from that vertex. Each arc from that tree is labeled by an object
						identifier component, which is [an integer number]. Each information object to
						be identified is allocated precisely one vertex (normally a leaf) and no other
						information object (of the same or a different type) is allocated to
						that same vertex. Thus an information object is uniquely and
						unambiguously identified by the sequence of [integer numbers] (object
						identifier components) labeling the arcs in a path from the root to
						the vertex allocated to the information object.
					</p>
					<p>
						<emph role="strong">28.10</emph> An object identifier value is
						semantically an ordered list of object identifier component
						values. Starting with the root of the object identifier tree, each
						object identifier component value identifies an arc in the object
						identifier tree. The last object identifier component value identifies
						an arc leading to a vertex to which an information object has been
						assigned. It is this information object, which is identified by the
						object identifier value. [...]
					</p>
				</quote>
				<!--
Comment from Kevin: The formal definition of OID is clear as mud.
Put in the individual attribute descriptions like the rest of the data types. 
The diagram which is used is ancient and doesn't really help all that much.
 -->
				<exhibit role="dtdl" id="dtdl-OID">
					<anchor id="dtdl-OID"/>
					<caption/>
					<pre>
type ObjectIdentifier alias OID specializes UID, LIST&lt;INT&gt; {
           INT  leaf;
           OID  butLeaf;
           OID  value(OID namespace);
   literal ST.SIMPLE;
};</pre>
				</exhibit>
				<p>
					According to ISO/IEC 8824 an object identifier is a sequence of object
					identifier component values, which are integer numbers. These
					component values are ordered such that the root of the object
					identifier tree is the head of the list followed by all the arcs down
					to the leaf representing the information object identified by the
					OID. The fact that <emph>OID</emph> specializes <termref ref="dt-LIST">LIST</termref>&lt;<termref ref="dt-INT">INT</termref>&gt;
					represents this path of object identifier component
					values from the root to the leaf.
				</p>
				<p>
					The <emph role="strong">leaf</emph> and "<emph role="strong">butLeaf</emph>"
					properties take the opposite view. The
					leaf is the last object identifier component value in the list, and
					the "butLeaf" property is all of the OID <emph>but</emph> the
					<emph>leaf</emph>. In a sense, the leaf is the identifier value and
					all of the OID but the leaf refers to the namespace in which the leaf
					is unique and meaningful.
				</p>
				<p>
					However, what part of the OID is considered <emph role="strong">value</emph>
					and what is <emph role="strong">namespace</emph> may be viewed differently. In
					general, any OID component sequence to the left can be considered the namespace
					in which the rest of the sequence to the right is defined as a
					meaningful and unique identifier value. The value-property with a
					namespace OID as its argument represents this point of view.<footnote>
						<p>
							The value/namespace view on ISO object identifiers has important
							semantic relevance. It represents the notion of identifier value
							versus identifier assigning authority (or "namespace"), which is common
							in healthcare information systems in general, and HL7 v2.x in
							particular.
						</p>
					</footnote>
				</p>
				<exhibit role="dtdl">
					<caption/>
					<pre>
invariant(OID x)
      where x.nonNull {
   x.notEmpty;
   x.tail.isEmpty.implies(x.leaf.equal(x.tail));
   x.tail.notEmpty.implies(x.leaf.equal(x.tail.leaf));
   x.tail.isEmpty.implies(x.butLeaf.isNull);
   x.tail.notEmpty.implies(x.butLeaf.head.equal(x.head)
         .and(x.butLeaf.tail.equal(x.butLeaf(x.tail))));
   forall(OID v; OID n) where v.equal(x.value(n)) {
      n.isEmpty.implies(v.equal(x));
      n.notEmpty.implies(v.equal(x.value(n.tail)));
      };
};</pre>
				</exhibit>
				<p>
					In order to support interoperability, HL7 maintains strict rules about the
					registration and use of OIDs. These rules are published in 
						the "Core Principles of V3 Models" specification under "Identification" ([<loc href="../coreprinciples/v3modelcoreprinciples.htm#coreP_Identification-registry" xlink-form="simple" show="embed" actuate="auto"/>]) and SHALL be followed.   
				</p>
				<p>
						While most owners of an OID will "design" their namespace sub-tree in
						some meaningful way, there is no way to generally infer any meaning on
						the parts of an OID. HL7 does not standardize or require any namespace
						sub-structure. An OID owner, or anyone having knowledge about the
						logical structure of part of an OID, may still use that knowledge to
						infer information about the associated object; however, the techniques
						cannot be generalized.
					</p>
				<graphic source="graphics/datyp2fig5.gif" alt="&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Example for a tree of ISO object identifiers. HL7's OID&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;is 2.16.840.1.113883.&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;"/>
				<p>
					<emph role="strong">An HL7 interface SHALL NOT rely on any
						knowledge about the substructure of an OID for which it cannot control the
						assignment policies.</emph>
				</p>
				<prop id="prop-OID.leaf" type="INT" shortname="leaf" longname="Leaf" render="false"/>
				<prop id="prop-OID.butLeaf" type="OID" shortname="butLeaf" longname="All-But-The-Leaf" render="false"/>
				<prop id="prop-OID.value" type="OID" shortname="value" longname="Value" render="false">
					<argument name="namespace" type="OID"/>
				</prop>
				<div3 id="prop-OID.literal">
					<head>Literal Form</head>
					<p>
						The structured definition of the OID is provided mostly to be faithful
						to the OID specification. Within HL7, OIDs are used as UID strings
						only, i.e., the literal string value is the only thing that is
						communicated and is the only thing that a reciever should have to
						consider when working with UIDs in the scope of the HL7 specification.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
OID.literal ST.SIMPLE {
   OID : INT "." OID { $.head.equal($1);
                       $.tail.equal($3); }
       | INT         { $.head.equal($1);
                       $.tail.isEmpty; }
};</pre>
					</exhibit>
					<p>
						For compatibility with the DICOM standard, the literal form of the OID
						should not exceed 64 characters. (see DICOM part 5, section 9).
					</p>
				</div3>
				<div3 id="prop-OID.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<argument name="x" type="ED"/>
					<p>
						The evaluation of equality for <emph>OID</emph> is the same as the <termref ref="dt-ED">ED</termref> data type.
						The value property is not included in the equality test.<footnote>
							<p>
								This means that values of the type OID, UID, UUID, RUID, ST, SC, and ED may be equal.
							</p>
						</footnote>
					</p>
				</div3>
			</div2>
			<div2 id="dt-UUID">
				<anchor id="UUID"/>
				<head>UniversalUniqueIdentifier (UUID) specializes <termref ref="dt-UID">UID</termref>
				</head>
				<p>
					<emph role="strong">Definition:     </emph>
					A globally unique string representing a DCE Universal Unique
					Identifier (UUID) in the common UUID format that consists of 5
					hyphen-separated groups of hexadecimal digits having 8, 4, 4, 4,
					and 12 places respectively.
				</p>
				<p>
					Both the UUID and its string representation are defined by the Open
					Group, CDE 1.1 Remote Procedure Call specification, Appendix A.
				</p>
				<p>
					UUIDs are assigned based on Ethernet MAC addresses, the point in time
					of creation and some random component. This mix is believed to
					generate sufficiently unique identifiers without any organizational
					policy for identifier assignment (in fact this piggy-backs on the
					organization of MAC address assignment). Note that there are other 
					common methods for generating UUIDs. HL7 does not require that the UUID
					method defined by the Open Group specification so long as generated UUIDs
					are globally unique. 
				</p>
				<p>
					UUIDs are <emph role="strong">not</emph> the preferred identifier
					scheme for use as HL7 UIDs. UUIDs may be used when identifiers are
					issued to objects representing individuals (e.g., entity instance
					identifiers, act event identifiers, etc.). For objects describing
					classes of things or events (e.g., catalog items), OIDs are the
					preferred identifier scheme.
				</p>
				<exhibit role="dtdl" id="dtdl-UUID">
					<anchor id="dtdl-UUID"/>
					<caption/>
					<pre>
type UniversalUniqueIdentifier alias UUID specializes UID {
   INT  timeLow;
   INT  timeMid;
   INT  timeHighAndVersion;
   INT  clockSequence;
   INT  node;
   literal  ST.SIMPLE;
};</pre>
				</exhibit>
				<div3 id="prop-UUID.timeLow">
					<head>Low Time (timeLow) : <termref ref="dt-INT">INT</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The low field of the timestamp.
					</p>
				</div3>
				<div3 id="prop-UUID.timeMid">
					<head>Mid Time (timeMid) : <termref ref="dt-INT">INT</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The middle field of the timestamp.
					</p>
				</div3>
				<div3 id="prop-UUID.timeHighAndVersion">
					<head>High Time and Version (timeHighAndVersion) : <termref ref="dt-INT">INT</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The high field of the timestamp multiplexed with the version number.
					</p>
				</div3>
				<div3 id="prop-UUID.clockSequence">
					<head>Clock Sequence (clockSequence) : <termref ref="dt-INT">INT</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The high field of the clock sequence multiplexed with the variant and the low field of the clock sequence.
					</p>
				</div3>
				<div3 id="prop-UUID.node">
					<head>Node (node) : <termref ref="dt-INT">INT</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The spatially unique node identifier (usually the host address). 
					</p>
				</div3>
				<div3 id="prop-UUID.literal">
					<head>Literal Form</head>
					<p>
						The structured definition of the UUID is provided mostly to be
						faithful to the UUID specification. Within HL7, UUIDs are used as UID
						strings only, i.e., the literal string value is the only thing that is
						communicated and is the only thing that a reciever should have to
						consider when working with UIDs in the scope of the HL7 specification.
					</p>
					<p>
						The literal form for the UUID is defined according to the original
						specification of the UUID. However, because the HL7 UIDs are case
						sensitive, for use with HL7, the hexadecimal digits A-F in UUIDs
						SHALL be converted to upper case.
					</p>
					<exhibit role="dtdl" id="dtdl-UUID.literal">
						<anchor id="dtdl-UUID.literal"/>
						<caption/>
						<pre>
UUID.literal ST.SIMPLE {
   UUID        : hex8 "-" hex4 "-" hex4 "-" hex4 "-" hex12 {
                    $.timeLow.equal($1);
                    $.timeMid.equal($3);
                    $.timeHighAndVersion.equal($5);
                    $.clockSequence.equal($7);
                    $.node.equal($9);
                    }

   INT hex4    : hexDigit hexDigit hexDigit hexDigit {
                    $.equal($1.times(16).plus($2)
                     .times(16).plus($3)
                     .times(16).plus($4);
                    }

   INT hex8    : hexDigit hexDigit hexDigit hexDigit
                       hexDigit hexDigit hexDigit hexDigit {
                    $.equal($1.times(16).plus($2)
                     .times(16).plus($3)
                     .times(16).plus($4)
                     .times(16).plus($5)
                     .times(16).plus($6)
                     .times(16).plus($7)
                     .times(16).plus($8);
                     }

   INT hex12    : hexDigit hexDigit hexDigit hexDigit
                        hexDigit hexDigit hexDigit hexDigit
                        hexDigit hexDigit hexDigit hexDigit {
                     $.equal($1.times(16).plus($2)
                      .times(16).plus($3)
                      .times(16).plus($4)
                      .times(16).plus($5)
                      .times(16).plus($6)
                      .times(16).plus($7)
                      .times(16).plus($8)
                      .times(16).plus($9)
                      .times(16).plus($10)
                      .times(16).plus($11)
                      .times(16).plus($12);
                     }

   INT hexDigit : "0"     { $.equal(0); }
                | "1"     { $.equal(1); }
                | "2"     { $.equal(2); }
                | "3"     { $.equal(3); }
                | "4"     { $.equal(4); }
                | "5"     { $.equal(5); }
                | "6"     { $.equal(6); }
                | "7"     { $.equal(7); }
                | "8"     { $.equal(8); }
                | "9"     { $.equal(9); }
                | "A"     { $.equal(10); }
                | "B"     { $.equal(11); }
                | "C"     { $.equal(12); }
                | "D"     { $.equal(13); }
                | "E"     { $.equal(14); }
                | "F"     { $.equal(15); }
};</pre>
					</exhibit>
					<note>
						<p>
							The output of UUID related programs and functions may use all sorts of
							forms, upper case, lower case, and with or without the hyphens that
							group the digits. This variate output SHALL be postprocessed to conform
							to the HL7 specification, i.e., the hyphens SHALL be inserted for the
							8-4-4-4-12 grouping and all hexadecimal digits SHALL be converted to
							upper case.
						</p>
					</note>
				</div3>
				<div3 id="prop-UUID.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<argument name="x" type="ED"/>
					<p>
						The evaluation of equality for <emph>UUID</emph> is the same as the <termref ref="dt-ED">ED</termref> data type.
						The value property is not included in the equality test.<footnote>
							<p>
								This means that values of the type UUID, UID, OID, RUID, ST, SC, and ED may be equal.
							</p>
						</footnote>
					</p>
				</div3>
			</div2>
			<div2 id="dt-RUID">
				<anchor id="RUID"/>
				<head>HL7ReservedIdentifierScheme (RUID) specializes <termref ref="dt-UID">UID</termref>
				</head>
				<p>
					<emph role="strong">Definition:     </emph>
					A globally unique string defined exclusively by HL7. Identifiers in
					this scheme SHALL only be defined by balloted HL7 specifications. Local
					communities or systems SHALL never use such reserved identifiers based
					on bilateral negotiations.
				</p>
				<exhibit role="dtdl" id="dtdl-RUID">
					<anchor id="dtdl-RUID"/>
					<caption/>
					<pre>
type HL7ReservedIdentifierScheme alias RUID specializes UID;</pre>
				</exhibit>
				<p>
					HL7 reserved identifiers are strings that consist only of (US-ASCII)
					letters and digits, where the first character SHALL be a
					letter. HL7 may assign these reserved identifiers as mnemonic
					identifiers for major concepts of interest to HL7. RUID's are case 
					sensitive; the case assigned to the identifier by HL7 will be used.
				</p>
				<!-- editors note: cannot include hyphens, because then a UUID is a valid RUID  -->
				<p>
					HL7 has reserved the RUID scheme for future use, but at this time there are no plans
					to make use of them, as <termref ref="dt-OID">OID</termref>s and <termref ref="dt-UUID">UUID</termref>s have met all
					requirements so far identified.    
				</p>
				<div3 id="prop-RUID.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<argument name="x" type="ED"/>
					<p>
						The evaluation of equality for <emph>RUID</emph> is the same as the <termref ref="dt-ED">ED</termref> data type.<footnote>
							<p>
						This means that values of the type RUID, UID, ST, SC, and ED may be equal.
							</p>
						</footnote>
					</p>
				</div3>
			</div2>
			<div2 id="dt-II">
				<anchor id="II"/>
				<head>InstanceIdentifier (II) specializes <termref ref="dt-ANY">ANY</termref>
				</head>
				<p>
					<emph role="strong">Definition:     </emph>
					An identifier that uniquely identifies a thing or object. Examples
					are object identifier for HL7 RIM objects, medical record number,
					order id, service catalog item id, Vehicle Identification Number
					(VIN), etc. 
				</p>
				<p>
					Note that a <emph>II</emph> does not identify the type of the object being identified, or 
					the type of the association between the object and the identifier - it is only
					the identifier itself. <footnote>
						<p>HL7 is preparing a document that contains common usage patterns that
					will discuss how to best use the II type in common healthcare identification use cases.</p>
					</footnote>
				</p>
				<table id="dt-II-prop-summary">
					<caption>Property Summary of
      InstanceIdentifier</caption>
					<col width="79"/>
					<col width="60"/>
					<col width="413"/>
					<thead>
						<tr>
							<th>Name</th>
							<th>Type</th>
							<th>Description</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>
								<termref ref="prop-II.root">root</termref>
							</td>
							<td>
								<termref ref="dt-UID">UID</termref>
							</td>
							<td>
						A unique identifier that guarantees the global uniqueness of the
						instance identifier. The root alone may be the entire instance
						identifier.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-II.extension">extension</termref>
							</td>
							<td>
								<termref ref="dt-ST.SIMPLE">ST.SIMPLE</termref>
							</td>
							<td>
						A character string as a unique identifier within the scope of the
						identifier root.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-II.identifierName">identifierName</termref>
							</td>
							<td>
								<termref ref="dt-ST.NT">ST.NT</termref>
							</td>
							<td>
						This is a human-readable name for the namespace represented in the root. It is a
						descriptive name for the actual namespace. e.g. "California, U.S. Driver's License Number, 1970-".
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-II.scope">scope</termref>
							</td>
							<td>
								<termref ref="dt-CS">CS</termref>
							</td>
							<td>
						Specifies the scope in which the identifier applies to the object with which it is associated.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-II.reliability">reliability</termref>
							</td>
							<td>
								<termref ref="dt-CS">CS</termref>
							</td>
							<td>
						Specifies the reliability with which the identifier is known. This attribute MAY be used to assist with identifier matching algorithms.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-II.displayable">displayable</termref>
							</td>
							<td>
								<termref ref="dt-BL">BL</termref>
							</td>
							<td>
                     Specifies if the identifier is intended for human
                     display and data entry (displayable = true) as
                     opposed to pure machine interoperation (displayable
                     = false).
                  </td>
						</tr>
					</tbody>
				</table>
				<exhibit role="dtdl" id="dtdl-II">
					<anchor id="dtdl-II"/>
					<caption/>
					<pre>
type InstanceIdentifier alias II specializes ANY {
      UID        root;
      ST.SIMPLE  extension;
      ST.NT      identifierName;
      CS         scope;
      CS         reliability;
      BL         displayable;
  literal ST.SIMPLE;
};</pre>
				</exhibit>
				<p>
					In order to simplify processing, when the root or extension properties have some nullFlavor other than 
					NotApplicable, the <emph>II</emph> itself must have some kind of nullFlavor.
				</p>
				<exhibit role="dtdl">
					<caption/>
					<pre>
invariant(II x) {
   root.isNull.and(root.notApplicable.not).implies(x.isNull);
   extension.isNull.and(extension.notApplicable.not).implies(x.isNull);
};</pre>
				</exhibit>
				<div3 id="prop-II.root">
					<head>Root (root) : <termref ref="dt-UID">UID</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						A unique identifier that guarantees the global uniqueness of the
						instance identifier. The root alone may be the entire instance
						identifier.
					</p>
					<!-- FIXME: integrate new language about root -->
					<p>
						In the presence of a non-null extension, the root is the unique identifier for
						the "namespace" of the identifier in the extension. Note that this does NOT
						necessarily correlate with the organization that manages the issuing of the
						identifiers.  A given organization may manage multiple identifier namespaces,
						and control over a given namespace may transfer from organization to organization
						over time while the root remains the same.<footnote>
							<p>
								DICOM objects are identified by UID only. For the purpose of DICOM/HL7
								integration, it would be awkward if HL7 required the extension to be
								mandatory and to consider the UID only as an assigning
								authority. Since UID values are simpler and do not contain the risks
								of containing meaningless decoration, we do encourage systems to use
								simple UID identifiers as external references to their objects.
							</p>
						</footnote>
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(II x)
      where x.nonNull {
   root.nonNull;
};</pre>
					</exhibit>
					<p>
						In situations where an extension is known, but the root is not known, the II should be populated with a 
						nullFlavor "Unknown", a null root, and an extension with the value. These situations may arise when 
						identifiers such as driver's license or passport numbers are collected without ascertaining which 
					    authority issued them, or with point-of-care devices that contain a simple bar code scanner. In some
					    of these cases, it may be possible to create a new <emph>II</emph> with a known root at a later time.
					</p>
				</div3>
				<div3 id="prop-II.extension">
					<head>Extension (extension) : <termref ref="dt-ST.SIMPLE">ST.SIMPLE</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						A character string as a unique identifier within the scope of the
						identifier root.
					</p>
					<p>
						The extension is a character string that is unique in the namespace
						designated by the root. If a non-NULL extension exists, the root
						specifies a namespace (sometimes called "assigning authority" or
						"identifier type").  The extension property MAY be Not Applicable in which case
						the root <termref ref="dt-OID">OID</termref> is the complete unique identifier. If
						the root is not a complete unique identifier, and the extension is not 
						known, then the <emph>II</emph> SHALL have a null value even if the root is 
						populated.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(II x)
      where x.extension.isNull {
   x.notApplicable().not.implies(x.isNull);
};</pre>
					</exhibit>
					<p>
						The root and extension scheme means that the concatenation
						of root and extension SHALL be a globally unique identifier for the
						item that this II value identifies.
					</p>
					<p>
						It is recommended that systems use the <termref ref="dt-OID">OID</termref> scheme for external
						identifiers of their communicated objects. The extension property is
						mainly provided to accommodate legacy alphanumeric identifier schemes.
					</p>
					<p>
						Some identifier schemes define certain style options to their code
						values. For example, the U.S. Social Security Number (SSN) is normally
						written with dashes that group the digits into a pattern
						"123-12-1234". However, the dashes are not meaningful and a SSN can
						just as well be represented as "123121234" without the dashes.
					</p>
					<p>
						In the case where identifier schemes provide for multiple
						representations, HL7 will make a ruling about which is the preferred
						form and document that ruling where that respective external
						identifier scheme is recognized. HL7 will decide upon the preferred
						form based on criteria of practicality and common use. In absence of
						clear criteria of practicality and common use, the safest, most
						extensible, and least stylized (the least decorated) form SHALL be
						given preference.<footnote>
							<p>
								This ruling at design-time is necessary to prevent HL7 interfaces from
								being burdened by identifier literal style conversions at
								runtime. This is notwithstanding the fact that some applications may
								require mapping from one form into another if that application has
								settled with the representation option that was not chosen by HL7.
							</p>
							<p>
								From practical experience it is recommended that II.extensions as
								an alphanumeric identifier not contain leading zero digits (if any
								zeroes at all), for these are often erroneously stripped. "000123"
								and "123" would be different extension values, but this is prone
								to be misunderstood, leading to false non-matches and duplicate
								record entries. However applications should maintain any leading zero
								digits encountered in II extensions. Leading zero digits are
								prohibited in <termref ref="dt-OID">OID</termref>'s, but may occur in <termref ref="dt-UUID">UUID</termref>'s,
								where they must be maintained.
							</p>
							<p>
								There is no separate check digit property. Check digits are used
								for human purpose and work best if kept completely transparent.
								II.extensions MAY contain check digits anywhere, and the
								particular check digit scheme (if any) would be implied by the
								II.root. However, a separate check digit property is intentionally
								not recognized by this specification.
							</p>
						</footnote>
						In the absence of a preferred form or ruling, implementers should omit all non-significant separators when performing semantic equality checks.
					</p>
					<p>
						HL7 MAY also decide to map common external identifiers to the value
						portion of the II.root <termref ref="dt-OID">OID</termref>. For example, the U.S. SSN could be
						represented as 2.16.840.1.113883.4.1.123121234. The criteria of
						practicality and common use will guide HL7's decision on each
						individual case.
					</p>
					<note role="Implementer">
						<p>
				  	    The normal mechanism for representing a <termref ref="dt-UUID">UUID</termref> as an identifier is as
						the value of the root property, with the extension property set to NULL. A <termref ref="dt-UUID">UUID</termref>
						expressed as an extension is not considered to be a match for a <termref ref="dt-UUID">UUID</termref>
						in the root. i.e. A match is required on both root and extension to be considered a match.
						The root can be used to identify a namespace. The design of HL7 specifications SHALL never assume
						that receiving applications can infer the identity of the scoper or issuer, or the type of the
						identifier or identified object, from the namespace identifier. 
					</p>
					</note>
				</div3>
				<div3 id="prop-II.identifierName">
					<head>Identifier Name (identifierName) : <termref ref="dt-ST.NT">ST.NT</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						This is a human-readable name for the namespace represented in the root. It is a
						descriptive name for the actual namespace. e.g. "California, U.S. Driver's License Number, 1970-".
					</p>
					<p>
						IdentifierName does NOT refer to the organization which issued the identifier (e.g. California Dept. of
						Motor Vehicles). It is intended for use as a human readable label when an identifier must be
						displayed to a human user where an OID would not be meaningful. In general, it should only be
						used when an extension is present, allowing for a display such as "California, U.S. Driver's
						License Number, 1970-: 123456789". There are absolutely no guidelines for the contents of this
						text other than it should be completely descriptive of the namespace. E.g. "Driver's License"
						or even "California Driver's License" would not be ideal. However, formatting, capitalization,
						whitepace, language, etc. are completely up to the sender. 
					</p>
					<p>
						The Identifier Name has no computational value. <emph>identifierName</emph> can
						never modify the meaning of <termref ref="prop-II.root">root</termref>. The purpose of a Identifier
						Name is to assist an unaided human interpreter of an II value to interpret the identifier.
						Applications SHALL NOT attempt to perform any decision-making, matching, filtering or other
						processing based on this presence or value of this property. It is for display and development
						assistance only. All decision logic SHALL be based solely on the root and extension properties.
						Conformant  systems MAY choose not to implement <emph>identifierName</emph> but SHALL NOT reject 
						instances because <emph>identifierName</emph> is present.						
					</p>
				</div3>
				<div3 id="prop-II.scope">
					<head>Scope (scope) : <termref ref="dt-CS">CS</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						Specifies the scope in which the identifier applies to the object with which it is associated.
					</p>
					<table id="domain-IdentifierScope">
						<caption>Concept Domain IdentifierScope. ValueSet OID:  [not yet assigned]. CodeSystem "IdentifierScope", OID: 2.16.840.1.113883.5.1116, Owner: HL7</caption>
						<thead>
							<tr valign="bottom">
								<th>lvl</th>
								<th>code</th>
								<th>name</th>
								<th>definition</th>
							</tr>
						</thead>
						<tr valign="top">
							<td>1</td>
							<td>BUSN</td>
							<td>Business Identifier</td>
							<td>
								<p>
            An identifier whose scope is defined by business practices associated with the object. In contrast to the other scope identifiers, the scope of the use of the id is not necessarily restricted to a single object, but may be reused for other objects closely associated with the object due to business practice.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>OBJ</td>
							<td>Object Identifier</td>
							<td>
								<p> The identifier associated with a particular object. It remains consistent as the object undergoes state transitions.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>VER</td>
							<td>Version Identifier</td>
							<td>
								<p>An identifier that references a particular object as it existed at a given point in time. </p>
								<p>The identifier SHALL change with each state transition on the object. I.e. The version identifier of an object prior to a 'suspend' state transition is distinct from the identifier of the object after the state transition. Each version identifier can be tied to exactly one ControlAct event which brought that version into being (though the control act may never be instantiated). <i>NOTE: Applications that do not support versioning of objects must ignore and not persist these ids to avoid confusion resulting from leaving the same identifier on an object that undergoes changes.</i>
								</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>VW</td>
							<td>View Specific Identifier</td>
							<td>
								<p>An identifier for a particular snapshot of a version of the object. </p>
								<p>This identifies a view of the business object at a particular point in time, and as such identifies a set of data items that can be digitally signed and/or attested. This is in contrast to the Version Identifier which identifies the object at a specific time, but not the amount of information being asserted about the object. This identifier would be changed when a transformation of the information is performed (eg to add code translations, to provide a simplified textual rendering, or to provide additional information about the object as it existed at the specific point in time). </p>
							</td>
						</tr>
					</table>
				</div3>
				<div3 id="prop-II.reliability">
					<head>Reliability (reliability) : <termref ref="dt-CS">CS</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						Specifies the reliability with which the identifier is known. This attribute MAY be used to assist with identifier matching algorithms.
					</p>
					<table id="domain-IdentifierReliability">
						<caption>Concept Domain IdentifierReliability. ValueSet OID:  [not yet assigned]. CodeSystem "IdentifierReliability", OID: 2.16.840.1.113883.5.1117, Owner: HL7</caption>
						<thead>
							<tr valign="bottom">
								<th>lvl</th>
								<th>code</th>
								<th>name</th>
								<th>definition</th>
							</tr>
						</thead>
						<tr valign="top">
							<td>1</td>
							<td>ISS</td>
							<td>Issued by system</td>
							<td>
								<p>The identifier was issued by the system responsible for constructing the instance.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>VER</td>
							<td>Verified by system</td>
							<td>
								<p>The identifier was not issued by the system responsible for constructing the instance, but the system that captured the id has verified the identifier with the issuing authority, or with another system that has verified the identifier.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>UNV</td>
							<td>Unverified by system</td>
							<td>
								<p>The identifier was provided to the system that constructed the instance, but has not been be verified. e.g. a Driver's license entered manually into a system by a user.</p>
							</td>
						</tr>
					</table>
				</div3>
				<div3 id="prop-II.displayable">
					<head>Displayable (displayable) : <termref ref="dt-BL">BL</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
                     Specifies if the identifier is intended for human
                     display and data entry (displayable = true) as
                     opposed to pure machine interoperation (displayable
                     = false).
                  </p>
					<p>
                  	Conformant systems MAY choose not to implement <emph>displayable</emph> but SHALL NOT reject 
						instances because <emph>displayable</emph> is present.
                  </p>
				</div3>
				<div3 id="prop-II.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<p>
						Two non-null instance identifiers are equal if and only if their root is equal, and
						their extensions are both null or equal.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(II x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.root.equal(y.root)
             .and(x.extension.notApplicable.and(y.extension.notApplicable).or(x.extension.equal(y.extension))));
};</pre>
					</exhibit>
					<note role="Implementer">
						<p>
				  	    If the extension property has a null value other than the nullFlavor Unknown, the 
				  	    <emph>II</emph> itself must also be non-null. Implementations may assume that when an
				  	    extension is null (i.e. missing) in a non-null II, the extension has a nullFlavor NotApplicable.
				     
					</p>
					</note>
				</div3>
				<div3 id="prop-II.literal">
					<head>Literal Form</head>
					<p>
						The literal representation for <emph>II</emph> provides a representation for
						the extension and root properties since they are the properties needed
						to test for equality.
					</p>
					<exhibit role="dtdl" id="dtdl-UUID.literal">
						<anchor id="dtdl-UUID.literal"/>
						<caption/>
						<pre>
II.literal ST.SIMPLE {
   UID ":" ST { 
      $.root.equal($1).and($.extension.equal($3)); 
   }
};</pre>
					</exhibit>
				</div3>
			</div2>
			<graphic source="graphics/dtUML-Tel.png" alt="URL And TEL data types"/>
			<div2 id="dt-URL">
				<anchor id="URL"/>
				<head>UniversalResourceLocator (URL) specializes <termref ref="dt-ANY">ANY</termref>
				</head>
				<p>
					<emph role="strong">Definition:     </emph>
					A telecommunications address specified according to Internet standard
					RFC 2396 [<loc href="http://www.ietf.org/rfc/rfc2396.txt" xlink-form="simple" show="embed" actuate="auto"/>]. The
					URI specifies the protocol and the contact point defined by that
					protocol for the resource.  Notable uses of the telecommunication
					address data type are for telephone and telefax numbers, e-mail
					addresses, Hypertext references, FTP references, etc.
				</p>
				<p>
					The Internet standard RFC 2396 [<loc href="http://www.ietf.org/rfc/rfc2396.txt" xlink-form="simple" show="embed" actuate="auto"/>] defines a URI as
					follows:
				</p>
				<quote>
					<p>
						Just as there are many different methods of access to resources, there
						are several schemes for describing the location of such resources.
						The generic syntax for URLs provides a framework for
						new schemes to be established using protocols other than those defined
						in this document.
					</p>
					<p>
						URLs are used to "locate" resources, by providing an abstract
						identification of the resource location. Having located a resource, a
						system may perform a variety of operations on the resource, as might
						be characterized by such words as "access", "update", "replace", "find
						attributes". In general, only the "access" method needs to be
						specified for any URL scheme.
					</p>
					<p>
						By agreement, it is permissable to use a URI in place of a URL. In these
						cases, the resources identified SHOULD be accessible
						by some agreed method. A common use of URI's is to refer to SOAP attachments.
					</p>
				</quote>
				<exhibit role="dtdl" id="dtdl-URL">
					<anchor id="dtdl-URL"/>
					<caption/>
					<pre>
protected type UniversalResourceLocator alias URL specializes ANY {
   CS         scheme;
   ST.SIMPLE  address;
   literal    ST.SIMPLE;
   URL        canonical;
};</pre>
				</exhibit>
				<div3 id="prop-URL.scheme">
					<head>Scheme (scheme) : <termref ref="dt-CS">CS</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						Identifies the protocol used to interpret the address string and 
						to access the resource so addressed.
					</p>
					<p>
						Some URL schemes are registered by the <emph>Internet Assigned Numbers
						Authority</emph> (IANA) [http://www.iana.org], however IANA only
						registers URL schemes that are defined in Internet RFC documents. In
						fact there are a number of URL schemes defined outside RFC documents,
						some of which are registered with the World Wide Web Consortium
						(W3C).<footnote>
							<p>
								The data type of the <emph>scheme</emph> is still <termref ref="dt-CS">CS</termref> and for
								HL7 purposes, the <emph>scheme</emph> is a CNE domain. This appears to be
								at odds with the fact that there is no one official list of URL
								schemes, and so many URL schemes in use may be defined locally.
								However, we cannot allow extension of the <termref ref="dt-URL">URL</termref> scheme
								using the HL7 mechanism of local alternative code systems, which is
								why technically the <emph>scheme</emph> is a <termref ref="dt-CS">CS</termref> data type.
							</p>
						</footnote>
					</p>
					<p>
						Note that while URIs and URLs can be used for all sorts of purposes,
						this specification explicitly limits itself to locatable resources.<footnote>
							<p>
								The W3C definitions of URL and URI are changing. Refer to 
								[<loc href="http://www.w3.org/TR/uri-clarification" xlink-form="simple" show="embed" actuate="auto"/>] for
								further discussion.
							</p>
						</footnote>. Locatable means that the definition of the scheme SHALL
						clearly establish how to locate and access the resource without 
						implementors needing to consult local agreements to determine how 
						the resource is to be accessed. 
					</p>
					<table id="domain-URLScheme">
						<caption>Concept Domain URLScheme. ValueSet OID:  2.16.840.1.113883.11.14866. CodeSystem "URLScheme", OID: 2.16.840.1.113883.5.143, Owner: IANA</caption>
						<thead>
							<tr valign="bottom">
								<th>lvl</th>
								<th>code</th>
								<th>name</th>
								<th>definition</th>
							</tr>
						</thead>
						<tr valign="top">
							<td>1</td>
							<td>ftp</td>
							<td>FTP</td>
							<td>
								<p>The File Transfer Protocol (FTP) [RFC 1738].</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>file</td>
							<td>File</td>
							<td>
								<p>Host-specific local file names [RCF 1738].  Note that the file scheme works only for local files.  There is little use for exchanging local file names between systems, since the receiving system likely will not be able to access the file.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>http</td>
							<td>HTTP</td>
							<td>
								<p>Hypertext Transfer Protocol [RFC 2068].</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>mllp</td>
							<td>MLLP</td>
							<td>
								<p>The traditional HL7 Minimal Lower Layer Protocol. The URL has the form of a common IP URL e.g., mllp://&lt;host&gt;:&lt;port&gt;/ with &lt;host&gt; being the IP address or DNS hostname and &lt;port&gt; being a port number on which the MLLP protocol is served. Mimimal Lower Layer Protocol. See "Transport Specification: MLLP, Release 2" (HL7 V3 Transport specification)</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>mailto</td>
							<td>Mailto</td>
							<td>
								<p>Electronic mail address [RFC 2368].</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>nfs</td>
							<td>NFS</td>
							<td>
								<p>Network File System protocol [RFC 2224].  Some sites use NFS servers to share data files.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>tel</td>
							<td>Telephone</td>
							<td>
								<p>A voice telephone number [http://www.ietf.org/rfc/rfc3966.txt and http://www.ietf.org/rfc/rfc2806.txt].</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>telnet</td>
							<td>Telnet</td>
							<td>
								<p>Reference to interactive sessions [RFC 1738].  Some sites, (e.g., laboratories) have TTY based remote query sessions that can be accessed through telnet.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>cid</td>
							<td>Content ID</td>
							<td>
								<p>cid: is the most common mechanism used in webservices. A cid: reference points from the SOAP body to other content in the mime package in which the SOAP envelope is wrapped</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>hl7-att</td>
							<td>HL7 Attachment</td>
							<td>
								<p>A reference to an HL7 attachment by it's identifier, which takes the form hl7-att:[II.literal], such as hl7-att:2.1.16.3.9.12345.2.39.3:ABC123</p>
							</td>
						</tr>
					</table>
					<div4 id="ht7-att">
						<head>HL7 Attachment Resolution</head>
						<p>
							The scheme hl7-att is used to make references to HL7 Attachments. HL7 attachments
							may be located in the instance itself as an attachment on the Message class, or 
							in some wrapping entity such as a MIME package, or stored elsewhere.
						</p>
						<p>
							The following rules are required to make the hl7-att scheme work:
						</p>
						<list role="ordered">
							<item>
								<p>
									Attachments SHALL be globally uniquely identified. Attachment id is mandatory, and
									an ID SHALL never be re-used. Once assigned, an attachment id SHALL be accosiated
									with exactly one byte-stream as defined for ED.data.
								</p>
							</item>
							<item>
								<p>
									When receiving an attachment, a receiver SHOULD store that attachment for later
									reference. A sender is not required to resend the same attachment if the attachment
									has already been sent.
								</p>
							</item>
							<item>
								<p>
									Attachment references SHALL be resolved against all stored attachments using the
									globally unique attachment identifier in the address.
								</p>
								<note>
									<p>
										When attempting to resolve an attachment reference receiver may need to be able to deal with references to attachments
										that have not been seen previously and will occur later in the document currently being processed. Forward references
										are allowed within an instance, as defined by the applicable ITS, but not to other message instances. 
									</p>
								</note>
							</item>
						</list>
						<p>
							Applications MAY declare conformance to the HL7 Attachment Resolution Protocol, in which case they
							SHALL conform to the rules above. The rules are not mandatory for other applications. The hl7-att scheme
							should only be expected to work with applications that conform to the HL7 Attachment Resolution Protocol.
						</p>
					</div4>
					<!--					<p>
						Similar to the <propref ref="prop-ED.mediaType"/>, HL7 makes
						suggestions about <propname/> values classifying them as
						<emph>required</emph>, <emph>recommended</emph>, <emph>indifferent</emph>,
						and <emph>deprecated</emph>. Any scheme not mentioned has status
						<emph>indifferent</emph>.
					</p>
					<list role="unordered">
						<item>
							<strong>required</strong>: Every HL7 application
							must support at least the required schemes.
						</item>
						<item>
							<strong>recommended</strong>: Other schemes are
							recommended as generally useful to support.
						</item>
						<item>
							<strong>indifferent</strong>: This status means, HL7
							neither forbids nor endorses the use of this scheme.
						</item>
						<item>
							<strong>deprecated</strong>: Deprecated schemes
							should not be used, because the schemes are flawed, because
							there are better alternatives, or because of certain risks. 
						</item>
					</list>
					
					<domain table="URLScheme" source="External - IANA" oid="2.16.840.1.113883.5.143">
						<custom-heading>
							<entry position="1" attribute="code" th="code"/>
							<entry position="1" attribute="printName" th="name"/>
							<entry position="1" attribute="status" th="status"/>
							<entry position="1" element="definition" elposition="1" th="definition"/>
						</custom-heading>
						<entry code="ftp" status="required"/>
						<entry code="x-text-fax" status="required"/>
						<entry code="file" status="deprecated"/>
						<entry code="http" status="required"/>
						<entry code="mllp" status="required"/>
						<entry code="mailto" status="required"/>
						<entry code="modem" status="other"/>
						<entry code="nfs" status="other"/>
						<entry code="tel" status="required"/>
						<entry code="x-text-tel" status="required"/>
						<entry code="telnet" status="other"/>
					</domain> -->
				</div3>
				<div3 id="prop-URL.address">
					<head>Address (address) : <termref ref="dt-ST.SIMPLE">ST.SIMPLE</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The address is a character string whose format is entirely defined by
						the <termref ref="prop-URL.scheme">scheme</termref>.
					</p>
				</div3>
				<div3 id="prop-URL.literal">
					<head>Literal Form</head>
					<p>
						While conceptually URL has the properties scheme and address,
						the common appearance of a URL is as a string literal formed according
						to the Internet standard. The general syntax of the URL literal is:
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
URL.literal ST.SIMPLE {
   URL : /[a-z0-9+.-]+/ ":" ST   { $.scheme.equal($1);
                                   $.address.equal($3); }
};</pre>
					</exhibit>
					<descriptive name="Telephone and FAX Numbers"/>
					<p>
						Note that there is no special data type for telephone numbers,
						telephone numbers are <termref ref="dt-TEL">TEL</termref>s and are specified as <emph>URL</emph>s.
					</p>
					<p>
						The telephone number <emph>URL</emph> is defined in Internet RFC 2806
						[<loc href="http://www.ietf.org/rfc/rfc2806.txt" xlink-form="simple" show="embed" actuate="auto"/>]. Its definition is
						summarized in this subsection. This summary does not override or
						change any of the Internet specification's rulings.
					</p>
					<p>
						The <termref ref="prop-URL.address">address</termref> is the telephone number in
						accordance with ITU-T E.123 <emph>Telephone Network and ISDN
						Operation, Numbering, Routing and Mobile Service: Notation for
						National and International Telephone Numbers (1993)</emph>. While HL7
						does not add or withdraw from the URL specification, the preferred
						subset of the <termref ref="prop-URL.address">address</termref> address syntax is
						given as follows:
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
protected type TelephoneURL alias TelURL specializes URL {
   literal ST.SIMPLE {
      URL                 : /(tel)/ ":" address   { $.scheme.equal($1);
                                                          $.address.equal($3); };
      ST address          : "+" phoneDigits
      ST phoneDigits      : digitOrSeparator phoneDigits
                          | digitOrSeparator
      ST digitOrSeparator : digit
                          | separator;
      ST digit            : /[0..9]/;
      ST separator        : /[().-]/;
      };
};</pre>
					</exhibit>
					<p>
						The global absolute telephone numbers starting with the "+" and
						country code are preferred. Separator characters serve as decoration
						but have no bearing on the meaning of the telephone number. For
						example: "tel:+13176307960" and "tel:+1(317)630-7960" are both the
						same telephone number.
					</p>
				</div3>
				<div3 id="prop-URL.canonical">
					<head>Canonical (canonical) : <termref ref="dt-URL">URL</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The <emph>URL</emph> with any separator or other non-significant characters stripped out of the address. 
					</p>
					<p>
					    The actual characters stripped out depends on the scheme.
					    
						The tel: syntax allows for characters such as () which are syntactical separator characters but
						do not change the actual telephone number. <emph>canonical</emph> strips characters like these out of the 
						address portion.
						
						The email: syntax allows for the inclusion of non-semantic comment in "phrases" and "comments".
						These are removed in the canonical form. Consult RFC 2368 [<loc href="http://www.ietf.org/rfc/rfc2368.txt" xlink-form="simple" show="embed" actuate="auto"/>]
						and RFC 822 [<loc href="http://www.ietf.org/rfc/rfc822.txt" xlink-form="simple" show="embed" actuate="auto"/>] for further information. Headers are 
						also removed.  
					</p>
				</div3>
				<div3 id="prop-URL.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<argument name="x" type="URL"/>
					<p>
						Two nonNull <emph>URL</emph>s are equal if they have the same scheme and canonical address.
						If the address is not known, then it is not known whether the addresses are equal.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(URL x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.scheme.equal(y.scheme).and(x.canonical.address.equal(y.address.canonical)));
};</pre>
					</exhibit>
				</div3>
				<p>
				  Applications SHALL ignore separator characters when comparing <emph>URL</emph>s with tel: scheme.  
				</p>
			</div2>
			<div2 id="dt-TEL">
				<anchor id="TEL"/>
				<head>TelecommunicationAddress (TEL) specializes <termref ref="dt-URL">URL</termref>
				</head>
				<p>
					<emph role="strong">Definition:     </emph>
					A locatable resource that is identified by a URI. The address is specified as a Universal Resource 
					Identifier (URL) qualified by time specification and use codes that 
					help in deciding which address to use for a given time and purpose.
					TEL may be used to designate a retrievable resource such as a web 
					page, a telephone number (voice, fax or some other resource mediated 
					by telecommunication equipment), an e-mail address, or any other locatable
					resource that can be specified by a URL.
				</p>
				<table id="dt-TEL-prop-summary">
					<caption>Property Summary of
      TelecommunicationAddress</caption>
					<col width="79"/>
					<col width="60"/>
					<col width="413"/>
					<thead>
						<tr>
							<th>Name</th>
							<th>Type</th>
							<th>Description</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>
								<termref ref="prop-TEL.use">use</termref>
							</td>
							<td>
								<termref ref="dt-DSET">DSET</termref>&lt;<termref ref="dt-CS">CS</termref>&gt;</td>
							<td>
						One or more codes advising a system or user which telecommunication
						address in a set of like addresses to select for a given
						telecommunication need.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-TEL.capabilities">capabilities</termref>
							</td>
							<td>
								<termref ref="dt-DSET">DSET</termref>&lt;<termref ref="dt-CS">CS</termref>&gt;</td>
							<td>
				    	One or more codes advising a system or user what telecommunication capabilities
				    	are known to be associated with the telecommunication address. 
				    </td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-TEL.useablePeriod">useablePeriod</termref>
							</td>
							<td>
								<termref ref="dt-GTS">GTS</termref>
							</td>
							<td>
						Specifies the periods of time during which the telecommunication
						address can be used.  For a telephone number, this can indicate the
						time of day in which the party can be reached on that telephone.  For
						a web address, it may specify a time range in which the web content is
						promised to be available under the given address.
					</td>
						</tr>
					</tbody>
				</table>
				<p>
					The semantics of a telecommunication address is that a communicating
					entity (the responder) listens and responds to that address, and
					therefore can be contacted by an other communicating entity (the
					initiator).
				</p>
				<p>
					The responder of a telecommunication address may be an automatic
					service that can respond with information (e.g., FTP or HTTP
					services).  In such case a telecommunication address is a reference to
					that information accessible through that address. A telecommunication
					address value can thus be resolved to some information (in the form of
					encapsulated data, <termref ref="dt-ED">ED</termref>).
				</p>
				<exhibit role="dtdl" id="dtdl-TEL">
					<anchor id="dtdl-TEL"/>
					<caption/>
					<pre>
type TelecommunicationAddress alias TEL specializes URL {
   DSET&lt;CS&gt; use;
   DSET&lt;CS&gt; capabilities;
   GTS      useablePeriod;
};</pre>
				</exhibit>
				<p>
					The telecommunication address is an extension of the Universal
					Resource Locator (<termref ref="dt-URL">URL</termref>) specified according to Internet
					standard RFC 2396 [<loc href="http://www.ietf.org/rfc/rfc2396.txt" xlink-form="simple" show="embed" actuate="auto"/>].
					The <termref ref="dt-URL">URL</termref> specifies the protocol and the contact point
					defined by that protocol for the resource. Notable use cases for the
					telecommunication address data type are for telephone and fax numbers,
					e-mail addresses, Hypertext references, FTP references, etc.
				</p>
				<note role="Implementer">
					<p>
					  The proper way to express an unknown phone number is to provide an
					  appropriate value for the scheme property, such as "tel", populate
					  the use property as appropriate, and leave the  address value as null.
					  NullFlavor SHALL also be valued in this case. 
					</p>
				</note>
				<div3 id="prop-TEL.use">
					<head>Use Code (use) : <termref ref="dt-DSET">DSET</termref>&lt;<termref ref="dt-CS">CS</termref>&gt;</head>
					<p>
						<emph role="strong">Definition:     </emph>
						One or more codes advising a system or user which telecommunication
						address in a set of like addresses to select for a given
						telecommunication need.
					</p>
					<table id="domain-TelecommunicationAddressUse">
						<caption>Concept Domain TelecommunicationAddressUse. ValueSet OID:  2.16.840.1.113883.11.201. CodeSystem "TelecommunicationAddressUse", OID: 2.16.840.1.113883.5.1011, Owner: HL7</caption>
						<thead>
							<tr valign="bottom">
								<th>lvl</th>
								<th>code</th>
								<th>name</th>
								<th>definition</th>
							</tr>
						</thead>
						<tr valign="top">
							<td>1</td>
							<td>H</td>
							<td>home address</td>
							<td>
								<p>A communication address at a home, attempted contacts for business purposes might intrude privacy and chances are one will contact family or other household members instead of the person one wishes to call.  Typically used with urgent cases, or if no othe</p>
							</td>
						</tr>
						<tr valign="top">
							<td>2</td>
							<td> HP</td>
							<td>primary home</td>
							<td>
								<p>The primary home, to reach a person after business hours.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>2</td>
							<td> HV</td>
							<td>vacation home</td>
							<td>
								<p>A vacation home, to reach a person while on vacation.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>WP</td>
							<td>work place</td>
							<td>
								<p>An office address. First choice for business related contacts during business hours.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>2</td>
							<td> DIR</td>
							<td>Direct</td>
							<td>
								<p>Indicates a work place address or telecommunication address that reaches the individual or organization directly without intermediaries. For phones, often referred to as a 'private line'.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>2</td>
							<td> PUB</td>
							<td>Public</td>
							<td>
								<p>Indicates a work place address or telecommunication address that is a 'standard' address which may reach a reception service, mail-room, or other intermediary prior to the target entity.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>BAD</td>
							<td>bad address</td>
							<td>
								<p>A flag indicating that the address is bad, in fact, useless.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>TMP</td>
							<td>temporary address</td>
							<td>
								<p>A temporary address, may be good for visit or mailing.  Note that an address history can provide more detailed information.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>AS</td>
							<td>answering service</td>
							<td>
								<p>An automated answering machine used for less urgent cases and if the main purpose of contact is to leave a message or access an automated announcement.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>EC</td>
							<td>emergency contact</td>
							<td>
								<p>A contact specifically designated to be used for emergencies.  This is the first choice in emergencies, independent of any other use codes.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>MC</td>
							<td>mobile contact</td>
							<td>
								<p>A telecommunication device that moves and stays with its owner.  May have characteristics of all other use codes, suitable for urgent matters, not the first choice for routine business.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>PG</td>
							<td>pager</td>
							<td>
								<p>A paging device suitable to solicit a callback or to leave a very short message.</p>
							</td>
						</tr>
					</table>
					<p>
							The telecommunication use code is not a complete classification for
							equipment types or locations. Its main purpose is to suggest or
							discourage the use of a particular telecommunication address. There
							are no easily defined rules that govern the selection of a
							telecommunication address.
						</p>
				</div3>
				<div3 id="prop-TEL.capabilities">
					<head>Telecommunication Equipment Capabilities (capabilities) : <termref ref="dt-DSET">DSET</termref>&lt;<termref ref="dt-CS">CS</termref>&gt;</head>
					<p>
						<emph role="strong">Definition:     </emph>
				    	One or more codes advising a system or user what telecommunication capabilities
				    	are known to be associated with the telecommunication address. 
				    </p>
					<table id="domain-TelecommunicationCapabilities">
						<caption>Concept Domain TelecommunicationCapabilities. ValueSet OID:  [to be assigned]. CodeSystem "TelecommunicationCapabilities", OID: 2.16.840.1.113883.5.1118, Owner: HL7</caption>
						<thead>
							<tr valign="bottom">
								<th>lvl</th>
								<th>code</th>
								<th>name</th>
								<th>definition</th>
							</tr>
						</thead>
						<tr valign="top">
							<td>1</td>
							<td>voice</td>
							<td>Voice</td>
							<td>
								<p>This device can receive voice calls (i.e. talking to another person, or a recording device, or a voice activated computer)</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>fax</td>
							<td>Fax</td>
							<td>
								<p>This device can receive faxes.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>data</td>
							<td>Data</td>
							<td>
								<p>This device can receive data calls (i.e. modem)</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>tty</td>
							<td>Text</td>
							<td>
								<p>This device is a text telephone.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>sms</td>
							<td>SMS</td>
							<td>
								<p>This device can receive SMS messages.</p>
							</td>
						</tr>
					</table>
				</div3>
				<div3 id="prop-TEL.useablePeriod">
					<head>Useable Period (useablePeriod) : <termref ref="dt-GTS">GTS</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						Specifies the periods of time during which the telecommunication
						address can be used.  For a telephone number, this can indicate the
						time of day in which the party can be reached on that telephone.  For
						a web address, it may specify a time range in which the web content is
						promised to be available under the given address.
					</p>
				</div3>
				<div3 id="prop-TEL.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<p>
						The evaluation of equality for <emph>TEL</emph> is the same as the <termref ref="dt-URL">URL</termref> data type. The use and useablePeriod properties
						are excluded from the equality test.<footnote>
							<p>
								This means that values of the type URL and TEL may be equal.
							</p>
						</footnote>
					</p>
				</div3>
				<div3 id="telexamples">
					<head>Examples for TEL</head>
					<p>
						The first example shows a combination work and home phone number.
					</p>
					<exhibit role="example" verbatim="yes">
						<pre>
&lt;tel value="tel:+15556755745" use="H WP"/&gt;</pre>
					</exhibit>
					<p>
						The second example shows a combination work phone number with optional separators and 
						an extension 545.
					</p>
					<exhibit role="example" verbatim="yes">
						<pre>
&lt;tel value="tel:+1(555)6755745;postd=545" use="WP"/&gt;</pre>
					</exhibit>
					<p>
						Note that extensions are not the only use for the post-dial sequence. Consult RFC 2806
						[<loc href="http://www.ietf.org/rfc/rfc2806.txt" xlink-form="simple" show="embed" actuate="auto"/>] for further details. The canonical
						form of this example is:
					</p>
					<exhibit role="example" verbatim="yes">
						<pre>
&lt;tel value="tel:+15556755745;postd=545" use="WP"/&gt;</pre>
					</exhibit>
				</div3>
			</div2>
			<graphic source="graphics/dtUML-Names.png" alt="&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Data types for Postal Address and Entity Names (Person,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Organization, and Trivial Names) are all based on extensions of&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;a character string.&#xA;&#x9;&#x9;&#x9;&#x9;"/>
			<div2 id="dt-ADXP">
				<anchor id="ADXP"/>
				<head>AddressPart (ADXP) specializes <termref ref="dt-SC.NT">SC.NT</termref>
				</head>
				<p>
					<emph role="strong">Definition:     </emph>
					A character string that may have a type-tag signifying its role in the
					address. Typical parts that exist in about every address are street,
					house number, or post box, postal code, city, country but other roles
					may be defined regionally, nationally, or on an enterprise level
					(e.g. in military addresses). Addresses are usually broken up into
					lines, which are indicated by special line-breaking delimiter elements
					(e.g., DEL).
				</p>
				<table id="dt-ADXP-prop-summary">
					<caption>Property Summary of
      AddressPart</caption>
					<col width="79"/>
					<col width="60"/>
					<col width="413"/>
					<thead>
						<tr>
							<th>Name</th>
							<th>Type</th>
							<th>Description</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>
								<termref ref="prop-ADXP.partType">partType</termref>
							</td>
							<td>
								<termref ref="dt-CS">CS</termref>
							</td>
							<td>
						Specifies whether an address part names the street, city, country,
						postal code, post box, etc. If the type is NULL the address part is
						unclassified.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-ADXP.language">language</termref>
							</td>
							<td>
								<termref ref="dt-CS">CS</termref>
							</td>
							<td>
						The human language of the address part, if known and relevant.
					</td>
						</tr>
					</tbody>
				</table>
				<exhibit role="dtdl" id="dtdl-ADXP">
					<anchor id="dtdl-ADXP"/>
					<caption/>
					<pre>
protected type AddressPart alias ADXP specializes SC.NT {
   CS  partType;
};</pre>
				</exhibit>
				<div3 id="prop-ADXP.partType">
					<head>Address Part Type (partType) : <termref ref="dt-CS">CS</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						Specifies whether an address part names the street, city, country,
						postal code, post box, etc. If the type is NULL the address part is
						unclassified.
					</p>
					<table id="domain-AddressPartType">
						<caption>Concept Domain AddressPartType. ValueSet OID:  2.16.840.1.113883.11.10642. CodeSystem "AddressPartType", OID: 2.16.840.1.113883.5.16, Owner: HL7</caption>
						<thead>
							<tr valign="bottom">
								<th>lvl</th>
								<th>code</th>
								<th>name</th>
								<th>definition</th>
							</tr>
						</thead>
						<tr valign="top">
							<td>1</td>
							<td>AL</td>
							<td>address line</td>
							<td>
								<p>An address line is for either an additional locator, a delivery address or a street address.  An address generally has only a delivery address line or a street address line, but not both.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>2</td>
							<td> ADL</td>
							<td>additional locator</td>
							<td>
								<p>This can be a unit designator, such as apartment number, suite number, or floor. There may be several unit designators in an address (e.g., "3rd floor, Appt. 342".)  This can also be a designator pointing away from the location (e.g. Across the street from).</p>
							</td>
						</tr>
						<tr valign="top">
							<td>3</td>
							<td>  UNIT</td>
							<td>unit designator</td>
							<td>
								<p>Indicates the type of specific unit contained within a building or complex.  E.g. Appartment, Floor</p>
							</td>
						</tr>
						<tr valign="top">
							<td>3</td>
							<td>  UNID</td>
							<td>unit identifier</td>
							<td>
								<p>The number or name of a specific unit contained within a building or complex, as assigned by that building or complex.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>2</td>
							<td> DAL</td>
							<td>delivery address line</td>
							<td>
								<p>A delivery address line is frequently used instead of breaking out delivery mode, delivery installation, etc.  An address generally has only a delivery address line or a street address line, but not both.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>3</td>
							<td>  DINSTA</td>
							<td>delivery installation area</td>
							<td>
								<p>The location of the delivery installation, usually a town or city, and is only required if the area is different from the municipality. Area to which mail delivery service is provided from any postal facility or service such as an individual letter carrier, rural route, or postal route.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>3</td>
							<td>  DINSTQ</td>
							<td>delivery installation qualifier</td>
							<td>
								<p>A number, letter or name identifying a delivery installation.  E.g., for Station A, the delivery installation qualifier would be 'A'.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>3</td>
							<td>  DINST</td>
							<td>delivery installation type</td>
							<td>
								<p>Indicates the type of delivery installation (the facility to which the mail will be delivered prior to final shipping via the delivery mode.) Example: post office, letter carrier depot, community mail center, station, etc.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>3</td>
							<td>  DMOD</td>
							<td>delivery mode</td>
							<td>
								<p>Indicates the type of service offered, method of delivery.  For example: post office box, rural route, general delivery, etc.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>3</td>
							<td>  DMODID</td>
							<td>delivery mode identifier</td>
							<td>
								<p>Represents the routing information such as a letter carrier route number.  It is the identifying number of the designator (the box number or rural route number).</p>
							</td>
						</tr>
						<tr valign="top">
							<td>2</td>
							<td> SAL</td>
							<td>street address line</td>
							<td>
								<p>A street address line is frequently used instead of breaking out build number, street name, street type, etc.  An address generally has only a delivery address line or a street address line, but not both.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>3</td>
							<td>  BNR</td>
							<td>building number</td>
							<td>
								<p>The number of a building, house or lot alongside the street.  Also known as "primary street number".  This does not number the street but rather the building.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>4</td>
							<td>   BNN</td>
							<td>building number numeric</td>
							<td>
								<p>The numeric portion of a building number</p>
							</td>
						</tr>
						<tr valign="top">
							<td>4</td>
							<td>   BNS</td>
							<td>building number suffix</td>
							<td>
								<p>Any alphabetic character, fraction or other text that may appear after the numeric portion of a building number</p>
							</td>
						</tr>
						<tr valign="top">
							<td>3</td>
							<td>  STR</td>
							<td>street name</td>
							<td>
								<p>The name of the street, including the type</p>
							</td>
						</tr>
						<tr valign="top">
							<td>4</td>
							<td>   STB</td>
							<td>street name base</td>
							<td>
								<p>The base name of a roadway or artery recognized by a municipality (excluding street type and direction)</p>
							</td>
						</tr>
						<tr valign="top">
							<td>4</td>
							<td>   STTYP</td>
							<td>street type</td>
							<td>
								<p>The designation given to the street.  (e.g. Street, Avenue, Crescent, etc.)</p>
							</td>
						</tr>
						<tr valign="top">
							<td>3</td>
							<td>  DIR</td>
							<td>direction</td>
							<td>
								<p>Direction (e.g., N, S, W, E)</p>
							</td>
						</tr>
						<tr valign="top">
							<td>2</td>
							<td> INT</td>
							<td>intersection</td>
							<td>
								<p>An intersection denotes that the actual address is located at or close to the intersection of two or more streets</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>CAR</td>
							<td>care of</td>
							<td>
								<p>The name of the party who will take receipt at the specified address, and will take on responsibility for ensuring delivery to the target recipient</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>CEN</td>
							<td>census tract</td>
							<td>
								<p>A geographic sub-unit delineated for demographic purposes.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>CNT</td>
							<td>country</td>
							<td>
								<p>Country</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>CPA</td>
							<td>county or parish</td>
							<td>
								<p>A sub-unit of a state or province. (49 of the United States of America use the term "county;" Louisiana uses the term "parish".)</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>DEL</td>
							<td>delimiter</td>
							<td>
								<p>Delimiters are printed without framing white space.  If no value component is provided, the delimiter appears as a line break.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>CTY</td>
							<td>municipality</td>
							<td>
								<p>The name of the city, town, village, or other community or delivery center</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>POB</td>
							<td>post box</td>
							<td>
								<p>A numbered box located in a post station.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>ZIP</td>
							<td>postal code</td>
							<td>
								<p>A postal code designating a region defined by the postal service.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>PRE</td>
							<td>precinct</td>
							<td>
								<p>A subsection of a municipality</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>STA</td>
							<td>state or province</td>
							<td>
								<p>A sub-unit of a country with limited sovereignty in a federally organized country.</p>
							</td>
						</tr>
					</table>
					<p>
					   The hierarchical nature of this code system shows composition. E.g. "Street Name" is part of "Street Address Line"
					</p>
					<p>
					  Some Address Part Types are associated with a Domain, and the code of SC may be valued in these cases. 
					  If no Domain is associated with the address part type, then the code may not be valued. The text 
					  content of the part is not restricted by the vocabulary domain unless constrained in this way by a realm.
					</p>
					<table>
						<caption>Domain Mappings for Part Type</caption>
						<col width="2.00" span="1"/>
						<col width="3.00" span="1"/>
						<thead>
							<tr>
								<th rowspan="1" colspan="1">Part Type</th>
								<th rowspan="1" colspan="1">Concept Domain</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td rowspan="1" colspan="1">UNIT</td>
								<td rowspan="1" colspan="1">AddressPartUnitType</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">DINST</td>
								<td rowspan="1" colspan="1">AddressPartDeliveryInstallationType</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">DMOD</td>
								<td rowspan="1" colspan="1">AddressPartDeliveryMode</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">STTYP</td>
								<td rowspan="1" colspan="1">AddressPartStreetType</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">CNT</td>
								<td rowspan="1" colspan="1">Country</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">STA</td>
								<td rowspan="1" colspan="1">AddressPartState</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">CPA</td>
								<td rowspan="1" colspan="1">AddressPartCounty</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">CTY</td>
								<td rowspan="1" colspan="1">AddressPartCity</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">DIR</td>
								<td rowspan="1" colspan="1">AddressPartDirection</td>
							</tr>
						</tbody>
					</table>
					<p>
						The concept domain Country is bound to ISO 3166. ISO 3166 is a code system with the
						OID 1.0.3166.1.2 that defines 2 letter, 3 letter, and numerical codes for each country. HL7
						defines a universal value set with the OID [oid] that includes all 3 types of code, so 
						that all 3 types of code may be used. Realms are able to restrict the use of country 
						to a particular type of code by binding the domain Country to a more restrictive 
						value set.
					</p>
					<p>
					  The other concept domains are not bound
					  to any particular value set or code system, but realms may specify particular bindings.
					  Note that ISO 3166 also specifies country sub-divisions, and realms should consider 
					  using these sub-divisions where possible. 
					</p>
					<note>
						<p>
							 	Please consult the "Core Principles of V3 Models" specification ([<loc href="../coreprinciples/v3modelcoreprinciples.htm" xlink-form="simple" show="embed" actuate="auto"/>])
								for a discussion of the relationship between code systems and instance identifiers for concepts such as country. 
							</p>
					</note>
				</div3>
				<div3 id="prop-ADXP.language">
					<head>Language (language) : <termref ref="dt-CS">CS</termref>, inherited from <termref ref="dt-ED">ED</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The human language of the address part, if known and relevant.
					</p>
					<p>
						While values of type <emph>ADXP</emph> may be assigned a language, the meaning of the part is not 
						dependent on the language, and applications SHALL not be required to indicate the linguistic origin of 
						any address part. Like <termref ref="dt-ST">ST</termref>, language is not part of the equality
						test for <emph>ADXP</emph>.
					</p>
				</div3>
				<div3 id="prop-ADXP.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<argument name="x" type="ADXP"/>
					<p>
						Two nonNull <emph>ADXP</emph>s are equal if they have the same partType, and
						if the other <termref ref="dt-ED">ED</termref> equality criteria are met.<footnote>
							<p>
								This means that values of the values of the type ADXP can not be equal with ED, ST, or SC values.
							</p>
						</footnote>
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(ADXP x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.partType.equal(y.partType).and(((ED)x).equal((ED)y)));
};</pre>
					</exhibit>
				</div3>
			</div2>
			<div2 id="dt-AD">
				<anchor id="AD"/>
				<head>PostalAddress (AD) specializes <termref ref="dt-LIST">LIST</termref>&lt;<termref ref="dt-ADXP">ADXP</termref>&gt;</head>
				<p>
					<emph role="strong">Definition:     </emph>
					Mailing and home or office addresses. A sequence of address parts,
					such as street or post office box, city, postal code, country, etc.
				</p>
				<p>
					<emph>AD</emph> is primarily used to communicate data that will allow
					printing mail labels, that will allow a person to physically visit
					that address. The postal address data type is not supposed to be a
					container for additional information that might be useful for finding
					geographic locations (e.g., GPS coordinates) or for performing
					epidemiological studies. Such additional information is captured by
					other, more appropriate HL7 elements.
				</p>
				<table id="dt-AD-prop-summary">
					<caption>Property Summary of
      PostalAddress</caption>
					<col width="79"/>
					<col width="60"/>
					<col width="413"/>
					<thead>
						<tr>
							<th>Name</th>
							<th>Type</th>
							<th>Description</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>
								<termref ref="prop-AD.use">use</termref>
							</td>
							<td>
								<termref ref="dt-DSET">DSET</termref>&lt;<termref ref="dt-CS">CS</termref>&gt;</td>
							<td>
						A set of codes advising a system or user which address in a set of
						like addresses to select for a given purpose.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-AD.useablePeriod">useablePeriod</termref>
							</td>
							<td>
								<termref ref="dt-GTS">GTS</termref>
							</td>
							<td>
						A General Timing Specification (GTS) specifying the periods of time
						during which the address can be used.  This is used to specify
						different addresses for different times of the week or year.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-AD.isNotOrdered">isNotOrdered</termref>
							</td>
							<td>
								<termref ref="dt-BL">BL</termref>
							</td>
							<td>
						A boolean value specifying whether the order of the address parts is known
						or not. While the address parts are always a Sequence, the order in which
						they are presented may or may not be known. Where this matters, the
						isNotOrdered property can be used to convey this information.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-AD.formatted">formatted</termref>
							</td>
							<td>
								<termref ref="dt-ST.NT">ST.NT</termref>
							</td>
							<td>
						A character string value with the address formatted in lines and with
						proper spacing. This is only a semantic property to define the
						function of some of the address part types.<footnote>
									<p>
								Remember that semantic properties are bare of all control flow
								semantics. The <termref ref="prop-AD.formatted">formatted</termref> could be implemented
								as a "procedure" that would "return" the formatted address, but it
								would not usually be a variable to which one could assign a formatted
								address. However, HL7 does not define applications but only the
								semantics of exchanged data values. Hence, the semantic model
								abstracts from concepts like "procedure", "return", and "assignment"
								but speaks only of property and value.
							</p>
								</footnote>
							</td>
						</tr>
					</tbody>
				</table>
				<p>
					Addresses are conceptualized as text with added logical mark-up. The
					mark-up may break the address into lines and may describe in detail
					the role of each address part if it is known. Address parts occur in
					the address in the order in which they would be printed on a mailing
					label. The approach is similar to HTML or XML markup of text (but it
					is not technically limited to XML representations).
				</p>
				<p>
					Addresses are essentially sequences of address parts, but add a "use"
					code and a valid time range for information about if and when the
					address can be used for a given purpose.
				</p>
				<exhibit role="dtdl" id="dtdl-AD">
					<anchor id="dtdl-AD"/>
					<caption/>
					<pre>
type PostalAddress alias AD specializes LIST&lt;ADXP&gt; {
   DSET&lt;CS&gt; use;
   GTS      useablePeriod;
   BL       isNotOrdered;
   ST.NT    formatted;
};</pre>
				</exhibit>
				<p>
						The correct presentation order of the parts is realm dependent and may not be the same between addresses 
						from different countries or realms. Patients regularly travel between realms, so realm specified ordering
						and constraints need to account for addresses from other realms as well. 
					</p>
				<div3 id="prop-AD.use">
					<head>Use Code (use) : <termref ref="dt-DSET">DSET</termref>&lt;<termref ref="dt-CS">CS</termref>&gt;</head>
					<p>
						<emph role="strong">Definition:     </emph>
						A set of codes advising a system or user which address in a set of
						like addresses to select for a given purpose.
					</p>
					<table id="domain-PostalAddressUse">
						<caption>Concept Domain PostalAddressUse. ValueSet OID:  2.16.840.1.113883.11.190. CodeSystem "PostalAddressUse", OID: 2.16.840.1.113883.5.1012, Owner: HL7</caption>
						<thead>
							<tr valign="bottom">
								<th>lvl</th>
								<th>code</th>
								<th>name</th>
								<th>definition</th>
							</tr>
						</thead>
						<tr valign="top">
							<td>1</td>
							<td>--</td>
							<td>
								<emph>AddressUse</emph>
							</td>
							<td/>
						</tr>
						<tr valign="top">
							<td>2</td>
							<td> H</td>
							<td>home address</td>
							<td>
								<p>A communication address at a home, attempted contacts for business purposes might intrude privacy and chances are one will contact family or other household members instead of the person one wishes to call.  Typically used with urgent cases, or if no other contacts are available.
</p>
							</td>
						</tr>
						<tr valign="top">
							<td>3</td>
							<td>  HP</td>
							<td>primary home</td>
							<td>
								<p>The primary home, to reach a person after business hours.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>3</td>
							<td>  HV</td>
							<td>vacation home</td>
							<td>
								<p>A vacation home, to reach a person while on vacation.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>2</td>
							<td> WP</td>
							<td>work place</td>
							<td>
								<p>An office address. First choice for business related contacts during business hours.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>3</td>
							<td>  DIR</td>
							<td>Direct</td>
							<td>
								<p>Indicates a work place address or telecommunication address that reaches the individual or organization directly without intermediaries. For phones, often referred to as a 'private line'.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>3</td>
							<td>  PUB</td>
							<td>Public</td>
							<td>
								<p>Indicates a work place address or telecommunication address that is a 'standard' address which may reach a reception service, mail-room, or other intermediary prior to the target entity.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>2</td>
							<td> BAD</td>
							<td>bad address</td>
							<td>
								<p>A flag indicating that the address is bad, in fact, useless.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>2</td>
							<td> TMP</td>
							<td>temporary address</td>
							<td>
								<p>A temporary address, may be good for visit or mailing.  Note that an address history can provide more detailed information.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>2</td>
							<td> PHYS</td>
							<td>physical visit address</td>
							<td>
								<p>Used primarily to visit an address.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>2</td>
							<td> PST</td>
							<td>postal address</td>
							<td>
								<p>Used to send mail.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>--</td>
							<td>
								<emph>AddressRepresentationUse</emph>
							</td>
							<td>
								<p>Identifies the different representations of a Address.  The representation may affect how the address is used.  (E.g. use of Ideographic for formal communications.)</p>
							</td>
						</tr>
						<tr valign="top">
							<td>2</td>
							<td> ABC</td>
							<td>Alphabetic</td>
							<td>
								<p>Alphabetic transcription of name (Japanese: romaji)</p>
							</td>
						</tr>
						<tr valign="top">
							<td>2</td>
							<td> IDE</td>
							<td>Ideographic</td>
							<td>
								<p>Ideographic representation of name (e.g., Japanese kanji, Chinese characters)</p>
							</td>
						</tr>
						<tr valign="top">
							<td>2</td>
							<td> SYL</td>
							<td>Syllabic</td>
							<td>
								<p>Syllabic transcription of name (e.g., Japanese kana, Korean hangul)</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>SRCH</td>
							<td>
								<emph>Search Type Uses</emph>
							</td>
							<td>
								<p>A name intended for use in searching or matching.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>2</td>
							<td> SNDX</td>
							<td>Soundex</td>
							<td>
								<p>An address spelled according to the SoundEx algorithm.</p>
							</td>
						</tr>
						<tr valign="top">
							<td>2</td>
							<td> PHON</td>
							<td>phonetic</td>
							<td>
								<p>The address as understood by the data enterer, i.e. a close approximation of a phonetic spelling of the address, not based on a phonetic algorithm.</p>
							</td>
						</tr>
					</table>
					<p>
						An address without specific use code might be a default address useful
						for any purpose, but an address with a specific use code would be
						preferred for that respective purpose.
					</p>
					<p>
						An address with a use of "H" and a nullFlavor of NotApplicable means that the concept of 
						a home address does not apply; i.e. that a person has no fixed place of abode.
					</p>
				</div3>
				<div3 id="prop-AD.useablePeriod">
					<head>Useable Period (useablePeriod) : <termref ref="dt-GTS">GTS</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						A General Timing Specification (GTS) specifying the periods of time
						during which the address can be used.  This is used to specify
						different addresses for different times of the week or year.
					</p>
				</div3>
				<div3 id="prop-AD.isNotOrdered">
					<head>Is Not Ordered (isNotOrdered) : <termref ref="dt-BL">BL</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						A boolean value specifying whether the order of the address parts is known
						or not. While the address parts are always a Sequence, the order in which
						they are presented may or may not be known. Where this matters, the
						isNotOrdered property can be used to convey this information.
					</p>
					<p>
						The default isNotOrdered is false: the order of address parts is considered meaningful by default.
					</p>
				</div3>
				<div3 id="prop-AD.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<p>
						Two address values are considered equal if both contain the same
						address parts, independent of ordering. Use code, useablePeriod, and isNotOrdered are
						excluded from the equality test. <footnote>
							<p>
						   This definition follows from the semantics of the address; Although some delivery systems may become
						   confused if the parts are re-ordered, especially in the absense of the part type semantics (for
						   instance in a formatted literal address), it is not possible to change from one valid address to
						   a different valid address by reordering the parts; for this reason equality simply depends on the
						   parts, in any order, irrespective of the valid time, use or IsNotOrdered flag.
						</p>
						</footnote>
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(AD x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal((
      forall(ADXP p) where x.contains(p) {
	     y.contains(p);
	     }).and(
            forall(ADXP p) where y.contains(p) {
	           x.contains(p);
	           }));
};</pre>
					</exhibit>
					<p>
						Note that two values that refer to the same address but that are encoded using different address parts 
						(perhaps to different levels of detail) would not be considered equal.						
					</p>
				</div3>
				<div3 id="prop-AD.formatted">
					<head>Formatting Address (formatted) : <termref ref="dt-ST.NT">ST.NT</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						A character string value with the address formatted in lines and with
						proper spacing. This is only a semantic property to define the
						function of some of the address part types.<footnote>
							<p>
								Remember that semantic properties are bare of all control flow
								semantics. The <termref ref="prop-AD.formatted">formatted</termref> could be implemented
								as a "procedure" that would "return" the formatted address, but it
								would not usually be a variable to which one could assign a formatted
								address. However, HL7 does not define applications but only the
								semantics of exchanged data values. Hence, the semantic model
								abstracts from concepts like "procedure", "return", and "assignment"
								but speaks only of property and value.
							</p>
						</footnote>
					</p>
					<p>
						<emph>AD</emph>'s main purpose is to capture postal addresses,
						such that one can visit that address or send mail to it. Humans will
						look at addresses in printed form, such as on a mailing label. The
						<emph>AD</emph> data type defines precise rules of how its data is
						formatted.<footnote>
							<p>
								These rules for formatting addresses are part of the semantics of
								addresses because addresses are primarily defined as text displayed or
								printed and consumed by humans. Other uses (e.g., epidemiology) are
								secondary &#8212; although not forbidden, the AD
								data type might not serve these other use cases very well, and HL7
								defines better ways to handle these use cases. Note that these
								formatting rules are not ITS issues, since this formatting applies
								to presentations for humans whereas ITS specifications are
								presentations for computer interchange.
							</p>
						</footnote>
					</p>
					<p>
						Addresses are ordered lists of address parts. Each address part is
						printed in the order of the list from left to right and top to bottom
						(or in any other language-related reading direction, which to
						determine is outside the scope of this specification).  Every address
						part value is printed. Most address parts are framed by white
						space. The following six rules govern the setting of whitespace.
					</p>
					<list role="ordered">
						<item>
							Whitespace never accumulates, i.e. two subsequent spaces are the same
							as one. Subsequent line breaks can be reduced to one. Whitespace
							around a line break is not significant.
						</item>
						<item>
							Literals may contain explicit whitespace, subject to the same white
							space reduction rules. There is no notion of a literal line break
							within the text of a single address part.
						</item>
						<item>
							Leading and trailing explicit whitespace is insignificant in all
							address parts, except for delimiter (DEL) address parts.
						</item>
						<item>
							By default, an address part is surrounded by implicit whitespace.
						</item>
						<item>
							Delimiter (DEL) address parts are not surrounded by any implicit white
							space.
						</item>
						<item>
							Leading and trailing explicit whitespace is significant in delimiter
							(DEL) address parts.
						</item>
					</list>
					<p>
						This means that all address parts are generally surrounded by white
						space, but whitespace does never accumulate. Delimiters are never
						surrounded by implicit whitespace and every whitespace contributed
						by preceding or succeeding address parts is discarded, whether it was
						implicit or explicit.
					</p>
				</div3>
				<div3 id="ADExamples">
					<head>AD Examples</head>
					<p>
						For examples of names, please consult the ISO datatypes (ISO 21090).
					</p>
				</div3>
			</div2>
			<div2 id="dt-ENXP">
				<anchor id="ENXP"/>
				<head>EntityNamePart (ENXP) specializes <termref ref="dt-SC.NT">SC.NT</termref>
				</head>
				<p>
					<emph role="strong">Definition:     </emph>
					A character string token representing a part of a name. May have a
					type code signifying the role of the part in the whole entity name,
					and a qualifier code for more detail about the name part type.
					Typical name parts for person names are given names, and family names,
					titles, etc.
				</p>
				<table id="dt-ENXP-prop-summary">
					<caption>Property Summary of
      EntityNamePart</caption>
					<col width="79"/>
					<col width="60"/>
					<col width="413"/>
					<thead>
						<tr>
							<th>Name</th>
							<th>Type</th>
							<th>Description</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>
								<termref ref="prop-ENXP.partType">partType</termref>
							</td>
							<td>
								<termref ref="dt-CS">CS</termref>
							</td>
							<td>
						Indicates whether the name part is a given name, family name, prefix,
						suffix, etc.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-ENXP.qualifier">qualifier</termref>
							</td>
							<td>
								<termref ref="dt-DSET">DSET</termref>&lt;<termref ref="dt-CS">CS</termref>&gt;</td>
							<td>
						The qualifier is a set of codes each of which specifies a certain
						subcategory of the name part in addition to the main name part type.
						For example, a given name may be flagged as a nickname, a family name
						may be a pseudonym or a name of public records.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-ENXP.language">language</termref>
							</td>
							<td>
								<termref ref="dt-CS">CS</termref>
							</td>
							<td>
						The human language of the name part, if known and relevant.
					</td>
						</tr>
					</tbody>
				</table>
				<exhibit role="dtdl" id="dtdl-ENXP">
					<anchor id="dtdl-ENXP"/>
					<caption/>
					<pre>
protected type EntityNamePart alias ENXP specializes SC.NT {
   CS       partType;
   DSET&lt;CS&gt;  qualifier;
};</pre>
				</exhibit>
				<note>
					<p>
						Note that as a specialization of <termref ref="dt-ST">ST</termref>, a non-null <emph>ENXP</emph> must have some
						content. If no content is known, a nullFlavor must be supplied, though the normal usage
						would be to omit the part altogether (with an implicit nullFlavor of NI). 
					</p>
				</note>
				<div3 id="prop-ENXP.partType">
					<head>Name Part Type (partType) : <termref ref="dt-CS">CS</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						Indicates whether the name part is a given name, family name, prefix,
						suffix, etc.
					</p>
					<table id="domain-EntityNamePartTypeR2">
						<caption>Concept Domain EntityNamePartTypeR2. ValueSet OID:  [to be assigned]. CodeSystem "EntityNamePartTypeR2", OID: [to be assigned], Owner: HL7</caption>
						<thead>
							<tr valign="bottom">
								<th>lvl</th>
								<th>code</th>
								<th>name</th>
								<th>definition</th>
							</tr>
						</thead>
					</table>
					<p>
						Not every name part must have a type code; if the type code is
						unknown, not applicable, or simply undefined this is expressed by a
						NULL value (type.isNull). For example, a name may be "Rogan Sulma" and
						it may not be clear which one is a given name or which is a last name,
						or whether Rogan may be a title.
					</p>
					<p>
						When a name is hyphenated, such as Mary-Ann, it may be ambigious whether
						to use a delimiter separating two name parts, or a single name part with 
						a hyphen in it. As a rule of thumb, if each name part should contribute an
						initial when the name is presented as initials, then a delimiter SHOULD be 
						used to separate two parts.
					</p>
					<p>
						Entity names are conceptualized as text with added mark-up. The
						mark-up may describe in detail the role of each name part if it is
						known. Name parts occur in the order in which they would be printed on
						a mailing label. The model is similar to HTML or XML markup of text.
					</p>
					<p>
					  Some Entity Name Part Types are associated with a Domain, and the code of SC may be valued in these cases. 
					  If no Domain is associated with the address part type, then the code may not be valued. The text 
					  content of the part is not restricted by the vocabulary domain unless constrained in this way by a realm.
					</p>
					<table>
						<caption>Domain Mappings for Part Type</caption>
						<col width="2.00" span="1"/>
						<col width="3.00" span="1"/>
						<thead>
							<tr>
								<th rowspan="1" colspan="1">Part Type</th>
								<th rowspan="1" colspan="1">Domain</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td rowspan="1" colspan="1">PFX</td>
								<td rowspan="1" colspan="1">EntityNamePrefix</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">SFX</td>
								<td rowspan="1" colspan="1">EntityNameSuffix</td>
							</tr>
						</tbody>
					</table>
					<p>
					  These domains are not bound to any particular value set, but realms may specify particular bindings.
					</p>
				</div3>
				<div3 id="prop-ENXP.qualifier">
					<head>Qualifier (qualifier) : <termref ref="dt-DSET">DSET</termref>&lt;<termref ref="dt-CS">CS</termref>&gt;</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The qualifier is a set of codes each of which specifies a certain
						subcategory of the name part in addition to the main name part type.
						For example, a given name may be flagged as a nickname, a family name
						may be a pseudonym or a name of public records.
					</p>
					<table id="domain-EntityNamePartQualifierR2">
						<caption>Concept Domain EntityNamePartQualifierR2. ValueSet OID:  [to be assigned]. CodeSystem "EntityNamePartQualifierR2", OID: [to be assigned]=, Owner: HL7</caption>
						<thead>
							<tr valign="bottom">
								<th>lvl</th>
								<th>code</th>
								<th>name</th>
								<th>definition</th>
							</tr>
						</thead>
					</table>
					<note>
						<p>Note: The Scandinavian &#8220;Mellomnavn / Mellannamn&#8221; translates to &#8220;middle name&#8221; but does not match the English &#8216;middle name&#8217; concept. The general English &#8216;middle name&#8217; concept is simply all of the given names after the first.</p>
					</note>
					<note>
						<p>Note: The qualifiers PFX and SFX are mutually incompatible. It is not legal to use both on the same part type. It is not necessary to label the name part following a prefix as a suffix or vice versa.</p>
					</note>
					<note>
						<p>Initials are allowed to be more than one letter specifically to cater for linguistic norms in the applicable language. Abbreviations, such as Dr. for Doctor are not initials.</p>
					</note>
					<p>
					    The following table summarizes which qualifiers may be used with which part types:
					</p>
					<table id="EN-use-qualifier-combinations" width="1px">
						<caption>PartType &amp; Qualifier Combinations</caption>
						<col width="0.1" span="1"/>
						<col width="0.1" span="1"/>
						<col width="0.1" span="1"/>
						<col width="0.1" span="1"/>
						<col width="0.1" span="1"/>
						<col width="0.1" span="1"/>
						<thead>
							<tr>
								<td rowspan="1" colspan="1"> </td>
								<td rowspan="1" colspan="1">FAM (Family)</td>
								<td rowspan="1" colspan="1">GIV (Given)</td>
								<td rowspan="1" colspan="1">TITLE</td>
								<td rowspan="1" colspan="1">DEL (Delimiter)</td>
								<td rowspan="1" colspan="1">null</td>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td rowspan="1" colspan="1">LS (Legal Status)</td>
								<td rowspan="1" colspan="1"/>
								<td rowspan="1" colspan="1"/>
								<td rowspan="1" colspan="1">&#8225;</td>
								<td rowspan="1" colspan="1"/>
								<td rowspan="1" colspan="1">&#8225; </td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">BR (Birth)</td>
								<td rowspan="1" colspan="1">&#8225;&#8225;</td>
								<td rowspan="1" colspan="1">&#8225;&#8225;</td>
								<td rowspan="1" colspan="1"/>
								<td rowspan="1" colspan="1"/>
								<td rowspan="1" colspan="1">&#8225; </td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">AD (Acquired)</td>
								<td rowspan="1" colspan="1">&#8225;&#8225;</td>
								<td rowspan="1" colspan="1">&#8225;&#8225;</td>
								<td rowspan="1" colspan="1"/>
								<td rowspan="1" colspan="1"/>
								<td rowspan="1" colspan="1">&#8225; </td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">SP (Spouse)</td>
								<td rowspan="1" colspan="1">&#8225;&#8225;</td>
								<td rowspan="1" colspan="1">&#8225; </td>
								<td rowspan="1" colspan="1"/>
								<td rowspan="1" colspan="1"/>
								<td rowspan="1" colspan="1">&#8225; </td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">MID (Middle Name)</td>
								<td rowspan="1" colspan="1">&#8225;&#8225;</td>
								<td rowspan="1" colspan="1">&#8225;&#8225;</td>
								<td rowspan="1" colspan="1"/>
								<td rowspan="1" colspan="1"/>
								<td rowspan="1" colspan="1">&#8225; </td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">CL (Call Me)</td>
								<td rowspan="1" colspan="1">&#8225; </td>
								<td rowspan="1" colspan="1">&#8225;&#8225;</td>
								<td rowspan="1" colspan="1"/>
								<td rowspan="1" colspan="1"/>
								<td rowspan="1" colspan="1">&#8225; </td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">IN (initial)</td>
								<td rowspan="1" colspan="1">&#8225;&#8225; </td>
								<td rowspan="1" colspan="1">&#8225;&#8225;</td>
								<td rowspan="1" colspan="1"/>
								<td rowspan="1" colspan="1"/>
								<td rowspan="1" colspan="1">&#8225; </td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">PFX (Prefix)</td>
								<td rowspan="1" colspan="1">&#8225;&#8225;</td>
								<td rowspan="1" colspan="1">&#8225;&#8225;</td>
								<td rowspan="1" colspan="1">&#8225;&#8225;</td>
								<td rowspan="1" colspan="1"/>
								<td rowspan="1" colspan="1">&#8225; </td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">SFX (Suffix)</td>
								<td rowspan="1" colspan="1">&#8225;&#8225;</td>
								<td rowspan="1" colspan="1">&#8225;&#8225;</td>
								<td rowspan="1" colspan="1">&#8225;&#8225;</td>
								<td rowspan="1" colspan="1"/>
								<td rowspan="1" colspan="1">&#8225; </td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">AC (academic)</td>
								<td rowspan="1" colspan="1"/>
								<td rowspan="1" colspan="1"/>
								<td rowspan="1" colspan="1">&#8225;&#8225;</td>
								<td rowspan="1" colspan="1"/>
								<td rowspan="1" colspan="1">&#8225; </td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">PR (professional)</td>
								<td rowspan="1" colspan="1"/>
								<td rowspan="1" colspan="1"/>
								<td rowspan="1" colspan="1">&#8225;&#8225;</td>
								<td rowspan="1" colspan="1"/>
								<td rowspan="1" colspan="1">&#8225; </td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">NB (nobility)</td>
								<td rowspan="1" colspan="1"/>
								<td rowspan="1" colspan="1"/>
								<td rowspan="1" colspan="1">&#8225;&#8225;</td>
								<td rowspan="1" colspan="1"/>
								<td rowspan="1" colspan="1">&#8225; </td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">HON (Honorific)</td>
								<td rowspan="1" colspan="1"/>
								<td rowspan="1" colspan="1"/>
								<td rowspan="1" colspan="1">&#8225;&#8225;</td>
								<td rowspan="1" colspan="1"/>
								<td rowspan="1" colspan="1">&#8225; </td>
							</tr>
						</tbody>
					</table>
					<p>&#8225; = This combination is allowed.</p>
					<p>&#8225;&#8225; = This combination is allowed, and it is expected that this combination will be encountered in practice.</p>
					<p>
						See also the note under <termref ref="prop-EN.use">EN.use</termref> for further rules.
					</p>
				</div3>
				<div3 id="prop-ENXP.language">
					<head>Language (language) : <termref ref="dt-CS">CS</termref>, inherited from <termref ref="dt-ED">ED</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The human language of the name part, if known and relevant.
					</p>
					<p>
						While values of type <emph>ENXP</emph> may be assigned a language, the meaning of the part is not
						dependent on the language, and applications SHALL not be required to indicate the linguistic origin of
						any name part. Like <termref ref="dt-ST">ST</termref>, language is not part of the equality
						test for <emph>ENXP</emph>.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(ENXP x) {
   x.language.notApplicable;
};</pre>
					</exhibit>
					<p>
						Values of type <emph>ENXP</emph> do not have any assigned language. Though names may contain
						words and concepts from a particular language, the meaning of the name part is not dependent
						on the language.
					</p>
				</div3>
				<div3 id="prop-ENXP.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<argument name="x" type="ADXP"/>
					<p>
						Two nonNull <emph>ENXP</emph>s are equal if they have the same partType, and
						if the other <termref ref="dt-ED">ED</termref> equality criteria are met. The
						qualifier property is excluded from the equality test.<footnote>
							<p>
								This means that values of the values of the type ENXP can not be equal with ED, ST, or SC values.
							</p>
						</footnote>
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(ENXP x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.partType.equal(y.partType).and(((ED)x).equal((ED)y)));
};</pre>
					</exhibit>
				</div3>
			</div2>
			<div2 id="dt-EN">
				<anchor id="EN"/>
				<head>EntityName (EN) specializes <termref ref="dt-LIST">LIST</termref>&lt;<termref ref="dt-ENXP">ENXP</termref>&gt;</head>
				<p>
					<emph role="strong">Definition:     </emph>
					A name for a person, organization, place or thing. A sequence of name
					parts, such as given name or family name, prefix, suffix, etc.
					Examples for entity name values are "Jim Bob Walton, Jr.", "Health
					Level Seven, Inc.", "Lake Tahoe", etc. An entity name may be as simple
					as a character string or may consist of several entity name parts,
					such as, "Jim", "Bob", "Walton", and "Jr.", "Health Level Seven" and
					"Inc.", "Lake" and "Tahoe".
				</p>
				<table id="dt-EN-prop-summary">
					<caption>Property Summary of
      EntityName</caption>
					<col width="79"/>
					<col width="60"/>
					<col width="413"/>
					<thead>
						<tr>
							<th>Name</th>
							<th>Type</th>
							<th>Description</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>
								<termref ref="prop-EN.use">use</termref>
							</td>
							<td>
								<termref ref="dt-DSET">DSET</termref>&lt;<termref ref="dt-CS">CS</termref>&gt;</td>
							<td>
						A set of codes advising a system or user which name in a set of
						names to select for a given purpose.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-EN.validTime">validTime</termref>
							</td>
							<td>
								<termref ref="dt-IVL">IVL</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;</td>
							<td>
						An interval of time specifying the time during which the name is or
						was used for the entity. This accommodates the fact that people change
						names for people, places and things.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-EN.canonical">canonical</termref>
							</td>
							<td>
								<termref ref="dt-EN">EN</termref>
							</td>
							<td>
						The Entity Name with a standard ordering imposed on the parts.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-EN.formatted">formatted</termref>
							</td>
							<td>
								<termref ref="dt-ST.NT">ST.NT</termref>
							</td>
							<td>
						A character string value with the entity name formatted with
						proper spacing. This is only a semantic property to define the
						function of some of the name part types.<footnote>
									<p>
								Remember that semantic properties are bare of all control flow
								semantics. The <termref ref="prop-EN.formatted">formatted</termref> could be implemented
								as a "procedure" that would "return" the formatted name, but it would
								not usually be a variable to which one could assign a formatted
								name. However, HL7 does not define applications but only the semantics
								of exchanged data values. Hence, the semantic model abstracts from
								concepts like "procedure", "return", and "assignment" but speaks only
								of property and value.
							</p>
								</footnote>
							</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-EN.demotionST">demotion</termref>
							</td>
							<td>
								<termref ref="dt-ST.NT">ST.NT</termref>
							</td>
							<td/>
						</tr>
					</tbody>
				</table>
				<p>
					Entity names are conceptualized as text with added logical mark-up.
					Name parts occur in a natural order in which they would be displayed,
					as opposed to in a order detemined by name part. The ordering of the
					name parts is significant a feature that replaces the need for a
					separate "display name" property. Applications may change that
					ordering of name parts to account for their user's customary ordering
					of name parts. The approach is similar to HTML or XML markup of text
					(but it is not technically limited to XML representations).
				</p>
				<p>
					Entity names are essentially sequences of entity name parts, but add a
					"use" code and a valid time range for information about when the name
					was used and how to choose between multiple aliases that may be valid
					at the same point in time.
				</p>
				<exhibit role="dtdl" id="dtdl-EN">
					<anchor id="dtdl-EN"/>
					<caption/>
					<pre>
type EntityName alias EN specializes LIST&lt;ENXP&gt; {
      DSET&lt;CS&gt; use;
      IVL&lt;TS&gt;  validTime;
      EN       canonical;
      ST.NT    formatted;
   
  demotion   ST.NT;
  promotion  TN (ST x);
};</pre>
				</exhibit>
				<p>
					The existence of the use and qualifier codes does not mean that names must 
					always be fully encoded. For example, in most contexts, as a matter of cultural 
					practice, prefixes will simply be recorded as part of the family name to which 
					they are corrected. Some specific implementation negotiation may always be 
					required to clarify how to deal with implementations that have different policies 
					about how names are represented using the facilities of the name.
				</p>
				<div3 id="prop-EN.use">
					<head>Use Code (use) : <termref ref="dt-DSET">DSET</termref>&lt;<termref ref="dt-CS">CS</termref>&gt;</head>
					<p>
						<emph role="strong">Definition:     </emph>
						A set of codes advising a system or user which name in a set of
						names to select for a given purpose.
					</p>
					<table id="domain-EntityNameUseR2">
						<caption>Concept Domain EntityNameUseR2. ValueSet OID:  [to be assigned]. CodeSystem "EntityNameUseR2", OID: [to be assigned], Owner: HL7</caption>
						<thead>
							<tr valign="bottom">
								<th>lvl</th>
								<th>code</th>
								<th>name</th>
								<th>definition</th>
							</tr>
						</thead>
					</table>
					<p>
						A name without specific use code might be a default name useful for
						any purpose, but a name with a specific use code would be preferred
						for that respective purpose.
					</p>
					<note>
						<p>
							The use and qualifier codes are both used as sets, where more than 
							one of each type may be used. This allows syntactically well-formed 
							but semantically absurd constructions. The following rules apply:
						</p>
						<list role="unordered">
							<item>
								<p>A single entity name may not have more than one NameRepresentationUse code.</p>
							</item>
							<item>
								<p>T, ABC, SYL, and IDE should be accompanied by some other name use code</p>
							</item>
							<item>
								<p>An organization entity name part qualifier code of "LS" may not be combined with any other qualifiers except PFX or SFX.</p>
							</item>
							<item>
								<p>The qualifiers BR and AD (or SP) are mutually incompatible</p>
							</item>
						</list>
					</note>
				</div3>
				<div3 id="prop-EN.validTime">
					<head>Valid Time (validTime) : <termref ref="dt-IVL">IVL</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;</head>
					<p>
						<emph role="strong">Definition:     </emph>
						An interval of time specifying the time during which the name is or
						was used for the entity. This accommodates the fact that people change
						names for people, places and things.
					</p>
					<p>
						<emph>EN</emph>.validTime conforms to the history item data type extension (<termref ref="dt-HXIT">HXIT</termref>) property validTime.
					</p>
				</div3>
				<div3 id="prop-EN.canonical">
					<head>Canonical (canonical) : <termref ref="dt-EN">EN</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The Entity Name with a standard ordering imposed on the parts.
					</p>
					<p>
					  The canonical form contains all the part types except for the delimiters, in the following order:
					</p>
					<list role="ordered">
						<item>titles not marked as suffix</item>
						<item>given names, with any prefixes and/or suffixes associated with the given names</item>
						<item>family names, with any prefixes and/or suffixes associated with the given names</item>
						<item>unknown name part types</item>
						<item>titles with qualifier suffix</item>
					</list>
					<p>
					  Each list of part types SHALL be in the order of the original name except as required to maintain specified prefix and suffix relationships.
					</p>
					<p>
					  The canonical form is primarily defined for the purposes of defining equality, and may differ from
					  the socially accepted order for the name parts in various cultures around the world.
					</p>
				</div3>
				<div3 id="prop-EN.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<p>
						Two name values are considered equal if their canonical forms both contain the same name
						parts in the same order. Use code and valid time are excluded from the equality test.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(EN x, y)
      where x.nonNull.and(y.nonNull) {
   x.isEmpty.and(y.isEmpty).implies(x.equal(y));
   
   x.notEmpty.and(y.notEmpty).and(x.canonical.head.nonNull).implies(
      x.equal(y).equal(x.canonical.head.equal(y.canonical.head).and(x.canonical.tail.equal(y.canonical.tail))));
	  
   x.notEmpty.and(y.notEmpty).and(x.canonical.head.isNull).implies(
      x.equal(y).equal(y.canonical.head.isNull.and(x.canonical.tail.equal(y.canonical.tail))));
};					
</pre>
					</exhibit>
				</div3>
				<div3 id="prop-EN.formatted">
					<head>Formatting Entity Names (formatted) : <termref ref="dt-ST.NT">ST.NT</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						A character string value with the entity name formatted with
						proper spacing. This is only a semantic property to define the
						function of some of the name part types.<footnote>
							<p>
								Remember that semantic properties are bare of all control flow
								semantics. The <termref ref="prop-EN.formatted">formatted</termref> could be implemented
								as a "procedure" that would "return" the formatted name, but it would
								not usually be a variable to which one could assign a formatted
								name. However, HL7 does not define applications but only the semantics
								of exchanged data values. Hence, the semantic model abstracts from
								concepts like "procedure", "return", and "assignment" but speaks only
								of property and value.
							</p>
						</footnote>
					</p>
					<p>
						<emph>EN</emph>'s main purpose is to capture names of people,
						places, and things (entities), so that one can address and refer to
						these entities in speech and writing. Humans will look at names in
						printed form, such as on a mailing label. <emph>EN</emph> therefore defines
						precise rules of how its data is formatted.<footnote>
							<p>
								These rules for formatting names are part of the semantics of names
								because the name parts have been designed with the important use case
								of displaying and rendering on labels. Note that these formatting
								rules are not ITS issues, since this formatting applies to
								presentations for humans whereas ITS specifications are presentations
								for computer interchange.
							</p>
						</footnote>
					</p>
					<p>
						Entity names are ordered lists of entity name parts. Each entity name
						part is printed in the order of the list from left to right (or in any
						other language-related reading direction).  Every entity name part
						is printed. Most entity name
						parts are framed by whitespace. The following seven rules govern the
						setting of whitespace.
					</p>
					<list role="ordered">
						<item>
							Whitespace never accumulates, i.e. two subsequent spaces are the same
							as one.
						</item>
						<item>
							Literals may contain explicit whitespace subject to the same white
							space reduction rules.
						</item>
						<item>
							Except for <emph>prefix</emph>, <emph>suffix</emph> and
							<emph>delimiter</emph> name parts, every name part is surrounded by
							implicit whitespace. Leading and trailing explicit whitespace is
							insignificant in all those name parts.
						</item>
						<item>
							Delimiter name parts are not surrounded by any implicit white
							space. Leading and trailing explicit whitespace is significant in
							delimiter name parts.
						</item>
						<item>
							Prefix name parts only have implicit leading whitespace but no
							implicit trailing whitespace. Trailing explicit whitespace is
							significant in prefix name parts.
						</item>
						<item>
							Suffix name parts only have implicit trailing whitespace but no
							implicit leading whitespace. Leading explicit whitespace is
							significant in suffix name parts.
						</item>
						<item>
							This means that all entity name parts are generally surrounded by
							whitespace, but whitespace does never accumulate. Delimiters are never
							surrounded by implicit whitespace, prefixes are not followed by
							implicit whitespace and suffixes are not preceded by implicit white
							space. Every whitespace contributed by preceding or succeeding name
							parts around those special name parts is discarded, whether it was
							implicit or explicit.
						</item>
					</list>
					<p>
						A <emph>EN</emph> can be demoted into <termref ref="dt-ST">ST</termref> by using the formatted
						representation.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(EN x)
      where x.nonNull {
   ((ST)x).equal(x.formatted);
};					
</pre>
					</exhibit>
				</div3>
				<div3 id="prop-EN.demotionST">
					<head>Demotion to ST (demotion) : <termref ref="dt-ST.NT">ST.NT</termref>
					</head>
					<p>
						<emph>EN</emph> can be demoted to <termref ref="dt-ST.NT">ST.NT</termref> using the <termref ref="prop-EN.formatted">formatted</termref> property.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(EN x)
      where x.nonNull {
 x.formatted.equal((ST) x);
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-EN.promotion">
					<head>Promotion of String to Name (promotion) : <termref ref="dt-TN">TN</termref>
					</head>
					<argument name="x" type="ST"/>
					<p>
						A <termref ref="dt-ST">ST</termref>  may be promoted to a <emph>EN</emph> where the
						equivalent <emph>EN</emph> has one part with an unknown type (see the <termref ref="dt-TN">TN</termref>
						flavor).
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(ST x)
      where x.nonNull {
  ((EN)x).length.equal(1);
  ((EN)x).item(0).type.isNull;
  
  x.equal((ST)((EN)x));  
};</pre>
					</exhibit>
					<p>
						When <termref ref="dt-ST">ST</termref> is promoted to <emph>EN</emph> and then demoted again,
						the value is preserved.						
					</p>
				</div3>
				<div3 id="ENExamples">
					<head>EN Examples</head>
					<p>
						For examples of names, please consult the ISO datatypes (ISO 21090).
					</p>
				</div3>
			</div2>
			<!-- Moved to a flavor; delete this when the move is confirmed
			<dt id="dt-TN" restricts="dt-EN" access="public" longname="Trivial Name" shortname="TN">
				<definition>
					A restriction of entity name that is effectively a simple string used
					for a simple name for things and places.
				</definition>
				<p>
					<dtname/> is an <dtref ref="dt-EN"/> that consists of only one name
					part without any name part type or qualifier. The <dtname/>, and its
					single name part are therefore equivalent to a simple character
					string. This equivalence is expressed by a defined demotion to
					<dtref ref="dt-ST"/> and promotion from <dtref ref="dt-ST"/>.
				</p>
				<dtdl id="dtdl-TN" for="dt-TN" xml:space="preserve">
type TrivialName alias TN specializes EN {
   demotion   ST;
   promotion  TN (ST x);
};

invariant(TN x) where x.nonNull {
   x.head.nonNull;
   x.tail.isEmpty;
   x.formatted.equal(x.head);
};

invariant(ST x) {
   ((TN)x).head.equal(x);
};</dtdl>
				<p>
					Trivial names are typically used for places and things, such as
					<emph>Lake Erie</emph> or <emph>Washington-Reagan National Airport</emph>:
				</p>
				<example><![CDATA[
<name>Lake Erie</name>
<name>Washington-Reagan National Airport</name>]]></example>
				<prop id="prop-TN.equal" base="prop-ANY.equal">
					<argument name="x" type="EN"/>
					<definition>
						The definition of equality for the <dtname/> is taken from the <dtref ref="dt-EN"/> data type.
<footnote>
							<p>
								This means that values of the type TN, ON, PN, and EN may be equal.
							</p>
						</footnote>
					</definition>
				</prop>
			</dt> -->
			<!--	 Moved to a flavor; delete this when the move is confirmed		
			<dt id="dt-PN" restricts="dt-EN" longname="Person Name" shortname="PN" access="public">
				<definition>
					An <dtref ref="dt-EN"/> used when the named Entity
					is a Person. A sequence of name parts, such as given name or
					family name, prefix, suffix, etc. A name part is a restriction of
					entity name part that only allows those entity name parts qualifiers
					applicable to person names. Since the structure of entity name is
					mostly determined by the requirements of person name, the restriction
					is very minor.
				</definition>
				<p>
					Since most of the functionality of entity name is in support of person
					names, the person name (PN) is only a very minor
					restriction on the entity name part qualifier.
				</p>
				<dtdl id="dtdl-PN" for="dt-PN" xml:space="preserve">
type PersonName alias PN specializes EN;

invariant(PN this) {
   forall(ENXP part)
         where this.contains(part) {
      part.qualifier.contains("LS").not;
      }
};</dtdl>
				<prop id="prop-PN.equal" base="prop-ANY.equal">
					<argument name="x" type="EN"/>
					<definition>
						The definition of equality for the <dtname/> is taken from the <dtref ref="dt-EN"/> data type.<footnote>
							<p>
								This means that values of the type TN, ON, PN, and EN may be equal.
							</p>
						</footnote>
					</definition>
				</prop>
			</dt>
			-->
			<!--	 Moved to a flavor; delete this when the move is confirmed		
			<dt id="dt-ON" restricts="dt-EN" longname="Organization Name" shortname="ON" access="public">
				<definition>
					An <dtref ref="dt-EN"/> used when the named Entity
					is an Organization. A sequence of name parts.
				</definition>
				<p>
					A name for an organization, such as "Health Level Seven, Inc."  An
					organization name consists only of untyped name parts, prefixes,
					suffixes, and delimiters.
				</p>
				<dtdl id="dtdl-ON" for="dt-ON" xml:space="preserve">
type OrganizationName alias ON specializes EN;

invariant(ON this) {
   forall(ENXP part)
         where this.contains(part) {
      part.type.implies("FAM").not;
      part.type.implies("GIV").not;
      }
};</dtdl>
				<div3 id='PN-examples'>
					<head>Examples</head>
					<p>
						The following is the organization name, "Health Level Seven, Inc." in
						a simple string form:
					</p>
					<example><![CDATA[<name>Health Level Seven, Inc.</name>]]></example>
					<p>
						And with the legal status "Inc." as a distinguished name part:
					</p>
					<example><![CDATA[<name>Health Level Seven, <suffix qualifier="LS">Inc.</suffix></name>]]></example>
				</div3>
				<prop id="prop-PN.equal" base="prop-ANY.equal">
					<argument name="x" type="EN"/>
					<definition>
						The definition of equality for the <dtname/> is taken from the <dtref ref="dt-EN"/> data type.<footnote>
							<p>
								This means that values of the type TN, ON, PN, and EN may be equal.
							</p>
						</footnote>
					</definition>
				</prop>
			</dt>
-->
		</div1>
		<div1 id="datyp2qtytyp">
			<head>Quantities</head>
			<graphic source="graphics/dtUML-Quantities.png" alt="Quantity Data Types"/>
			<div2 id="dt-QTY">
				<anchor id="QTY"/>
				<head>Quantity (QTY) specializes <termref ref="dt-ANY">ANY</termref>
				</head>
				<p>
					<emph role="strong">Definition:     </emph>
					The quantity data type is an abstract generalization for all data
					types (1) whose value set has an order relation (less-or-equal) and
					(2) where difference is defined in all of the data type's totally
					ordered value subsets.  The quantity type abstraction is needed in
					defining certain other types, such as the interval and the probability
					distribution.
				</p>
				<exhibit role="dtdl" id="dtdl-QTY">
					<anchor id="dtdl-QTY"/>
					<caption/>
					<pre>
abstract type Quantity alias QTY specializes ANY {
   BL      isComparableTo(QTY x);
   BL      lessOrEqual(QTY x);
   BL      lessThan(QTY x);
   BL      greaterThan(QTY x);
   BL      greaterOrEqual(QTY x);
   TYPE    diffType;
   QTY     minus(QTY x);
   QTY     plus(QTY x);
   ED.TEXT originalText;
   promotion RTO&lt;QTY, INT&gt; (QTY x);
};</pre>
				</exhibit>
				<div3 id="prop-QTY.isComparableTo">
					<head>Is Comparable To (isComparableTo) : <termref ref="dt-BL">BL</termref>
					</head>
					<argument name="x" type="QTY"/>
					<p>
						<emph role="strong">Definition:     </emph>
						A predicate indicating if this value and the operand can be compared
						as to which is greater than the other.
					</p>
					<p>
						Two quantities are comparable if they are both elements of a common
						totally ordered partition of their data types' value space. The
						definition is based on <termref ref="prop-QTY.lessOrEqual">lessOrEqual</termref>.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (QTY x, y, z)
      where x.nonNull.and(y.nonNull) {
   x.isComparableTo(y).equal(x.lessOrEqual(y).or(y.lessOrEqual(x)));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-QTY.lessOrEqual">
					<head>Ordering: less-or-equal (lessOrEqual) : <termref ref="dt-BL">BL</termref>
					</head>
					<argument name="x" type="QTY"/>
					<p>
						<emph role="strong">Definition:     </emph>
						A predicate expressing an order relation that is reflexive, asymmetric
						and transitive, between this quantity and another quantity.
					</p>
					<p>
						The <emph>lessOrEqual</emph> relation is defined on any totally ordered partition
						of the quantity data type. A totally ordered partition is a subset of
						the data types's defined values where all elements have a defined
						order (e.g., the integer and real numbers are totally ordered).
					</p>
					<p>
						By contrast, a partially ordered set is a set where some, but not all
						pairs of elements are comparable through the order relation (e.g., a
						tree structure or the set of physical quantities is a partially
						ordered set).  Two data values <emph>x</emph> and <emph>y</emph> of an
						ordered type are comparable (<emph>x</emph>.isComparableTo(<emph>y</emph>))
						if the less-or-equal relation holds in either way (<emph>x</emph>
						&#8804; <emph>y</emph> or <emph>y</emph> &#8804; <emph>x</emph>).
					</p>
					<p>
						A partial order relation generates totally ordered subsets whose union
						is the entire set (e.g., the set of all length is a totally ordered
						subset of the set of all physical quantities).
					</p>
					<p>
						For example, a tree structure is partially ordered, where the root is
						considered less or equal to a leaf, but there may not be an order
						among the leafs. Also, physical quantities are partially ordered,
						since an order exists only among quantities of the same dimension
						(e.g., between two lengths, but not between a length and a time).  A
						totally ordered subset of a tree is a path that transitively connects
						a leaf to the root. The physical dimension of time is a totally
						ordered subset of physical quantities.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (QTY x, y, z)
   where x.nonNull.and(y.nonNull).and(z.nonNull) {
      x.lessOrEqual(x);                                  /* reflexive */
       x.equal(y).not.implies(x.lessOrEqual(y).implies(y.lessOrEqual(x)).not);    /* asymmetric */
      x.lessOrEqual(y).and(y.lessOrEqual(z))
       .implies(x.lessOrEqual(z))                        /* transitive */
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-QTY.lessThan">
					<head>Ordering: less-than (lessThan) : <termref ref="dt-BL">BL</termref>
					</head>
					<argument name="x" type="QTY"/>
					<p>
						<emph role="strong">Definition:     </emph>
						A predicate expressing an order relation that is asymmetric and
						transitive, between this quantity and another quantity. The ordering
						is the same as <termref ref="prop-QTY.lessOrEqual">lessOrEqual</termref>, but irreflexive.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (QTY x, y, z)
      where x.nonNull.and(y.nonNull) {
   x.lessThan(y).equal(x.lessOrEqual(y)
                .and(x.equal(y).not));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-QTY.greaterThan">
					<head>Ordering: greater-than (greaterThan) : <termref ref="dt-BL">BL</termref>
					</head>
					<argument name="x" type="QTY"/>
					<p>
						<emph role="strong">Definition:     </emph>
						A predicate expressing an order relation that is asymmetric and
						transitive, between this quantity and another quantity. This
						is the invese of <termref ref="prop-QTY.lessThan">lessThan</termref>.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (QTY x, y, z)
      where x.nonNull.and(y.nonNull) {
   x.greaterThan(y).equal(y.lessThan(x));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-QTY.greaterOrEqual">
					<head>Ordering: greater-or-equal (greaterOrEqual) : <termref ref="dt-BL">BL</termref>
					</head>
					<argument name="x" type="QTY"/>
					<p>
						<emph role="strong">Definition:     </emph>
						A predicate expressing an order relation that is reflexive, asymmetric
						and transitive, between this quantity and another quantity. This is
						the inverse order of <termref ref="prop-QTY.lessOrEqual">lessOrEqual</termref>.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (QTY x, y, z)
      where x.nonNull.and(y.nonNull) {
   x.greaterOrEqual(y).equal(y.lessOrEqual(x));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-QTY.diffType">
					<head>DifferenceDataType (diffType) : <termref ref="dt-TYPE">TYPE</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The type of the difference between two values of a specific QTY data type. The data type
						of the difference quantity is related to the operand quantities but need not be the same.
					</p>
					<p>
						<emph>diffType</emph> is a data type that can express the difference between
						two values for which the ordering relation is defined (i.e., two
						elements of a common totally ordered subset).  For example, the
						difference data type of integer number is integer number, but the
						difference type of point in time is a physical quantity in the
						dimension of time. A difference data type is a totally ordered data
						type.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(QTY x) {
   x.diffType.implies(QTY);
   x.diffType.equal(QTY).not;
};</pre>
					</exhibit>
					<p>
						The type will be some data type that further specializes QTY.
					</p>
				</div3>
				<div3 id="prop-QTY.minus">
					<head>Difference (minus) : <termref ref="dt-QTY">QTY</termref>
					</head>
					<argument name="x" type="QTY"/>
					<p>
						<emph role="strong">Definition:     </emph>
						A quantity expressing the "distance" of this quantity from the operand
						quantity, that must be comparable.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(QTZ x, y)
     where y.dataType.implies(x.dataType) {
   x.minus(y).datatype.implies(x.diffType);
};

invariant(QTZ x, y)
     where y.dataType.implies(x.diffType) {
   x.minus(y).datatype.implies(x.dataType);
};</pre>
					</exhibit>
					<p>
						The difference between two quantities has the data type returned by the diffType property of the instance.
						This leads to two different minus operations, one with an operand of the same type as the instance, and
						the other with the diffType of the instance, with the return types of the matching type. When the diffType
						is the same as the dataType, there is only one minus operation.
					</p>
					<p>
						A difference is defined in an ordered set if it is semantically
						meaningful to state that &#916; is the difference between the values
						<emph>x</emph> and <emph>y</emph>. This difference &#916; must be
						meaningful independently from the values <emph>x</emph> and
						<emph>y</emph>. This independence exists if for all values
						<emph>u</emph> one can meaningfully derive a value <emph>v</emph> such
						that &#916; would also be the difference between <emph>u</emph> and
						<emph>v</emph>. The judgment for what is <emph>meaningful</emph>
						cannot be defined formally.<footnote>
							<p>
								The quantity data type abstraction corresponds to the notion of
								difference scales in contrast to ordinal scales and ratio scales
								(Guttman and Stevens). A data type with only the order requirement but
								not the difference requirement would be an ordinal. Ordinals are not
								currently defined with a special data type. Instead, ordinals are
								usually coded values, where the underlying code system specifies
								ordinal semantics. CO is the data type expressing thes ordinal
								semantics.
							</p>
						</footnote>
					</p>
					<p>
						The difference between two values <emph>x</emph> minus <emph>y</emph>
						must be defined for all <emph>x</emph> and <emph>y</emph> in a common
						totally ordered subset of the data type's value set.
					</p>
					<p>
						If x and y are not comparable, then the difference will be Null.<footnote>
							<p>
								Note that the converse may not apply. If the diffType is different to
								the dataType, then minus may still evaluate to a proper value, even though
								the values are not comparable in this case.
							</p>
						</footnote>
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(QTY x, y)
      where y.datatype.equal(x.dataType).and(x.isComparableTo(y).Not) {
   x.minus(y).notApplicable;
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-QTY.plus">
					<head>Addition (plus) : <termref ref="dt-QTY">QTY</termref>
					</head>
					<argument name="x" type="diffType"/>
					<p>
						<emph role="strong">Definition:     </emph>
						The sum of this quantity and its operand. The operand must be of a
						data type that can express the difference between two values of this
						quantity's data type.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(QTY x, y)
      where y.nonNull.and(x.nonNull).and(y.dataType.implies(x.dataType).and(x.isComparableTo(y))) {
   x.plus(y.minus(x)).equal(y);
};</pre>
					</exhibit>
					<p>
						If <emph>y</emph> is not a valid type for the difference between two
						values of the type of <emph>x</emph>, the the result of the operation
						will be NULL.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(QTY x, y)
      where y.dataType.implies(x.diffType).not {
   x.plus(y).notApplicable;
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-QTY.originalText">
					<head>Original Text (originalText) : <termref ref="dt-ED.TEXT">ED.TEXT</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
					    The text representation from which the <emph>QTY</emph> was encoded, if such a representation is the source
						of the <emph>QTY</emph>. Original text can be used in a structured user interface to capture what the user
						saw as a representation of the code on the data input screen, or in a situation where the user dictates
						or directly enters text, it is the text entered or uttered by the user.
					</p>
					<p>
						The originalText is not a substitute for a valid value. If the actual value of the <emph>QTY</emph> is not
						valid, then the <emph>QTY</emph> SHALL be null, irrespective of whether originalText has a value or not.
					</p>
					<p>
							Note that although post-coding is often performed from free text information,
							such as documents, scanned images or dictation, multi-media data is
							explicitly not permitted as original text. Also, the original text
							property is not meant to be a link into the entire source
							document. The link between different artifacts of medical information
							(e.g., document and coded result) is outside the scope of this
							specification and is maintained elsewhere in the HL7 standards. The
							original text SHALL be an excerpt of the relevant information in the
							original sources, rather than a pointer or exact reproduction. Thus
							the original text SHALL be represented in plain text form. In specific
							circumstances, as described in other HL7 specifications, the originalText
							may be a reference to some other text artefact for which the resolution
							scope is clearly described. 
						</p>
				</div3>
				<div3 id="prop-QTY.promotion">
					<head>Promotion of Quantity to Ratio (promotion) : <termref ref="dt-RTO">RTO</termref>&lt;<termref ref="dt-QTY">QTY</termref>,<termref ref="dt-INT">INT</termref>&gt;</head>
					<argument name="x" type="QTY"/>
					<p>
							A quantity of can be promoted into a RTO&lt;?, INT&gt; where the type of ? is the 
							type of the quantity itself, and the denominator of the ratio has a value of 1. 
						</p>
				</div3>
			</div2>
			<div2 id="dt-QTZ">
				<anchor id="QTZ"/>
				<head>ZeroedQuantity (QTZ) specializes <termref ref="dt-QTY">QTY</termref>
				</head>
				<p>
					<emph role="strong">Definition:     </emph>
					The Zeroed Quantity data type is an abstract generalization for all data
					types where the addition and subtraction operations involve both operands
					and results from the same type, and where the concept of a zero value exists. 
				</p>
				<exhibit role="dtdl" id="dtdl-QTZ">
					<anchor id="dtdl-QTZ"/>
					<caption/>
					<pre>
abstract type ZeroedQuantity alias QTZ specializes QTY {
   QTZ   minus(QTZ x);
   QTZ   plus(QTZ x);
   BL    isZero;
};</pre>
				</exhibit>
				<div3 id="prop-QTZ.diffType">
					<head>DifferenceDataType (diffType) : <termref ref="dt-TYPE">TYPE</termref>, inherited from <termref ref="dt-QTY">QTY</termref>
					</head>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(QTZ x) {
   x.diffType.equal(x.dataType)
};</pre>
					</exhibit>
					<p/>
						For all specializations of <emph>QTZ</emph>, the difference type is the type itself.
				</div3>
				<div3 id="prop-QTZ.minus">
					<head>Difference (minus) : <termref ref="dt-QTZ">QTZ</termref>, inherited from <termref ref="dt-QTY">QTY</termref>
					</head>
					<argument name="x" type="QTZ"/>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(QTZ x, y) {
   x.minus(y).datatype.implies(x.dataType);
};</pre>
					</exhibit>
					<p>
						The result of minus has the same data type as the instance.
					</p>
				</div3>
				<div3 id="prop-QTZ.plus">
					<head>Addition (plus) : <termref ref="dt-QTZ">QTZ</termref>, inherited from <termref ref="dt-QTY">QTY</termref>
					</head>
					<argument name="x" type="QTZ"/>
					<p>
						The operand has the same type as this quantity's data type.
					</p>
				</div3>
				<div3 id="prop-QTZ.isZero">
					<head>The Zero-Quantity (isZero) : <termref ref="dt-BL">BL</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The neutral element in the difference and addition operations, i.e.,
						if a quantity is zero, addition to, or subtraction from any other
						comparable quantity will result in that other quantity.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(QTZ x) 
    where x.nonNull {
   x.minus(x).isZero;
};</pre>
					</exhibit>
					<p>
					  Zero is the difference between a value and itself.
					</p>
				</div3>
			</div2>
			<div2 id="dt-INT">
				<anchor id="INT"/>
				<head>IntegerNumber (INT) specializes <termref ref="dt-QTZ">QTZ</termref>
				</head>
				<p>
					<emph role="strong">Definition:     </emph>
					Integer numbers (-1,0,1,2, 100, 3398129, etc.) are precise numbers
					that are results of counting and enumerating. Integer numbers are
					discrete, the set of integers is infinite but countable.  No arbitrary
					limit is imposed on the range of integer numbers. Two NULL flavors are
					defined for the positive and negative infinity.
				</p>
				<exhibit role="dtdl" id="dtdl-INT">
					<anchor id="dtdl-INT"/>
					<caption/>
					<pre>
type IntegerNumber alias INT specializes QTZ {
           INT  successor;
           INT  predecessor;
           INT  plus(QTY x);
           INT  times(INT x);
           INT  negated;
           BL   isNegative;
           BL   nonNegative;
           REAL  dividedBy(REAL x);
           INT  dividedBy(INT x);
           INT  remainder(INT x);
           BL   isOne;
  literal  ST.SIMPLE;
};</pre>
				</exhibit>
				<p>
					Since the integer number data type includes all of the semantics of
					the mathematical integer number concept, the basic operations plus
					(addition) and times (multiplication) are defined. These operations
					are defined here as characterizing operations in the sense of ISO
					11404, and because these operations are needed in other parts of this
					specification, namely the semantics of the literal form.
				</p>
				<p>
					The traditional recursive definitions of addition and multiplication
					are due to Grassmann, and use the notion of <termref ref="prop-INT.successor">successor</termref>.<footnote>
						<p>
							H. Grassman. <emph>Lehrbuch der Arithmetik.</emph> 1861. We prefer
							Grassman's original axioms to the Peano axioms, because Grassman's
							axioms work for all integers, not just for natural numbers. Also, "it
							is rather well-known, through Peano's own acknowledgment, that Peano
							borrowed his axioms from Dedekind and made extensive use of
							Grassmann's work in his development of the axioms." (Hao Wang. The
							Axiomatization of Arithmetic. J. Symb. Logic; 1957:22(2); p. 145).
						</p>
					</footnote>
				</p>
				<exhibit role="dtdl">
					<caption/>
					<pre>
invariant(INT x, o, i)
      where x.nonNull.and(o.isZero) {
   x.lessThan(x.successor);
   x.plus(o).equal(x);
   x.plus(y.successor).equal(x.plus(y).successor);
   x.times(o).equal(o);
   x.times(y.successor).equal(x.times(y)).plus(x);
};</pre>
				</exhibit>
				<div3 id="prop-INT.successor">
					<head>Successor (successor) : <termref ref="dt-INT">INT</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The <emph>INT</emph> value that is greater than this <emph>INT</emph> value but
						where no <emph>INT</emph> value exists between this value and its successor.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(INT x, y)
      where x.successor(y) {
   x.lessThan(y).and.not(exists(INT z) {
      x.lessThan(z);
      z.lessThan(y);
      });
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-INT.predecessor">
					<head>Predecessor (predecessor) : <termref ref="dt-INT">INT</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The inverse of <termref ref="prop-INT.successor">successor</termref>.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(INT x, y)
      where x.successor(y) {
   x.successor.predecessor.equal(x);
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-INT.diffType">
					<head>DifferenceDataType (diffType) : <termref ref="dt-TYPE">TYPE</termref>, inherited from <termref ref="dt-QTY">QTY</termref>
					</head>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(INT x) {
   x.diffType.implies(INT);
};</pre>
					</exhibit>
					<p>
						The difference between two <emph>INT</emph> values is also a <emph>INT</emph> value.
					</p>
				</div3>
				<div3 id="prop-INT.plus">
					<head>Addition (plus) : <termref ref="dt-INT">INT</termref>, inherited from <termref ref="dt-QTY">QTY</termref>
					</head>
					<argument name="x" type="QTY"/>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(INT x, y, o)
      where x.nonNull.and(y.nonNull).and(o.isZero) {
   x.plus(o).equal(x);
   x.plus(y.successor).equal(x.plus(y).successor);
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-INT.times">
					<head>Multiplication (times) : <termref ref="dt-INT">INT</termref>
					</head>
					<argument name="x" type="INT"/>
					<p>
						<emph role="strong">Definition:     </emph>
						The result of multiplying this integer with the operand, equivalent to
						repeated additions of this integer.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(INT x, y, i, o)
      where x.nonNull.and(x.isComparableTo(y)).and(o.isZero).and(i.isOne) {
   x.times(o).equal(o);
   x.times(i).equal(x);
   x.times(y.successor).equal(x.times(y)).plus(x);
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-INT.negated">
					<head>Negation (negated) : <termref ref="dt-INT">INT</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The inverse element of the <emph>INT</emph> value, another <emph>INT</emph> value,
						which, when added to that value yields zero (the neutral element).
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(INT x)
      where x.nonNull {
   x.plus(x.negated).isZero;
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-INT.isNegative">
					<head>Negative (isNegative) : <termref ref="dt-BL">BL</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						A predicate indicating whether this <emph>INT</emph> is less than zero (not
						non-negative).
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(INT x)
      where x.nonNull {
   x.isNegative.equal(x.nonNegative.not);
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-INT.nonNegative">
					<head>Non-Negative (nonNegative) : <termref ref="dt-BL">BL</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						A predicate indicating whether the <emph>INT</emph> zero (neutral element) is
						less or equal to this <emph>INT</emph>.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(INT x, o)
      where x.nonNull.and(o.isZero) {
   x.nonNegative.equal(o.lessOrEqual(x));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-INT.dividedBy">
					<head>Standard Division (dividedBy) : <termref ref="dt-REAL">REAL</termref>
					</head>
					<argument type="REAL" name="x"/>
					<p>
						<emph role="strong">Definition:     </emph>
						The division operation of this integer (dividend) with a real number
						(divisor) to produce a real number value.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(INT dividend, REAL divisor)
      where dividend.nonNull.and(divisor.nonNull).and(divisor.isZero.not) {
   dividend.isZero.implies(dividend.dividedBy(divisor).isZero);
   dividend.isZero.not.implies(dividend.dividedBy(divisor).equals(dividend.times(divisor.inverted)));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-INT.dividedBy">
					<head>Integer Division (dividedBy) : <termref ref="dt-INT">INT</termref>
					</head>
					<argument type="INT" name="x"/>
					<p>
						<emph role="strong">Definition:     </emph>
						The integer division operation of this integer (dividend) with another
						integer (divisor) is the integer number of times the divisor fits into
						the dividend.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(INT dividend, divisor, o, i)
      where dividend.nonNull.and(divisor.nonNull).and(divisor.isZero.not).and(o.isZero) {
   dividend.isZero.implies(dividend.dividedBy(divisor).equal(o));
   dividend.isZero.not.implies(dividend.dividedBy(divisor).equal(
      absolute(dividend).minus(absolute(divisor)).dividedBy(absolute(divisor))
                        .successor.times(sign(dividend)
                        .times(sign(divisor)))));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-INT.remainder">
					<head>Remainder (remainder) : <termref ref="dt-INT">INT</termref>
					</head>
					<argument type="INT" name="x"/>
					<p>
						<emph role="strong">Definition:     </emph>
						The remainder of the integer division.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(INT x, y)
      where x.nonNull.and(y.nonNull) {
   x.reminder(y).equal(x.minus(x.dividedBy(z).times(y)));
};</pre>
					</exhibit>
					<p>
						This definition of the remainder matches the C and Java programming
						languages.
					</p>
				</div3>
				<div3 id="prop-INT.isOne">
					<head>Neutral Element of Multiplication (isOne) : <termref ref="dt-BL">BL</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						A predicate indicating if this value is the number one, i.e., the
						neutral element of multiplication. There is exactly one integer
						that has this property.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(INT x, y)
      where x.nonNull.and(y.nonNull) {
   x.isOne.and(y.isOne).implies(x.equal(y));
   x.isOne.and(y.isZero).implies(x.equal(y).not);
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-INT.literal">
					<head>Literal Form</head>
					<p>
						The literal form of an integer is a simple decimal number, i.e. a
						string of decimal digits.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
INT.literal ST.SIMPLE {
   INT digit : "0"         { $.isZero; }
             | "1"         { $.equal(0.successor); }
             | "2"         { $.equal(1.successor); }
             | "3"         { $.equal(2.successor); }
             | "4"         { $.equal(3.successor); }
             | "5"         { $.equal(4.successor); }
             | "6"         { $.equal(5.successor); }
             | "7"         { $.equal(6.successor); }
             | "8"         { $.equal(7.successor); }
             | "9"         { $.equal(8.successor); };

  INT uint   : digit       { $.equal($1); }
             | uint digit  { $.equal($1.times(9.successor).plus($2)); };

  INT        : uint        { $.equal($1); }
             | "+" uint    { $.equal($2); }
             | "-" uint    { $.equal($2.negated); };
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-INT.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<argument name="x" type="INT"/>
					<p>
						Two nonNull <emph>INT</emph> are equal if they have the same value.
					</p>
				</div3>
			</div2>
			<div2 id="dt-REAL">
				<anchor id="REAL"/>
				<head>RealNumber (REAL) specializes <termref ref="dt-QTZ">QTZ</termref>
				</head>
				<p>
					<emph role="strong">Definition:     </emph>
					A scalar magnitude. Typically used whenever quantities are measured,
					estimated, or computed from other real numbers.  The typical
					representation is decimal, where the number of significant decimal
					digits is known as the precision.
				</p>
				<p>
					The term "Real number" in this specification is used to mean that
					fractional values are covered without necessarily implying the full
					set of the mathematical real numbers that would include irrational
					numbers such as &#961;, Euler's number, etc.<footnote>
						<p>
							The term "Real" for a fractional number data type originates and is
							well established in the Algol, Pascal tradition of programming
							languages.
						</p>
					</footnote>
				</p>
				<note role="ITS">
					<p>
						This specification defines the real number data type in the broadest
						sense possible. However, it does not imply that any conforming ITS or
						implementation must be able to represent the full range of Real
						numbers, which would not be possible in any finite
						implementation. HL7's current use cases for the Real number data type
						are measured and estimated quantities and monetary amounts. These use
						cases can be handled with a restricted Real value space, rational
						numbers, and even just very limited decimals (scaled integers).
						However, we declare the representations of the real value space as
						floating point, rational, scaled integer, or digit string, and their
						various limitations to be out of the scope of this specification.
					</p>
				</note>
				<p>
					This specification offers two choices for a number data type. The
					choice is made as follows: Any number attribute is a real if it is not
					known for sure that it is an integer. A number is an integer if it is
					<emph>always</emph> counted, typically representing an ordinal
					number. If there are conceivable use cases where such a number would
					be estimated or averaged, it is not always an integer and thus should
					use the Real data type.
				</p>
				<exhibit role="dtdl" id="dtdl-REAL">
					<anchor id="dtdl-REAL"/>
					<caption/>
					<pre>
type RealNumber alias REAL specializes QTZ {
             INT   precision;
             REAL  negated;
             BL    isOne;
             REAL  times(REAL x);
             REAL  dividedBy(REAL x);
             REAL  inverted;
             REAL  power(REAL x);
  literal    ST.SIMPLE;
  promotion  REAL  (INT x);
  demotion   INT;
};</pre>
				</exhibit>
				<p>
					The algebraic operations are specified here as characterizing
					operations in the sense of ISO 11404, and because these operations are
					needed in other parts of this specification.
				</p>
				<p>
					Unlike the integer numbers, the real numbers semantics are not
					inductively constructed but only intuitively described by their axioms
					of their algebraic properties. The completeness axioms are
					intentionally left out so as to make no statement about irrational
					numbers.
				</p>
				<div3 id="prop-REAL.isComparableTo">
					<head>Is Comparable To (isComparableTo) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-QTY">QTY</termref>
					</head>
					<p>
						The value set of <emph>REAL</emph> is totally ordered.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(REAL x, y)
      where x.nonNull.and(y.nonNull) {
   x.isComparableTo(y);
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-REAL.diffType">
					<head>DifferenceDataType (diffType) : <termref ref="dt-TYPE">TYPE</termref>, inherited from <termref ref="dt-QTY">QTY</termref>
					</head>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(REAL x) {
   x.diffType.implies(REAL);
};</pre>
					</exhibit>
					<p>
						The difference between two <emph>REAL</emph> values is also a <emph>REAL</emph> value.
					</p>
				</div3>
				<div3 id="prop-REAL.precision">
					<head>Precision of the Decimal Form (precision) : <termref ref="dt-INT">INT</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The number of significant digits of the decimal representation.
					</p>
					<p>
						Precision is formally defined based on the <termref ref="prop-REAL.literal">literal</termref>.
					</p>
					<p>
						The precision attribute is only the precision of a decimal digit
						representation, <emph>not the accuracy of the real number
						value</emph>.
					</p>
					<p>
						The purpose of the precision property for the real number data type is
						to faithfully capture the whole information presented to humans in a
						number. The amount of decimal digits shown conveys information about
						the uncertainty (i.e., precision and accuracy) of a measured value.
					</p>
					<note>
						<p> 
							The precision of the representation is independent from uncertainty
							(precision accuracy) of a measurement result. If the uncertainty of a
							measurement result is important, one should specify uncertain values 
							as <termref ref="dt-PPD">PPD</termref> or <termref ref="dt-CIVL">CIVL</termref>.
						</p>
					</note>
					<p>
						The rules for what digits are significant are as follows:
					</p>
					<list role="ordered">
						<item>
							All non-zero digits are significant.
						</item>
						<item>
						    The zero immediately left to the decimal point is significant (even if either the zero or the decimal point is omitted).
						</item>
						<item>
							All zeroes to the right of a significant digit are significant.
						</item>
					</list>
					<note>
						<p>
							These rules of significance differ slightly from the more casual rules
							taught in school. Elsewhere, e.g., 2000 is
							ambiguous as to whether the zeroes are significant. This deviation
							from the common custom is warranted for the purpose of unambiguous
							communication.
						</p>
					</note>
					<table id="table-REAL.precision.examples" width="1px">
						<caption>Examples for the Precision of Real Number Literals.</caption>
						<thead>
							<tr>
								<th rowspan="1" colspan="1">Literal</th>
								<th rowspan="1" colspan="1">Number of Significant Digits</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td rowspan="1" colspan="1">2000</td>
								<td rowspan="1" colspan="1">has 4 significant digits.</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">2e3</td>
								<td rowspan="1" colspan="1">
									has 1 significant digit, used if one would naturally say 
									"2000" but precision is only 1.
								</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">0.001</td>
								<td rowspan="1" colspan="1">has 4 significant digits.</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">1e-3</td>
								<td rowspan="1" colspan="1">
									has 1 significant digit, use this if one would naturally
									say "0.001" but precision is only 1.
								</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">0</td>
								<td rowspan="1" colspan="1">has 1 significant digit.</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">0.</td>
								<td rowspan="1" colspan="1">has 1 significant digit.</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">0.0</td>
								<td rowspan="1" colspan="1">has 2 significant digits.</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">0.1</td>
								<td rowspan="1" colspan="1">has 2 significant digits.</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">.1</td>
								<td rowspan="1" colspan="1">has 2 significant digits.</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">000.0</td>
								<td rowspan="1" colspan="1">has 2 significant digits.</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">0.00</td>
								<td rowspan="1" colspan="1">has 3 significant digits.</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">4.10</td>
								<td rowspan="1" colspan="1">has 3 significant digits.</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">4.09</td>
								<td rowspan="1" colspan="1"> has 3 significant digits.</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">4.1</td>
								<td rowspan="1" colspan="1">has 2 significant digits.</td>
							</tr>
						</tbody>
					</table>
					<p>
						The precision of the representation SHOULD match the
						uncertainty of the value. However, precision of the representation and
						uncertainty of the value are separate independent concepts. Refer to
						<termref ref="dt-PPD_REAL">PPD&lt;REAL&gt;</termref> for details about uncertain real numbers.
					</p>
					<p>
						For example "0.123" has 3 significant digits <emph>in the
						representation</emph>, but the <emph>uncertainty of the value</emph>
						may be in any digit shown or not shown, i.e., the uncertainty may be
						0.123±0.0005, 0.123±0.005 or
						0.123±0.00005, etc. Note that ITS representations
						<emph>should</emph> adjust their representational precision with the
						uncertainty of the value. However, since the precision in the digit
						string is granular to 0.5 the least significant digit, while
						uncertainty may be anywhere between these "grid lines",
						0.123±0.005 would also be an adequate representation for the
						value between 0.118 and 0.128.
					</p>
					<note role="ITS">
						<p>
							On a character based Implementation Technology the ITS may not
							represent the precision as an explicit attribute if numbers are
							represented as decimal digit strings. In that case, the ITS SHALL abide
							by the rules of an unambiguous determination of significant digits. A
							number representation SHALL not produce more or less significant digits
							than were originally in that number. Conformance can be tested through
							round-trip encoding &#8212; decoding &#8212; encoding.
						</p>
					</note>
				</div3>
				<div3 id="prop-REAL.plus">
					<head>Addition (plus) : <termref ref="dt-QTY">QTY</termref>, inherited from <termref ref="dt-QTY">QTY</termref>
					</head>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(REAL x, y, z, o)
      where x.nonNull.and(y.nonNull).and(z.nonNull).and(o.isZero) {
   x.plus(o).equal(x);                             /* neutral element */
   x.plus(y).plus(z).equal(x.plus(y.plus(z)));     /* associative */
   x.plus(y).equal(y.plus(x));                     /* commutative */
   z.lessOrEqual(x).and(z.lessOrEqual(y)
                   .implies(z.lessOrEqual(x.plus(y))));
   x.lessOrEqual(y).implies(x.plus(z)
                   .lessOrEqual(y.plus(z)));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-REAL.negated">
					<head>Negation (Inverse Element of Addition) (negated) : <termref ref="dt-REAL">REAL</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						A <emph>REAL</emph> value, which, when added to another <emph>REAL</emph> value yields
						zero (the neutral element of addition).
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(REAL x)
      where x.nonNull {
   x.plus(x.negated).isZero;
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-REAL.isOne">
					<head>Neutral Element of Multiplication (isOne) : <termref ref="dt-BL">BL</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						A predicate indicating if this value is the number one, i.e., the
						neutral element of multiplication. There is exactly one real number
						that has this property.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(REAL x, y)
      where x.nonNull.and(y.nonNull) {
   x.isOne.and(y.isOne).implies(x.equal(y));
   x.isOne.and(y.isZero).implies(x.equal(y).not);
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-REAL.times">
					<head>Multiplication (times) : <termref ref="dt-REAL">REAL</termref>
					</head>
					<argument name="x" type="REAL"/>
					<p>
						<emph role="strong">Definition:     </emph>
						An operation in <emph>REAL</emph> that forms an abelian group and is related
						to addition by the law of distribution.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(REAL x, y, z, i, o)
      where x.nonNull.and(y.nonNull).and(z.nonNull)
             .and(i.isOne).and(o.isZero) {
   x.times(o).equal(o);
   x.times(i).equal(x);                                      /* neutral element */
   x.times(y).times(z).equal(x.times(y.times(z)));           /* associative */
   x.times(y).equal(y.times(x));                             /* commutative */
   x.times(y.plus(z)).equal(x.times(y).plus(x.times(z)));     /* distributive */
   o.lessOrEqual(x).and(o.lessOrEqual(y).implies(o.lessOrEqual(x.times(y))));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-REAL.dividedBy">
					<head>Standard Division (dividedBy) : <termref ref="dt-REAL">REAL</termref>
					</head>
					<argument type="REAL" name="x"/>
					<p>
						<emph role="strong">Definition:     </emph>
						The division operation of this real number(dividend) with a real number (divisor).
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(REAL dividend, REAL divisor)
      where dividend.nonNull.and(divisor.nonNull).and(divisor.isZero.not) {
   dividend.isZero.implies(dividend.dividedBy(divisor).isZero);
   dividend.isZero.not.implies(dividend.dividedBy(divisor).equals(dividend.times(divisor.inverted)));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-REAL.inverted">
					<head>Inverse Element of Multiplication (inverted) : <termref ref="dt-REAL">REAL</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						A <emph>REAL</emph> value, which, when muliplied with another <emph>REAL</emph> value
						yields one (the neutral element of multiplication). Zero (the neutral
						element of addition) has no inverse element.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(REAL x, i)
      where x.isZero.not.and(i.isOne) {
   x.times(x.inverted).equal(i);
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-REAL.power">
					<head>Exponentiation (power) : <termref ref="dt-REAL">REAL</termref>
					</head>
					<argument type="REAL" name="x"/>
					<p>
						<emph role="strong">Definition:     </emph>
						The basis of exponentiation is the iterative multiplication of a
						real number, and extended to rational exponents as the inverse
						operation.
					</p>
					<p>
						We only list certain common properties of exponentiation.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(REAL x, y, z, o, i)
      where x.nonNull.and(y.nonNull).and(z.nonNull)
             .and(o.isZero).and(i.isOne) {
   forall(INT n)
         where n.nonNull {
      n.greaterThan(o).implies(
         x.power(n).equal(x.times(x.power(n.predecessor))));
      n.lessThan(o).implies(
         x.power(n).equal(x.power(n.negated).inverted));
      };
      x.power(o).equal(i);
      x.power(i).equal(x);
      x.power(y).power(z).equal(x.power(y.times(z)));
      x.power(y).times(x.power(z)).equal(x.power(y.plus(z)));
      x.power(y).inverted.equal(x.power(y.negated));
      x.power(y).power(y.inverted).equal(x);
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-REAL.literal">
					<head>Literal Form</head>
					<p>
						The literal form of an real is a string of decimal digits with
						optional leading "+" or "-" sign, and optional decimal point, and
						optional exponential notation using a case insensitive "e" between the
						mantissa and the exponent. The number of significant digits SHALL
						conform to the precision property.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
REAL.literal ST.SIMPLE {
   REAL            : mantissa                   { $.equal($1); }
                   | mantissa /[eE]/ INT        { $.equal($1.times(10.power($3)); };

   REAL mantissa   : /0*/ 0                     { $.isZero;
                                                  $.precision.equal(1); }
                   | /0*/ "." /0*/              { $.isZero;
                                                  $.precision.equal($3.length.successor); }
                   | /0*/ "." /0*/ fractional   { $.equal($4);
                                                  $.precision.equal($4.precision); }
                   | integer                    { $.equal($1); }
                   | integer "." fractional     { $.equal($1.plus($2));
                                                  $.precision.equal(
                                                  $1.precision.plus($3.precision)); };

   REAL integer    : uintval                    { $.equal($2); }
                   | "+" uintval                { $.equal($1.times($2)); }
                   | "-" uintval                { $.equal($1.times($2).negated); };

   REAL uintval    : /0*/ uint                  { $.equal($2); };

   REAL uint       : digit                      { $.equal($1);
                                                  $.precision.equal(1); }
                   | uint digit                 { $.equal($1.times(10).plus($2));
                                                  $.precision.equal(
                                                     $1.precision.successor); };

   REAL fractional : digit                      { $.equal($1.times(10.inverted));
                                                  $.precision.equal(1); }
                   | digit fractional           { $.equal(
                                                  $1.plus($2.times(10.inverted));
                                                  $.precision.equal(
                                                     $1.precision.successor); };

   INT digit       : /[0-9]/                    { $.equal($1); }
};</pre>
					</exhibit>
					<p>
						Examples of real literals for two thousand are 2000, 2000., 2e3,
						2.0e+3, +2.0e+3.
					</p>
					<p>
						Note that the literal form does not carry type information. For
						example, "2000" is a valid representation of both a real number and an
						integer number. No trailing decimal point is used to disambiguate from
						integer numbers. An ITS that uses this literal form must recover the
						type information from other sources.
					</p>
				</div3>
				<!-- Homomorphism INT -> REAL -->
				<div3 id="prop-REAL.promotion">
					<head>Homomorphism of INT and REAL (promotion) : <termref ref="dt-REAL">REAL</termref>
					</head>
					<argument name="x" type="INT"/>
					<p>
						The <termref ref="dt-INT">INT</termref> and <emph>REAL</emph> data types are related by a
						homomorphism that maps every value in <termref ref="dt-INT">INT</termref> to a value
						in <emph>REAL</emph> whereby the algebraic properties of <termref ref="dt-INT">INT</termref>
						are preserved. This means, an integer can be promoted to a real and a
						real can be demoted to an integer by means of rounding off the
						fractional part.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(INT n, m)
      where n.nonNull.and(m.nonNull) {
   ((REAL)n.plus(m)).equal(((REAL)n).plus((REAL)m));
   ((REAL)n.times(m)).equal(((REAL)n).times((REAL)m));
};</pre>
					</exhibit>
				</div3>
				<prop id="prop-REAL.demotionINT" shortname="demotion" longname="Demotion to INT" type="INT" render="false"/>
				<div3 id="prop-REAL.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<argument name="x" type="REAL"/>
					<p>
						Two nonNull <emph>REAL</emph> are equal if they have the same value and precision.<footnote>
							<p>
								Because of precision and representation issues, such a strict
								evaluation of equals is often inappropriate in implementations, and some sort of 
								limit of difference or interval based logic is usually appropriate
								for applications.
							</p>
						</footnote>
					</p>
				</div3>
			</div2>
			<div2 id="dt-RTO">
				<anchor id="RTO"/>
				<head>Ratio (RTO) specializes <termref ref="dt-QTY">QTY</termref>
				</head>
				<parameter name="N" type="QTZ"/>
				<parameter name="D" type="QTZ"/>
				<p>
					<emph role="strong">Definition:     </emph>
					A quantity constructed as the quotient of a numerator quantity divided
					by a denominator quantity. Common factors in the numerator and
					denominator are not automatically cancelled out.  The <emph>RTO</emph> data
					type supports titers (e.g., "1:128") and other quantities produced by
					laboratories that truly represent ratios. Ratios are not simply
					"structured numerics": for instance, blood pressure measurements
					(e.g. "120/60") are not ratios.
				</p>
				<p>
					Ratios are different from rational numbers, i.e., in ratios common
					factors in the numerator and denominator never cancel out.  A ratio of
					two real or integer numbers is not automatically reduced to a real
					number. In many cases the <termref ref="dt-REAL">REAL</termref>
					should be used instead of <emph>RTO</emph>
				</p>
				<table id="dt-RTO-prop-summary">
					<caption>Property Summary of
      Ratio</caption>
					<col width="79"/>
					<col width="60"/>
					<col width="413"/>
					<thead>
						<tr>
							<th>Name</th>
							<th>Type</th>
							<th>Description</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>
								<termref ref="prop-RTO.numerator">numerator</termref>
							</td>
							<td>
								<termref ref="dt-N">N</termref>
							</td>
							<td>
						The quantity that is being divided in the ratio.  The default is the
						integer number 1 (one).
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-RTO.denominator">denominator</termref>
							</td>
							<td>
								<termref ref="dt-D">D</termref>
							</td>
							<td>
						The quantity that devides the numerator in the ratio.  The default is
						the integer number 1 (one).  The denominator SHALL not be zero.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-RTO.demotionREAL">demotion</termref>
							</td>
							<td>
								<termref ref="dt-REAL">REAL</termref>
							</td>
							<td>
						A ratio can be demoted to a real by dividing the numerator by the denominator. 
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-RTO.demotionPQ">demotion</termref>
							</td>
							<td>
								<termref ref="dt-PQ">PQ</termref>
							</td>
							<td>
						A ratio can be demoted to a physical quantity by dividing the numerator by the denominator. The units
						are derived by dividing the units for the numerator by the units for the denominator. 
					</td>
						</tr>
					</tbody>
				</table>
				<note>
					<p> 
						This data type is not defined to generally represent rational
						numbers. It is used only if common factors in numerator and
						denominator are not supposed to cancel out. This is only rarely the
						case. For observation values, ratios occur almost exclusively with
						titers.
					</p>
				</note>
				<exhibit role="dtdl" id="dtdl-RTO">
					<anchor id="dtdl-RTO"/>
					<caption/>
					<pre>
template&lt;QTZ N, QTZ D&gt;
type Ratio&lt;N, D&gt; alias RTO&lt;N, D&gt; specializes QTY {
   N         numerator;
   D         denominator;
   literal   ST.SIMPLE;
   demotion  REAL;
   demotion  PQ;
};</pre>
				</exhibit>
				<p>
					The default value for both numerator and denominator is the integer
					number 1 (one). The denominator may not be zero.
				</p>
				<note>
					<p> 
						This data type is defined as a generic data type so that it can
						be constrained precisely as to what the numerator and denominator
						types should be.
					</p>
				</note>
				<div3 id="prop-RTO.numerator">
					<head>Numerator (numerator) : <termref ref="dt-N">N</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The quantity that is being divided in the ratio.  The default is the
						integer number 1 (one).
					</p>
				</div3>
				<div3 id="prop-RTO.denominator">
					<head>Denominator (denominator) : <termref ref="dt-D">D</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The quantity that devides the numerator in the ratio.  The default is
						the integer number 1 (one).  The denominator SHALL not be zero.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(RTO x)
      where x.nonNull {
   x.denominator.isZero.not;
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-RTO.literal">
					<head>Literal Form</head>
					<p>
						A ratio literal form exists for all ratios where both numerator and
						denominators have literal forms. A ratio is simply the numerator
						literal a colon as separator followed by the denominator literal. When
						the colon and denominator are missing, the integer number 1 is assumed
						as the denominator.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
RTO.literal ST.SIMPLE {
   RTO : QTY          { $.numerator.equal($1);
                        $.denominator.equal((INT)1); };
       | QTZ ":" QTZ  { $.numerator.equal($1);
                        $.denominator.equal($3); };
};</pre>
					</exhibit>
					<p>
						For example, the rubella virus antibody titer value 1:64 could be
						represented using the literal "1:64".
					</p>
				</div3>
				<div3 id="prop-RTO.demotionREAL">
					<head>Demotion To REAL (demotion) : <termref ref="dt-REAL">REAL</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						A ratio can be demoted to a real by dividing the numerator by the denominator. 
					</p>
					<p>
						The numerator and denominator are converted to a REAL prior to the operation. 
					</p>
				</div3>
				<div3 id="prop-RTO.demotionPQ">
					<head>Demotion To PQ (demotion) : <termref ref="dt-PQ">PQ</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						A ratio can be demoted to a physical quantity by dividing the numerator by the denominator. The units
						are derived by dividing the units for the numerator by the units for the denominator. 
					</p>
					<p>
						The the numerator or denominator are not physical quantities, they must first be converted
						to a REAL and promoted to <termref ref="dt-PQ">PQ</termref> by assigning the unit "1". 
					</p>
				</div3>
				<div3 id="prop-RTO.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<argument name="x" type="RTO"/>
					<p>
						Two nonNull <emph>RTO</emph>s are equal if their numerator and denominator are equal.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(RTO x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.numerator.equal(y.numerator).and(x.denominator.equal(y.denominator)));
};</pre>
					</exhibit>
				</div3>
			</div2>
			<div2 id="dt-PQ">
				<anchor id="PQ"/>
				<head>PhysicalQuantity (PQ) specializes <termref ref="dt-QTZ">QTZ</termref>
				</head>
				<p>
					<emph role="strong">Definition:     </emph>
					A dimensioned quantity expressing the result of measuring.
				</p>
				<table id="dt-PQ-prop-summary">
					<caption>Property Summary of
      PhysicalQuantity</caption>
					<col width="79"/>
					<col width="60"/>
					<col width="413"/>
					<thead>
						<tr>
							<th>Name</th>
							<th>Type</th>
							<th>Description</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>
								<termref ref="prop-PQ.value">value</termref>
							</td>
							<td>
								<termref ref="dt-REAL">REAL</termref>
							</td>
							<td>
						The magnitude of the quantity measured in terms of the unit.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-PQ.unit">unit</termref>
							</td>
							<td>
								<termref ref="dt-CS">CS</termref>
							</td>
							<td>
						The unit of measure specified in the Unified Code for Units of Measure
						(UCUM) [<loc href="http://aurora.regenstrief.org/ucum" xlink-form="simple" show="embed" actuate="auto"/>]. The default
						unit is 1.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-PQ.codingRationale">codingRationale</termref>
							</td>
							<td>
								<termref ref="dt-SET">SET</termref>&lt;<termref ref="dt-CS">CS</termref>&gt;</td>
							<td>
					    CodingRationale provides a reason why a particular <emph>PQ</emph> has been provided, either as the
						root concept or as one of the translations.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-PQ.translation">translation</termref>
							</td>
							<td>
								<termref ref="dt-DSET">DSET</termref>&lt;<termref ref="dt-PQR">PQR</termref>&gt;</td>
							<td>
						An alternative representation of the same physical quantity expressed
						in a different unit, of a different unit code system and possibly with
						a different value.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-PQ.canonical">canonical</termref>
							</td>
							<td>
								<termref ref="dt-PQ">PQ</termref>
							</td>
							<td>
						A physical quantity expressed in a canonical unit. In any given unit
						system has every physical dimension can be assigned one canonical unit
						Defining the canonical unit is not subject of this specification, only
						asserting that such a canonical unit exists (and can be arbitrarily
						chosen) for every physical quantity. An abstract physical quantity is
						equal to its canonical form.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-PQ.diffType">diffType</termref>
							</td>
							<td>
								<termref ref="dt-TYPE">TYPE</termref>
							</td>
							<td>
						The type of the difference between two values of a specific QTY data type. The data type
						of the difference quantity is related to the operand quantities but need not be the same.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-PQ.isOne">isOne</termref>
							</td>
							<td>
								<termref ref="dt-BL">BL</termref>
							</td>
							<td>
						A predicate indicating if this value is the number one, i.e., the
						neutral element of multiplication. There is exactly one physical
						quantity that has this property and is called <emph>the unity</emph>.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-PQ.negated">negated</termref>
							</td>
							<td>
								<termref ref="dt-PQ">PQ</termref>
							</td>
							<td>
						A <emph>PQ</emph> value, which, when added to another <emph>PQ</emph> value yields
						zero (the neutral element of addition).
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-PQ.inverted">inverted</termref>
							</td>
							<td>
								<termref ref="dt-PQ">PQ</termref>
							</td>
							<td>
						A <emph>PQ</emph> value, which, when muliplied with another <emph>PQ</emph> value
						yields one (the neutral element of multiplication). Zero (the neutral
						element of addition) has no inverse element.  The quotient of two
						comparable quantities is comparable to the unity (the unit 1).
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-PQ.demotionREAL">demotion</termref>
							</td>
							<td>
								<termref ref="dt-REAL">REAL</termref>
							</td>
							<td/>
						</tr>
					</tbody>
				</table>
				<exhibit role="dtdl" id="dtdl-PQ">
					<anchor id="dtdl-PQ"/>
					<caption/>
					<pre>
type PhysicalQuantity alias PQ specializes QTZ {
            REAL      value;
            CS        unit;
            SET&lt;CS&gt;   codingRationale;
            DSET&lt;PQR&gt; translation;

            PQ        canonical;
            PQ        plus(QTY x);
            BL        isOne;
            PQ        times(REAL x);
            PQ        dividedBy(REAL x);
            PQ        times(PQ x);
            PQ        dividedBy(PQ x);
            PQ        negated;
            PQ        inverted;
            PQ        power(INT x);

  literal   ST.SIMPLE;
  promotion  PQ  (REAL x);
  demotion  REAL;
};</pre>
				</exhibit>
				<div3 id="prop-PQ.value">
					<head>Maginitude Value (value) : <termref ref="dt-REAL">REAL</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The magnitude of the quantity measured in terms of the unit.
					</p>
				</div3>
				<div3 id="prop-PQ.unit">
					<head>Unit of Measure (unit) : <termref ref="dt-CS">CS</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The unit of measure specified in the Unified Code for Units of Measure
						(UCUM) [<loc href="http://aurora.regenstrief.org/ucum" xlink-form="simple" show="embed" actuate="auto"/>]. The default
						unit is 1.
					</p>
					<p>
						UCUM defines two forms of expression, case sensitive and case insensitive.
						<emph>PQ</emph> uses the case sensitive codes. The codeSystem OID for the case
						sensitive form is 2.16.840.1.113883.6.8.
					</p>
					<note>
						<p>
							Equality of physical quantities does not require the values and units
							to be equal independently. Value and unit is only how we represent
							physical quantities. For example, 1 m equals 100 cm. Although the
							units are different and the values are different, the physical
							quantities are equal.  Therefore one should never expect a particular
							unit for a physical quantity but instead provide automated conversion
							between different comparable units.
						</p>
					</note>
					<p>
							The unit SHALL come from UCUM, which only specifies unambiguous measurement units.
							Sometimes it is not clear how some measurements in healthcare map to UCUM
							codes. The general pattern for a measurement is <span style="background: yellow">
							value </span>
						<span style="background: pink">unit </span> of <span style="background: Aqua">Thing</span>.
							In this scheme, the <emph>PQ</emph> represents the <span style="background: yellow">
							value</span> and the <span style="background: pink">unit</span>, and the
							<span style="background: Aqua">Thing</span> is described by some coded concept that
							is linked to the <emph>PQ</emph> by the context of use. This maps obviously to some
							measurements, such as <span style="background: Aqua">Patient Body Temperature</span> of
							<span style="background: yellow">37 </span>
						<span style="background: pink">Celsius</span>,
							and <span style="background: yellow">250 </span>
						<span style="background: pink">mg/day</span> 
							of <span style="background: Aqua">Salicylate</span>. 
						</p>
					<p>
							However for some measurements that arise in healthcare, the scheme is not so obvious.
							Two classic examples are 5 Drinks of Beer, and 3 Acetominophen tablets. At first glance
							it is tempting to classify these measurments like this: <span style="background: yellow">5 </span>
						<span style="background: pink">drinks</span> of <span style="background: Aqua">Beer</span> 
							and <span style="background: yellow">3 </span>
						<span style="background: Aqua">Acetominophen </span>
						<span style="background: pink">tablets</span>. The problem with this is that UCUM does not 
							support units of "beer", "tablets" or "scoops". 
						</p>
					<p>
							The reason for this is that neither tablets or scoops are proper units. What kind of tablets?
							How big is the scoop? In these kinds of cases, the concept that appears to be a unit needs to 
							further specified before interoperability is established. If a correct amount is required, then
							it is generally appropriate to specify an exact measurement with an appropriate UCUM unit. If
							this is not possible, then the concept is not part of the measurement. UCUM provides a unit called
							unity for use in these cases. The proper way to understand these measurements as
							<span style="background: yellow">3 </span>
						<span style="background: pink">1 </span>
						<span style="background: Aqua">Acetominophen </span>
						<span style="background: lime">tablets</span>, where 1 is the UCUM unit for unity, and
							the <span style="background: Aqua">Thing</span> has a <span style="background: lime">qualifier</span>.
							It is occasionally possible to use a <termref ref="dt-CD">CD</termref>
						<termref ref="CD.qualifier">.qualifier</termref> to qualify the concept of
							the Thing directly, but usually there will be a need for extra information to clarify the measurements
							associated with the qualifying concept, and some further component observation would be required.
							<footnote>
							<p>HL7 is preparing a document that contains common usage patterns that
					will discuss how to best use the PQ type in common healthcare measurement use cases.</p>
						</footnote>
					</p>
				</div3>
				<div3 id="prop-PQ.codingRationale">
					<head>Coding Rationale (codingRationale) : <termref ref="dt-SET">SET</termref>&lt;<termref ref="dt-CS">CS</termref>&gt;</head>
					<p>
						<emph role="strong">Definition:     </emph>
					    CodingRationale provides a reason why a particular <emph>PQ</emph> has been provided, either as the
						root concept or as one of the translations.
					</p>
					<table id="domain-CodingRationale">
						<caption>Concept Domain CodingRationale. ValueSet OID:  2.16.840.1.113883.11.19250. CodeSystem "CodingRationale", OID: 2.16.840.1.113883.5.1074, Owner: HL7</caption>
						<thead>
							<tr valign="bottom">
								<th>lvl</th>
								<th>code</th>
								<th>name</th>
								<th>definition</th>
							</tr>
						</thead>
						<tr valign="top">
							<td>1</td>
							<td>O</td>
							<td>Original</td>
							<td>
								<p>Originally produced code</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>P</td>
							<td>Post-coded</td>
							<td>
								<p>Post-coded from free text source</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>R</td>
							<td>Required</td>
							<td>
								<p>Required standard code for HL7</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>OR</td>
							<td>Original &amp; Required</td>
							<td>
								<p>Originally produced code, required by HL7</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>PR</td>
							<td>Post-coded &amp; Required</td>
							<td>
								<p>Post-coded from free text source, required by HL7</p>
							</td>
						</tr>
					</table>
				</div3>
				<div3 id="prop-PQ.translation">
					<head>Translation (translation) : <termref ref="dt-DSET">DSET</termref>&lt;<termref ref="dt-PQR">PQR</termref>&gt;</head>
					<p>
						<emph role="strong">Definition:     </emph>
						An alternative representation of the same physical quantity expressed
						in a different unit, of a different unit code system and possibly with
						a different value.
					</p>
				</div3>
				<div3 id="prop-PQ.canonical">
					<head>Canonical Form (canonical) : <termref ref="dt-PQ">PQ</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						A physical quantity expressed in a canonical unit. In any given unit
						system has every physical dimension can be assigned one canonical unit
						Defining the canonical unit is not subject of this specification, only
						asserting that such a canonical unit exists (and can be arbitrarily
						chosen) for every physical quantity. An abstract physical quantity is
						equal to its canonical form.
					</p>
					<p>
					Physical quantities semantically are the results of measurement
					acts. Although physical quantities are represented as pairs of value
					and unit, semantically, a physical quantity is more than that. To find
					out whether two physical quantities are equal, it is not enough to
					compare equality of their two values and units independently. For
					example, 100 cm equals 1 m although neither values nor units are
					equal. To define equality we introduce the notion of a canonical form.
				</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(PQ x)
      where x.nonNull {
   x.canonical.equal(x);
};</pre>
					</exhibit>
					<p>
						For example, for a unit system based on the Système
						International (SI) one can define the canonical form as (a) the
						product of only the base units; (b) without prefixes; where (c) only
						multiplication and exponents are used (no division operation); and (d)
						where the seven base units appear in a defined ordering (e.g., m, s,
						g...) Thus, 1 mm Hg would be expressed as 133322 g.m<emph role="sup">-1</emph>
						s<emph role="sup">-2</emph>. As can be seen, the rules how to build the canonical
						form of units may be quite complex. However, for the semantic
						specification it doesn't matter how the canonical form is built, nor
						what specific canonical form is chosen, only that <emph>some</emph>
						canonical form <emph>could</emph> be defined.
					</p>
				</div3>
				<div3 id="prop-PQ.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<p>
						Two physical quantities are equal if their values (including precision) and their units
						of their canonical forms are equal.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(PQ x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.canonical.value
             .equal(y.canonical.value).and(
                x.canonical.unit.equal(y.canonical.unit)));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-PQ.isComparableTo">
					<head>Is Comparable To (isComparableTo) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-QTY">QTY</termref>
					</head>
					<p>
						Two physical quantities can be compared to each other (and have an ordering and
						difference) if the units of their canonical forms are equal.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(PQ x, y)
      where x.nonNull.and(y.nonNull) {
   x.isComparableTo(y).equal(x.canonical.unit.equal(y.canonical.unit));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-PQ.diffType">
					<head>DifferenceDataType (diffType) : <termref ref="dt-TYPE">TYPE</termref>, inherited from <termref ref="dt-QTY">QTY</termref>
					</head>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(PQ x) {
   x.diffType.implies(PQ);
};</pre>
					</exhibit>
					<p>
						The difference between 2 Physical Quantities is another Physical Quantity with
						the same units.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(PQ x, y)
      where x.nonNull.and(x.isComparableTo(y)) {
   x.minus(y).canonical.unit.implies(x.canonical.unit);
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-PQ.plus">
					<head>Addition (plus) : <termref ref="dt-PQ">PQ</termref>
					</head>
					<argument name="x" type="QTY"/>
					<p>
						<emph role="strong">Definition:     </emph>
						Two physical quantities that can be compared to each other can be added.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (PQ x, y)
      where x.nonNull.and(x.isComparableTo(y)) {
   x.canonical.plus(y.canonical).value.equal(
      x.canonical.value.plus(y.canonical.value));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-PQ.isOne">
					<head>Neutral Element of Multiplication (isOne) : <termref ref="dt-BL">BL</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						A predicate indicating if this value is the number one, i.e., the
						neutral element of multiplication. There is exactly one physical
						quantity that has this property and is called <emph>the unity</emph>.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(PQ x, y)
      where x.nonNull.and(y.nonNull) {
   x.isOne.and(y.isOne).implies(x.equal(y));
   x.isOne.and(y.isZero).implies(x.equal(y).not);
};</pre>
					</exhibit>
				</div3>
				<!--
	 this text is not necessary
				<p>
					Algebraic operations are defined for physical quantities because they
					are characterizing operations in the sense of ISO 11404 and because
					this specification makes use of them when defining the literal form.
				</p>
  -->
				<div3 id="prop-PQ.timesReal">
					<head>Real Multiplication (times) : <termref ref="dt-PQ">PQ</termref>
					</head>
					<argument name="x" type="REAL"/>
					<p>
						<emph role="strong">Definition:     </emph>
						Multiplication with a real number forms a scaled quantity. A scaled
						quantity is comparable to its original quantity.
					</p>
					<p>
						If two quantities <emph>Q</emph>
						<emph role="sub">1</emph> and
						<emph>Q</emph>
						<emph role="sub">2</emph> can be compared to each other, there
						exists a real number <emph>r</emph> such that <emph>r</emph>
						<emph role="strong">1</emph> = <emph>Q</emph>
						<emph role="sub">1</emph> / <emph>Q</emph>
						<emph role="sub">2</emph>.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(PQ x; REAL r)
      where x.nonNull.and(r.nonNull) {
   x.times(r).value.equal(x.value.times(r));
   x.times(r).isComparableTo(x);
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-PQ.dividedBy">
					<head>Standard Division (dividedBy) : <termref ref="dt-PQ">PQ</termref>
					</head>
					<argument type="REAL" name="x"/>
					<p>
						<emph role="strong">Definition:     </emph>
						Scalar division of the value property.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(PQ dividend, REAL divisor)
      where dividend.nonNull.and(divisor.nonNull).and(divisor.isZero.not) {
   dividend.dividedBy(divisor).value.equal(dividend.value.dividedBy(divisor));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-PQ.times">
					<head>Multiplication (times) : <termref ref="dt-PQ">PQ</termref>
					</head>
					<argument name="x" type="PQ"/>
					<p>
						<emph role="strong">Definition:     </emph>
						The product of two physical quantities is the product of their values
						times the product of their units.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(PQ x, y, z, i, o)
      where x.nonNull.and(y.nonNull).and(z.nonNull)
             .and(o.isZero).and(i.isOne) {
   x.times(o).equal(o);
   x.times(i).equal(x);             /* neutral element */
   x.times(y).times(z).equal(
            x.times(y.times(z)));   /* associative */
   x.times(y).equal(y.times(x));    /* commutative */
   o.lessOrEqual(x).and(o.lessOrEqual(y).implies(o.lessOrEqual(x.times(y))));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-PQ.dividedBy">
					<head>Standard Division (dividedBy) : <termref ref="dt-PQ">PQ</termref>
					</head>
					<argument type="PQ" name="x"/>
					<p>
						<emph role="strong">Definition:     </emph>
						The division of one physical quantities (dividend) by another (divisor) is the division of their values
						times the division of their units.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(PQ dividend, PQ divisor)
      where dividend.nonNull.and(divisor.nonNull).and(divisor.isZero.not) {
   dividend.isZero.implies(dividend.dividedBy(divisor).isZero);
   dividend.isZero.not.implies(dividend.dividedBy(divisor).equals(dividend.times(divisor.inverted)));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-PQ.negated">
					<head>Negation (Inverse Element of Addition) (negated) : <termref ref="dt-PQ">PQ</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						A <emph>PQ</emph> value, which, when added to another <emph>PQ</emph> value yields
						zero (the neutral element of addition).
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(PQ x)
      where x.nonNull {
   x.plus(x.negated).isZero;
   x.negated.unit.equals(x.unit);
   x.negated.value.equals(x.value.negated);
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-PQ.inverted">
					<head>Inverse Element of Multiplication (inverted) : <termref ref="dt-PQ">PQ</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						A <emph>PQ</emph> value, which, when muliplied with another <emph>PQ</emph> value
						yields one (the neutral element of multiplication). Zero (the neutral
						element of addition) has no inverse element.  The quotient of two
						comparable quantities is comparable to the unity (the unit 1).
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(PQ this, that, one)
      where this.nonNull.and(that.nonNull).and(one.isOne) {
   this.times(this.inverted).equal(one);
   this.isComparableTo(that).implies(this.times(that.inverted).equal(one));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-PQ.power">
					<head>Exponentiation (power) : <termref ref="dt-PQ">PQ</termref>
					</head>
					<argument type="INT" name="x"/>
					<p>
						<emph role="strong">Definition:     </emph>
						A physical quantity can be raised to an integer power.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (PQ x, i; INT n, o) 
      where x.nonNull.and(i.isOne).and(n.nonNull.and(o.isZero)) {
   x.power(o).equal(i);
   n.greaterThan(o).implies(
      x.power(n).equal(x.times(x.power(n.predecessor))));
   n.lessThan(o).implies(
      x.power(n).equal(x.power(n.negated).inverted));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-PQ.literal">
					<head>Literal Form</head>
					<p>
						The literal form for a physical quantity is a real number literal
						followed by optional whitespace and a character string representing a
						valid code in the Unified Code for Units of Measure (UCUM)
						[<loc href="http://aurora.regenstrief.org/ucum" xlink-form="simple" show="embed" actuate="auto"/>].
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
PQ.literal ST.SIMPLE {
   PQ       : REAL unit    { $.value.equal($1);
                             $.unit.equal($2); }
   CS  unit : ST           { $.value.equal($1);
                             $.codeSystem.equal(2.16.840.1.113883.6.8); };
};</pre>
					</exhibit>
					<p>
						For example, 20 minutes is "20 min".
					</p>
				</div3>
				<div3 id="prop-PQ.promotion">
					<head>Promotion of REAL to PQ (promotion) : <termref ref="dt-PQ">PQ</termref>
					</head>
					<argument name="x" type="REAL"/>
					<p>
						A <termref ref="dt-REAL">REAL</termref> value can be converted to a <emph>PQ</emph> value
						with the unity, i.e. the unit <emph role="strong">1</emph> (one).
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(PQ x, unity) 
      where x.nonNull.and.unity.isOne.and(x.isComparableTo(unity)) {
   unity.times((REAL)x).equal(x);
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-PQ.demotionREAL">
					<head>Demotion to REAL (demotion) : <termref ref="dt-REAL">REAL</termref>
					</head>
					<p>
						If a <emph>PQ</emph> can be compared to unity can be converted
						to a <termref ref="dt-REAL">REAL</termref> number.
					</p>
				</div3>
			</div2>
			<div2 id="dt-PQR">
				<anchor id="PQR"/>
				<head>PhysicalQuantityRepresentation (PQR) specializes <termref ref="dt-CV">CV</termref>
				</head>
				<p>
					<emph role="strong">Definition:     </emph>
					An extension of the coded value data type representating a physical
					quantity using a unit from any code system. Used to show alternative
					representation for a physical quantity.
				</p>
				<table id="dt-PQR-prop-summary">
					<caption>Property Summary of
      PhysicalQuantityRepresentation</caption>
					<col width="79"/>
					<col width="60"/>
					<col width="413"/>
					<thead>
						<tr>
							<th>Name</th>
							<th>Type</th>
							<th>Description</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>
								<termref ref="prop-PQR.value">value</termref>
							</td>
							<td>
								<termref ref="dt-REAL">REAL</termref>
							</td>
							<td>
						The magnitude of the measurement value in terms of the unit
						specified by this code.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-PQR.code">code</termref>
							</td>
							<td>
								<termref ref="dt-ST.SIMPLE">ST.SIMPLE</termref>
							</td>
							<td>
						The code for the unit.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-PQR.codeSystem">codeSystem</termref>
							</td>
							<td>
								<termref ref="dt-UID">UID</termref>
							</td>
							<td>
						The identifier for the codeSystem from which the unit is taken.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-PQR.codeSystemName">codeSystemName</termref>
							</td>
							<td>
								<termref ref="dt-ST.NT">ST.NT</termref>
							</td>
							<td>
						The name of the codeSystem from which the unit is taken.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-PQR.codeSystemVersion">codeSystemVersion</termref>
							</td>
							<td>
								<termref ref="dt-ST.SIMPLE">ST.SIMPLE</termref>
							</td>
							<td>
						The version for the codeSystem from which the unit is taken, if applicable.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-PQR.displayName">displayName</termref>
							</td>
							<td>
								<termref ref="dt-ST">ST</termref>
							</td>
							<td>
						The displayName for the unit, if applicable.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-PQR.originalText">originalText</termref>
							</td>
							<td>
								<termref ref="dt-ED.TEXT">ED.TEXT</termref>
							</td>
							<td>
								<emph>PQR</emph> is a translation of a PQ which has an
						originalText, so originalText is prohibited in <emph>PQR</emph>.
					</td>
						</tr>
					</tbody>
				</table>
				<exhibit role="dtdl">
					<caption/>
					<pre>
protected type PhysicalQuantityRepresentation alias PQR specializes CV {
   REAL  value;
};</pre>
				</exhibit>
				<div3 id="prop-PQR.value">
					<head>Value (value) : <termref ref="dt-REAL">REAL</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The magnitude of the measurement value in terms of the unit
						specified by this code.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(PQR x)
    where x.nonNull {
  x.value.nonNull;
};</pre>
					</exhibit>
					<p>
						A value SHALL be provided if the translation is nonNull.
					</p>
				</div3>
				<div3 id="prop-PQR.code">
					<head>Code (code) : <termref ref="dt-ST.SIMPLE">ST.SIMPLE</termref>, inherited from <termref ref="dt-CD">CD</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The code for the unit.
					</p>
					<p>
						This is <termref ref="prop-CD.code">CD.code</termref>.
					</p>
				</div3>
				<div3 id="prop-PQR.codeSystem">
					<head>Code System (codeSystem) : <termref ref="dt-UID">UID</termref>, inherited from <termref ref="dt-CD">CD</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The identifier for the codeSystem from which the unit is taken.
					</p>
					<p>
						This is <termref ref="prop-CD.codeSystem">CD.codeSystem</termref>.
					</p>
				</div3>
				<div3 id="prop-PQR.codeSystemName">
					<head>Code System Name (codeSystemName) : <termref ref="dt-ST.NT">ST.NT</termref>, inherited from <termref ref="dt-CD">CD</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The name of the codeSystem from which the unit is taken.
					</p>
					<p>
						This is <termref ref="prop-CD.codeSystemName">CD.codeSystemName</termref>.
					</p>
				</div3>
				<div3 id="prop-PQR.codeSystemVersion">
					<head>Code System Version (codeSystemVersion) : <termref ref="dt-ST.SIMPLE">ST.SIMPLE</termref>, inherited from <termref ref="dt-CD">CD</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The version for the codeSystem from which the unit is taken, if applicable.
					</p>
					<p>
						This is <termref ref="prop-CD.codeSystemVersion">CD.codeSystemVersion</termref>.
					</p>
				</div3>
				<div3 id="prop-PQR.displayName">
					<head>Display Name (displayName) : <termref ref="dt-ST">ST</termref>, inherited from <termref ref="dt-CD">CD</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The displayName for the unit, if applicable.
					</p>
					<p>
						This is <termref ref="prop-CD.displayName">CD.displayName</termref>.
					</p>
				</div3>
				<div3 id="prop-PQR.originalText">
					<head>Original Text (originalText) : <termref ref="dt-ED.TEXT">ED.TEXT</termref>, inherited from <termref ref="dt-CD">CD</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						<emph>PQR</emph> is a translation of a PQ which has an
						originalText, so originalText is prohibited in <emph>PQR</emph>.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(PQR x) {
   x.originalText.notApplicable;
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-PQR.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<argument name="x" type="PQR"/>
					<p>
						Two nonNull <emph>PQR</emph>s are equal if they have the same value,
						and the <termref ref="dt-CD">CD</termref> equality criteria are met.<footnote>
							<p>
								This means that values of the values of the type PQR can not be equal with CD, CS, CO, or CV values.
							</p>
						</footnote>
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(PQR x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.value.equal(y.value).and(((CD)x).equal((CD)y)));
};</pre>
					</exhibit>
				</div3>
			</div2>
			<div2 id="dt-MO">
				<anchor id="MO"/>
				<head>MonetaryAmount (MO) specializes <termref ref="dt-QTZ">QTZ</termref>
				</head>
				<p>
					<emph role="strong">Definition:     </emph>
					A quantity expressing an amount of money in some
					currency. While the monetary amount
					is a single kind of quantity (money) the exchange rates between the
					different units are variable.  This is the principle difference
					between <termref ref="dt-PQ">PQ</termref> and <emph>MO</emph>, and the reason why
					currency units are not physical units.
				</p>
				<p/>
				<table id="dt-MO-prop-summary">
					<caption>Property Summary of
      MonetaryAmount</caption>
					<col width="79"/>
					<col width="60"/>
					<col width="413"/>
					<thead>
						<tr>
							<th>Name</th>
							<th>Type</th>
							<th>Description</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>
								<termref ref="prop-MO.value">value</termref>
							</td>
							<td>
								<termref ref="dt-REAL">REAL</termref>
							</td>
							<td>
							The magnitude of the <emph>MO</emph> in terms of <termref ref="prop-MO.currency">currency</termref>.
						</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-MO.currency">currency</termref>
							</td>
							<td>
								<termref ref="dt-CS">CS</termref>
							</td>
							<td>
							The currency unit as defined in ISO 4217.
						</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-MO.diffType">diffType</termref>
							</td>
							<td>
								<termref ref="dt-TYPE">TYPE</termref>
							</td>
							<td>
						The type of the difference between two values of a specific QTY data type. The data type
						of the difference quantity is related to the operand quantities but need not be the same.
					</td>
						</tr>
					</tbody>
				</table>
				<exhibit role="dtdl" id="dtdl-MO">
					<anchor id="dtdl-MO"/>
					<caption/>
					<pre>
type MonetaryAmount alias MO specializes QTZ {
           REAL  value;
           CS    currency;
           MO    plus(MO x);
           MO    times(REAL x);
           MO    dividedBy(REAL x);
   literal ST.SIMPLE;
};</pre>
				</exhibit>
				<div3 id="prop-MO.value">
					<head>Value (value) : <termref ref="dt-REAL">REAL</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
							The magnitude of the <emph>MO</emph> in terms of <termref ref="prop-MO.currency">currency</termref>.
						</p>
					<note>
						<p>
							<emph>MO</emph> values are usually precise to 0.01 (one cent, penny, paisa,
								etc.).  For large amounts, it is important not to store <emph>MO</emph> values
								in floating point registers, since this may lose
								precision. However, this specification does not define the internal
								storage of <termref ref="dt-REAL">REAL</termref> as fixed or floating point numbers.
							</p>
					</note>
					<p>
						<termref ref="prop-REAL.precision">REAL.precision</termref> is the precision of
							the decimal representation, not the precision of the value. <termref ref="dt-REAL">REAL</termref>
							has no notion of uncertainty or accuracy. For example,
							"1.99 USD" (precision 3) times 7 is "13.93 USD" (precision 4) and
							should not be rounded to "13.9" to keep the precision constant.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(MO x) where x.nonNull {
  x.value.nonNull;
}</pre>
					</exhibit>
					<p>
							A value is required.
						</p>
				</div3>
				<div3 id="prop-MO.currency">
					<head>Currency (currency) : <termref ref="dt-CS">CS</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
							The currency unit as defined in ISO 4217.
						</p>
					<table id="domain-Currency">
						<caption>Concept Domain Currency. ValueSet OID:  2.16.840.1.113883.11.17388. CodeSystem "Currency", OID: 2.16.840.1.113883.5.1058, Owner: ISO 4217</caption>
						<thead>
							<tr valign="bottom">
								<th>lvl</th>
								<th>code</th>
								<th>name</th>
								<th>definition</th>
							</tr>
						</thead>
						<tr valign="top">
							<td>1</td>
							<td>ARS</td>
							<td>Argentine Peso</td>
							<td>
								<p>Argentine Peso, monetary currency of Argentina</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>AUD</td>
							<td>Australian Dollar</td>
							<td>
								<p>Australian Dollar, monetary currency of Australia</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>THB</td>
							<td>Baht</td>
							<td>
								<p>Baht, monetary currency of Thailand</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>BRL</td>
							<td>Brazilian Real</td>
							<td>
								<p>Brazilian Real, monetary currency of Brazil</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>CAD</td>
							<td>Canadian Dollar</td>
							<td>
								<p>Canadian Dollar, monetary currency of Canada</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>DEM</td>
							<td>Deutsche Mark</td>
							<td>
								<p>Deutsche Mark, monetary currency of Germany</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>EUR</td>
							<td>Euro</td>
							<td>
								<p>Euro, monetary currency of European Union</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>FRF</td>
							<td>French Franc</td>
							<td>
								<p>French Franc, monetary currency of France</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>INR</td>
							<td>Indian Rupee</td>
							<td>
								<p>Indian Rupee, monetary currency of India</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>TRL</td>
							<td>Lira</td>
							<td>
								<p>Lira, monetary currency of Turkey</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>FIM</td>
							<td>Markka</td>
							<td>
								<p>Markka, monetary currency of Finland</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>MXN</td>
							<td>Mexican Nuevo Peso</td>
							<td>
								<p>Mexican Nuevo Peso, monetary currency of Mexico</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>NLG</td>
							<td>Netherlands Guilder</td>
							<td>
								<p>Netherlands Guilder, monetary currency of Netherlands</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>NZD</td>
							<td>New Zealand Dollar</td>
							<td>
								<p>New Zealand Dollar, monetary currency of New Zealand</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>PHP</td>
							<td>Philippine Peso</td>
							<td>
								<p>Philippine Peso, monetary currency of Philippines</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>GBP</td>
							<td>Pound Sterling</td>
							<td>
								<p>Pound Sterling, monetary currency of United Kingdom</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>ZAR</td>
							<td>Rand</td>
							<td>
								<p>Rand, monetary currency of South Africa</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>RUR</td>
							<td>Russian Ruble</td>
							<td>
								<p>Russian Ruble, monetary currency of Russian Federation</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>ILS</td>
							<td>Shekel</td>
							<td>
								<p>Shekel, monetary currency of Israel</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>ESP</td>
							<td>Spanish Peseta</td>
							<td>
								<p>Spanish Peseta, monetary currency of Spain</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>CHF</td>
							<td>Swiss Franc</td>
							<td>
								<p>Swiss Franc, monetary currency of Switzerland</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>TWD</td>
							<td>Taiwan Dollar</td>
							<td>
								<p>Taiwan Dollar, monetary currency of Taiwan</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>USD</td>
							<td>US Dollar</td>
							<td>
								<p>US Dollar, monetary currency of United States</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>CLF</td>
							<td>Unidades de Formento</td>
							<td>
								<p>Unidades de Formento, monetary currency of Chile</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>KRW</td>
							<td>Won</td>
							<td>
								<p>Won, monetary currency of Korea (South)</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>JPY</td>
							<td>Yen</td>
							<td>
								<p>Yen, monetary currency of Japan</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>CNY</td>
							<td>Yuan Renminbi</td>
							<td>
								<p>Yuan Renminbi, monetary currency of China</p>
							</td>
						</tr>
					</table>
					<p>
							Note: the OID specified here will be changing to a new OID once a new OID is agreed in association with ISO. 
						</p>
					<p>
							This table only shows a representative subset of the
							codes defined by ISO 4217. All codes from ISO 4127 are
							valid for this attribute.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(MO x) where x.nonNull {
  x.currency.nonNull;
}</pre>
					</exhibit>
					<p>
							A currency SHALL be provided.
						</p>
				</div3>
				<div3 id="prop-MO.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<p>
							Two <emph>MO</emph> values are equal if both <termref ref="prop-MO.value">value</termref> and
							<termref ref="prop-MO.currency">currency</termref> are equal.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(MO x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.value.equal(y.value)
             .and(x.unit.equal(y.unit)));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-MO.isComparableTo">
					<head>Is Comparable To (isComparableTo) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-QTY">QTY</termref>
					</head>
					<p>
							Two <emph>MO</emph> values can be compared to each other (and have an ordering and
							difference) if their <termref ref="prop-MO.currency">currency</termref>s are equal.
						</p>
					<p>
							If their <termref ref="prop-MO.currency">currency</termref>s are not identical,
							the <termref ref="prop-MO.values">values</termref> cannot be
							compared. Conversion between currencies is outside the scope of
							this specification. In practice, foreign exchange rates are highly
							variable not only over long and short amounts of time, but also
							depending on location and access to currency trade markets.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(MO x, y)
      where x.nonNull.and(y.nonNull) {
   x.isComparableTo(y).equal(x.currency.equal(y.currency));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-MO.diffType">
					<head>DifferenceDataType (diffType) : <termref ref="dt-TYPE">TYPE</termref>, inherited from <termref ref="dt-QTY">QTY</termref>
					</head>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(INT x) {
   x.diffType.implies(MO);
};</pre>
					</exhibit>
					<p>
							The difference between 2 <emph>MO</emph>s is another <emph>MO</emph>.
						</p>
				</div3>
				<div3 id="prop-MO.plus">
					<head>Addition (plus) : <termref ref="dt-MO">MO</termref>
					</head>
					<argument name="x" type="MO"/>
					<p>
						<emph role="strong">Definition:     </emph>
							Two <emph>MO</emph>s can be added if their
							<termref ref="prop-MO.currency">currency</termref>s are equal.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (MO x, y)
      where x.nonNull.and(y.nonNull).and(x.currency.equal(y.currency)) {
   x.plus(y).currency.equal(x.currency);
   x.plus(y).value.equal(x.value.plus(y.value));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-MO.timesREAL">
					<head>Real Multiplication (times) : <termref ref="dt-MO">MO</termref>
					</head>
					<argument name="x" type="REAL"/>
					<p>
						<emph role="strong">Definition:     </emph>
							Multiplication with a <termref ref="dt-REAL">REAL</termref> forms a scaled quantity. A scaled
							quantity is comparable to its original quantity.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(MO x; REAL r)
      where x.nonNull.and(r.nonNull) {
   x.times(r).value.equal(x.value.times(r));
   x.times(r).currency.equal(x.currency);
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-MO.dividedBy">
					<head>Standard Division (dividedBy) : <termref ref="dt-MO">MO</termref>
					</head>
					<argument type="REAL" name="x"/>
					<p>
						<emph role="strong">Definition:     </emph>
						Scalar division of the value property.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(MO dividend, REAL divisor)
      where dividend.nonNull.and(divisor.nonNull).and(divisor.isZero.not) {
   dividend.isZero.implies(dividend.dividedBy(divisor).isZero);
   dividend.isZero.not.implies(dividend.dividedBy(divisor).equals(dividend.times(divisor.inverted)));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-MO.literal">
					<head>Literal Form</head>
					<p>
							The literal form for an <emph>MO</emph> consists of a currency code string,
							optional whitespace, and a <termref ref="dt-REAL">REAL</termref> literal amount.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
MO.literal ST.SIMPLE {
   MO           : currency value  { $.currency.equal($1); }
                                    $.value.equal($2);
   CS  currency : ST              { $.currency.value.equal($1);
                                    $.currency.codeSystem
                                    .equal(2.16.840.1.113883.6.9); }
   REAL value   : REAL           { $.value.equal($1); }
};</pre>
					</exhibit>
					<p>
							For example, "USD189.95" is the literal for 189.95 U.S. Dollar.
						</p>
				</div3>
			</div2>
			<div2 id="dt-CAL">
				<anchor id="CAL"/>
				<head>Calendar (CAL) specializes <termref ref="dt-DSET">DSET</termref>&lt;<termref ref="dt-CLCY">CLCY</termref>&gt;</head>
				<p>
					<emph role="strong">Definition:     </emph>
					A calendar is a concept of measuring time in various cycles. Such
					cycles are years, months, days, hours, minutes, seconds, and
					weeks. Some of these cycles are synchronized and some are not (e.g.,
					weeks and months are not synchronized).
				</p>
				<p>
					After "rolling the time axis" into these cycles
					a calendar expresses a point in time as a sequence
					of integer counts of cycles, e.g., for year, month, day, hour,
					etc. The calendar is rooted in some conventional start point, called
					the "epoch."
				</p>
				<graphic source="graphics/datyp2fig9.gif" alt=""/>
				<p>
					A calendar "rolls" the time axis into a complex convolute according to
					the calendar periods year (blue), month (yellow), day (green), hour
					(red), etc. The cycles need not be aligned, for example, the week (not
					shown) is not aligned to the month.<footnote>
						<p>
							Imagine a special clock that measures those cycles, where the pointers
							are not all stacked on a common axis but each pointer is attached to
							the end of the pointer measuring the next larger cycle.
						</p>
					</footnote>
				</p>
				<p>
					Calendar is defined as a set of calendar cycles, and has a name and a
					code. The head of the Calendar is the largest CalendarCycle appearing
					right most in the calendar expression. The epoch is the beginning of
					that calendar, i.e., the point in time where all calendar cycles are
					zero.
				</p>
				<exhibit role="dtdl">
					<caption/>
					<pre>
private type Calendar alias CAL specializes DSET&lt;CLCY&gt;  {
   CS    name;
   CLCY  head;
   TS    epoch;
};</pre>
				</exhibit>
				<div3 id="prop-CAL.name">
					<head>Name (name) : <termref ref="dt-CS">CS</termref>
					</head>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(CAL c)
      where c.nonNull {
   c.name.nonNull;
   c.contains(c.head);
};</pre>
					</exhibit>
					<p>
					The calendar definition can be shown as in <tabref ref="domain-CalendarCycle"/>
					for the modern Gregorian calendar. The calendar definition table lists a
					calendar cycle in each row. The calendar units are dependent on each other and
					defined in the value column. The sequence column shows the relationship through
					the next property. The other columns are as in the formal calendar cycle
					definition.<footnote>
							<p> 
							At present, the CalendarCycle properties sum and value are not
							formally defined. The computation of calendar digits involves some
							complex computation which to specify here would be hard to understand
							and evaluate for correctness. Unfortunately, no standard exists that
							would formally define the relationship between calendar expressions
							and elapsed time since an epoch. ASN.1, the XML Schema Data Type
							specification and SQL92 all refer to ISO 8601, however, ISO 8601 does
							only specify the syntax of Gregorian calendar expressions, but not
							their semantics. In this standard, we define the syntax and semantics
							formally, however, we presume the semantics of the sum-, and
							value-properties to be defined elsewhere.  
						</p>
						</footnote>
					</p>
					<table id="domain-CalendarCycle">
						<caption>Concept Domain CalendarCycle. ValueSet OID:  2.16.840.1.113883.11.10684. CodeSystem "CalendarCycle", OID: 2.16.840.1.113883.5.9, Owner: HL7</caption>
						<thead>
							<tr valign="bottom">
								<th>name</th>
								<th>code 1</th>
								<th>code 2</th>
								<th>counter</th>
								<th>digits</th>
								<th>start</th>
								<th>condition</th>
							</tr>
						</thead>
						<tbody>
							<tr valign="top">
								<td>year </td>
								<td>Y </td>
								<td>CY </td>
								<td>1 </td>
								<td>4 </td>
								<td>0 </td>
								<td>MY12 </td>
							</tr>
							<tr valign="top">
								<td>month of the year </td>
								<td>M </td>
								<td>MY </td>
								<td>2 </td>
								<td>2 </td>
								<td>1 </td>
								<td>
							MY01,03,05,07,08,10,12 &#8594; DM31<br/>
							MY04,06,09,11 &#8594; DM30<br/>
							MY02 Y/4 Y/100 &#8594; DM28<br/>
							MY02 Y/4 &#8594; DM29<br/>
							MY02 &#8594; DM28<br/> </td>
							</tr>
							<tr valign="top">
								<td>month (continuous) </td>
								<td> </td>
								<td>CM </td>
								<td> </td>
								<td> </td>
								<td>0 </td>
								<td>continuous MY </td>
							</tr>
							<tr valign="top">
								<td>week of the month </td>
								<td>W </td>
								<td>WM </td>
								<td> </td>
								<td> </td>
								<td> </td>
								<td> </td>
							</tr>
							<tr valign="top">
								<td>week of the year </td>
								<td> </td>
								<td>WY </td>
								<td> </td>
								<td>2 </td>
								<td>1 </td>
								<td>continuous DW7 </td>
							</tr>
							<tr valign="top">
								<td>day of the month </td>
								<td>D </td>
								<td>DM </td>
								<td>3 </td>
								<td>2 </td>
								<td>1 </td>
								<td>HD24 </td>
							</tr>
							<tr valign="top">
								<td>day (continuous) </td>
								<td> </td>
								<td>CD </td>
								<td> </td>
								<td> </td>
								<td>0 </td>
								<td>CH24 </td>
							</tr>
							<tr valign="top">
								<td>day of the year </td>
								<td> </td>
								<td>DY </td>
								<td> </td>
								<td>3 </td>
								<td>1 </td>
								<td>HD24 </td>
							</tr>
							<tr valign="top">
								<td>day of the week (begins with Monday) </td>
								<td>J </td>
								<td>DW </td>
								<td> </td>
								<td>1 </td>
								<td>1 </td>
								<td>HD24 </td>
							</tr>
							<tr valign="top">
								<td>hour of the day </td>
								<td>H </td>
								<td>HD </td>
								<td>4 </td>
								<td>2 </td>
								<td>0 </td>
								<td>MH60 </td>
							</tr>
							<tr valign="top">
								<td>hour (continuous) </td>
								<td> </td>
								<td>CH </td>
								<td> </td>
								<td> </td>
								<td>0 </td>
								<td>CN60 </td>
							</tr>
							<tr valign="top">
								<td>minute of the hour </td>
								<td>N </td>
								<td>NH </td>
								<td>5 </td>
								<td>2 </td>
								<td>0 </td>
								<td>
							UTC leap second &#8594; SN61
							&#8594; SN60
						 </td>
							</tr>
							<tr valign="top">
								<td>minute (continuous) </td>
								<td> </td>
								<td>CN </td>
								<td> </td>
								<td> </td>
								<td>0 </td>
								<td>CS60 </td>
							</tr>
							<tr valign="top">
								<td>second of the minute </td>
								<td>S </td>
								<td>SN </td>
								<td>6 </td>
								<td>2 </td>
								<td>0 </td>
								<td>CS1 </td>
							</tr>
							<tr valign="top">
								<td>second (continuous) </td>
								<td> </td>
								<td>CS </td>
								<td> </td>
								<td> </td>
								<td>0 </td>
								<td>basis </td>
							</tr>
						</tbody>
					</table>
				</div3>
				<prop id="prop-CAL.head" longname="Head" shortname="head" type="CLCY" render="false"/>
				<prop id="prop-CAL.epoch" longname="Epoch" shortname="epoch" type="TS" render="false"/>
				<div3 id="prop-CAL.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<argument name="x" type="CAL"/>
					<p>
						The evaluation of equality for <emph>CAL</emph> is the same as the <termref ref="dt-DSET">DSET</termref> data type.<footnote>
							<p>
								This means that values of the type CAL and DSET&lt;CLCY&gt; may be equal.
							</p>
						</footnote>
					</p>
				</div3>
			</div2>
			<div2 id="dt-CLCY">
				<anchor id="CLCY"/>
				<head>CalendarCycle (CLCY) specializes <termref ref="dt-ANY">ANY</termref>
				</head>
				<p>
					<emph role="strong">Definition:     </emph>    
					A calendar cycle defines one group of decimal digits in the calendar
					expression. Examples for calendar cycles are year, month, day, hour,
					minute, second, and week.
				</p>
				<exhibit role="dtdl">
					<caption/>
					<pre>
private type CalendarCycle alias CLCY specializes ANY {
   CV     name;
   INT    ndigits;
   INT    start;
   CLCY   next;
   INT    max(TS t);
   TS     sum(TS t, REAL r);
   INT    value(TS t);
};</pre>
				</exhibit>
				<p>
					A calendar cycle has a name and two codes, a one-letter code and a
					two-letter code. The property <emph>ndigits</emph> is the number of
					decimal digits occupied in the calendar expression. The property
					<emph>start</emph> specifies where counting starts (i.e., at 0 or 1).
					The <emph>next</emph> property is the next lower cycle in the order of
					the calendar expression. The max(<emph>t</emph>) property is the
					maximum number of cycles at time <emph>t</emph> (max depends on the
					time <emph>t</emph> to account for leap years and leap seconds).  The
					property value(<emph>t</emph>) is the integer number of cycles shown
					in the calendar expression of time <emph>t</emph>. The property
					sum(<emph>t</emph>, <emph>n</emph>) is the sum of <emph>n</emph>
					calendar cycles added to the time <emph>t</emph>.
				</p>
				<exhibit role="dtdl">
					<caption/>
					<pre>
invariant(CLCY c)
      where c.nonNull {
   c.name.nonNull;
   c.start.equal(0).or(c.start.equal(1));
   c.digits.greaterThan(0);
};</pre>
				</exhibit>
				<prop id="prop-CAL.name" longname="Name" shortname="name" type="CV" render="false" mandatory="true"/>
				<prop id="prop-CAL.ndigits" longname="Number Of Digits" shortname="ndigits" type="INT" render="false"/>
				<prop id="prop-CAL.start" longname="Start" shortname="start" type="INT" render="false"/>
				<prop id="prop-CAL.next" longname="Next" shortname="next" type="CLCY" render="false"/>
				<prop id="prop-CAL.max" longname="Maximum" shortname="max" type="INT" render="false">
					<argument name="t" type="TS"/>
				</prop>
				<prop id="prop-CAL.sum" longname="Sum" shortname="sum" type="TS" render="false">
					<argument name="t" type="TS"/>
					<argument name="r" type="REAL"/>
				</prop>
				<prop id="prop-CAL.value" longname="Value" shortname="value" type="INT" render="false">
					<argument name="t" type="TS"/>
				</prop>
				<div3 id="prop-CLCY.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<argument name="x" type="CLCY"/>
					<p>
						Two nonNull <emph>CLCY</emph>s are equal if they have the same ndigits, start, and next.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(CLCY x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.ndigits.equal(y.ndigits).and(x.start.equal(y.start)).and(x.next.equal(y.next)));
};</pre>
					</exhibit>
				</div3>
			</div2>
			<div2 id="dt-TS">
				<anchor id="TS"/>
				<head>PointInTime (TS) specializes <termref ref="dt-QTY">QTY</termref>
				</head>
				<p>
					<emph role="strong">Definition:     </emph>
					A quantity specifying a point on the axis of natural time. A point
					in time is most often represented as a calendar expression.
				</p>
				<p>
					Semantically, however, time is independent from calendars and best
					described by its relationship to elapsed time (measured as a physical
					quantity in the dimension of time).  A <emph>TS</emph> plus an elapsed
					time yields another <emph>TS</emph>.  Inversely, a <emph>TS</emph> minus
					another <emph>TS</emph> yields an elapsed time.
				</p>
				<p>
					As nobody knows when time began, a <emph>TS</emph> is conceptualized as
					the amount of time that has elapsed from some arbitrary zero-point,
					called an epoch.  Because there is no absolute zero-point on the time
					axis; natural time is a difference-scale quantity, where only
					differences are defined but no ratios. (For example, no <emph>TS</emph>
					is &#8212; absolutely speaking &#8212; "twice as late" as another
					<emph>TS</emph>).
				</p>
				<p>
					Given some arbitrary zero-point, one can express any point in time as
					an elapsed time measured from that offset. Such an arbitrary
					zero-point is called an epoch. This epoch-offset form is used as a
					semantic representation here, without implying that any system would
					have to implement <emph>TS</emph> in that way. Systems that do not
					need to compute distances between <emph>TS</emph>s will not need any
					other representation than a calendar expression literal.
				</p>
				<exhibit role="dtdl" id="dtdl-TS">
					<anchor id="dtdl-TS"/>
					<caption/>
					<pre>
type PointInTime alias TS specializes QTY {
           PQ   offset;
           CS   calendar;
           INT  precision;
           PQ   timezone;
           TS   plus(PQ x);
           PQ   minus(TS x);
           TS   minus(PQ x);
  literal  ST.SIMPLE;
};</pre>
				</exhibit>
				<div3 id="prop-TS.offset">
					<head>Offset from Epoch (offset) : <termref ref="dt-PQ">PQ</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
							The elapsed time since any constant epoch, measured as a physical
							quantity in the dimension of time (i.e., comparable to one second).
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(TS x, PQ y)
      where x.nonNull.and(y.unit.code.equal("s")) {
   x.offset.isComparableTo(y);
};</pre>
					</exhibit>
					<p>
							It is not necessary for this specification to define a canonical
							epoch; the semantics is the same for any epoch, as long as the epoch
							is constant.
						</p>
					<note role="ITS">
						<p>
							<emph>offset</emph> may be treated as a purely semantic property that
								is not represented in any way other than the calendar literal
								expression. However, an ITS may just as well choose to define a
								constant epoch and represent <emph>TS</emph> values as elapsed time
								offsets relative to that epoch. However, an ITS using an epoch-offset
								representation would still need to communicate the calendar code and
								the precision of a calendar representation once other calendars are
								supported.
							</p>
					</note>
				</div3>
				<div3 id="prop-TS.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<argument name="x" type="ANY"/>
					<p>
							Two <emph>TS</emph> values are equal if and only if their
							<termref ref="prop-TS.offset">offset</termref>s
							(relative to the same epoch) are equal. If both TS value have timezones, 
							the values should be be corrected for timezone before comparison. 
							If neither TS value has a timezone, then they may be compared for 
							equality without correction. If only one TS value has a timezone, 
							then the equality is null (nullFlavor NI).
					</p>
					<p>
						Two nonNull <emph>TS</emph> are only equal if they have the same precision.<footnote>
							<p>
								Because of precision and representation issues, such a strict
								evaluation of equals is often inappropriate in implementations, and some sort of
								limit of difference or interval based logic is usually appropriate
								for applications.
							</p>
						</footnote>
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(TS x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.offset.equal(y.offset)).and(x.precision.equal(y.precision));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-TS.lessOrEqual">
					<head>Ordering: less-or-equal (lessOrEqual) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-QTY">QTY</termref>
					</head>
					<argument name="x" type="QTY"/>
					<p>
						<emph role="strong">Definition:     </emph>
						A predicate expressing an order relation that is reflexive, asymmetric
						and transitive, between this <emph>TS</emph> and another <emph>TS</emph>.
					</p>
					<p>
						<emph>TS</emph> values with the same precision form a totally ordered subset.
						The outcome of lessOrEqual between two <emph>TS</emph> is NULL unless they
						have the same precision.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(TS x, y)
      where x.nonNull.and(y.nonNull) {
   x.lessOrEqual(y).nonNull.implies(x.offset.equal(y.offset));
};</pre>
					</exhibit>
					<p>
						By contrast, a partially ordered set is a set where some, but not all
						pairs of elements are comparable through the order relation (e.g., a
						tree structure or the set of physical quantities is a partially
						ordered set).  Two data values <emph>x</emph> and <emph>y</emph> of an
						ordered type are comparable (<emph>x</emph>.isComparableTo(<emph>y</emph>))
						if the less-or-equal relation holds in either way (<emph>x</emph>
						&#8804; <emph>y</emph> or <emph>y</emph> &#8804; <emph>x</emph>).
					</p>
					<p>
						A partial order relation generates totally ordered subsets whose union
						is the entire set (e.g., the set of all length is a totally ordered
						subset of the set of all physical quantities).
					</p>
					<p>
						For example, a tree structure is partially ordered, where the root is
						considered less or equal to a leaf, but there may not be an order
						among the leafs. Also, physical quantities are partially ordered,
						since an order exists only among quantities of the same dimension
						(e.g., between two lengths, but not between a length and a time).  A
						totally ordered subset of a tree is a path that transitively connects
						a leaf to the root. The physical dimension of time is a totally
						ordered subset of physical quantities.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (QTY x, y, z)
   where x.nonNull.and(y.nonNull).and(z.nonNull) {
      x.lessOrEqual(x);                                  /* reflexive */
      x.lessOrEqual(y).implies(y.lessOrEqual(x)).not;    /* asymmetric */
      x.lessOrEqual(y).and(y.lessOrEqual(z))
       .implies(x.lessOrEqual(z))                        /* transitive */
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-TS.calendar">
					<head>Calendar (calendar) : <termref ref="dt-CS">CS</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
							A code specifying the calendar used in the literal representation of
							this <emph>TS</emph>. The default values is GREG.<footnote>
							<p>
									At this time, no other calendars than the Gregorian calendar are
									defined. However, the notion of a calendar as an arbitrary convention
									to specify absolute time is important to properly define the semantics
									of time and time-related data types. Furthermore, other calendars
									might be supported when needed to facilitate HL7's use in other
									cultures.
								</p>
						</footnote>
					</p>
					<table id="domain-Calendar">
						<caption>Concept Domain Calendar. ValueSet OID:  2.16.840.1.113883.11.17422. CodeSystem "Calendar", OID: 2.16.840.1.113883.5.1055, Owner: HL7</caption>
						<thead>
							<tr valign="bottom">
								<th>lvl</th>
								<th>code</th>
								<th>name</th>
								<th>definition</th>
							</tr>
						</thead>
						<tr valign="top">
							<td>1</td>
							<td>GREG</td>
							<td>Gregorian</td>
							<td>
								<p>The Gregorian calendar is the calendar in effect in most countries of Christian influence since approximately 1582. This calendar superceded the Julian calendar.</p>
							</td>
						</tr>
					</table>
					<p>
							The purpose of this property is mainly to faithfully convey what has
							been entered or seen by a user in a system originating such a
							<emph>TS</emph> value. <emph>calendar</emph> also advises any system
							rendering a <emph>TS</emph> value into a literal form of which calendar
							to use. However, this is only advice; any system that renders
							<emph>TS</emph> values to users may choose to use the calendar and
							literal form demanded by its users rather than the calendar mentioned
							in <emph>calendar</emph>. Hence, <emph>calendar</emph> is not constant
							in communication between systems, the calendar is not part of the
							equality test.
						</p>
					<p>
							For the purpose of defining the relationship between calendar
							expression and epoch/offset form, two private data types,
							<termref ref="dt-CAL">CAL</termref> and <termref ref="dt-CLCY">CLCY</termref>
							are defined. These calendar data types
							exist only for defining this specification. These private data types
							may not be used at all outside this specification.
						</p>
				</div3>
				<div3 id="prop-TS.precision">
					<head>Precision of the Calendar Literal Form (precision) : <termref ref="dt-INT">INT</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
							The number of significant digits of the calendar expression
							representation.
						</p>
					<p>
						<emph>precision</emph> is formally defined based on the <termref ref="prop-TS.literal">literal</termref>.
						</p>
					<p>
						<emph>precision</emph> is only the precision of a decimal digit
							representation, <emph>not the accuracy of the <emph>TS</emph>
							value</emph>.
						</p>
					<p>
							The purpose of <emph>precision</emph>
							is to faithfully capture the whole information presented to humans in
							a calendar expression. The number of digits shown conveys information
							about the uncertainty (i.e., precision and accuracy) of a measured
							<emph>TS</emph>. The decimal point between seconds and fractions of a second - if 
							present - does not count towards the significant digits. 
						</p>
					<note>
						<p>
								The precision of the representation is independent from uncertainty
								(precision accuracy) of a measurement result. If the uncertainty of a
								measurement result is important, one should specify uncertain values
								as <termref ref="dt-PPD">PPD</termref>.
							</p>
					</note>
					<p>
						<emph>precision</emph> is dependent on <termref ref="prop-TS.calendar">calendar</termref>.
							A given <emph>precision</emph> relative to one calendar does not mean the same in another
							calendar with different periods.
						</p>
					<p>
							For example "20000403" has 8 significant digits <emph>in the
							representation</emph>, but the <emph>uncertainty of the value</emph>
							may be in any digit shown or not shown, i.e., the uncertainty may be
							to the day, to the week, or to the hour. Note that external
							representations <emph>should</emph> adjust their representational
							precision with the uncertainty of the value. However, since the
							precision in the digit string depends on the calendar and is granular
							to the calendar periods, uncertainty may not fall into that grid
							(e.g., 2000040317 is an adequate representation for the value between
							2000040305 and 2000040405).
						</p>
					<note role="ITS">
						<p>
								A character based ITS MAY NOT
								represent <emph>precision</emph> as an explicit attribute if <emph>TS</emph>
								values are represented as literal calendar expressions. A <emph>TS</emph>
								representation SHALL NOT produce more or less significant digits
								than were originally in that value. Conformance can be tested through
								round-trip encoding - decoding - encoding.
							</p>
					</note>
				</div3>
				<div3 id="prop-TS.timezone">
					<head>Timezone Offset (timezone) : <termref ref="dt-PQ">PQ</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
							The difference between the local time in that time zone and Universal
							Coordinated Time (UTC, formerly called Greenwich Mean Time, GMT). The
							time zone is a <termref ref="dt-PQ">PQ</termref> in the dimension of time (i.e.,
							comparable to one second).  A zero time zone value specifies UTC. The
							time zone value does not permit conclusions about the geographical
							longitude or a conventional time zone name.
						</p>
					<p>
							For example, 200005121800-0500 may be eastern standard time (EST) in
							Indianapolis, IN, or central daylight savings time (CDT) in Decatur,
							IL. Furthermore in other countries having other latitude the time
							zones may be named differently.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(TS x, y)
      where x.nonNull.and(y.nonNull) {
   x.timezone.isComparableTo("1 s");
};</pre>
					</exhibit>
					<p>
							When <emph>timezone</emph> is NULL (unknown), "local time" is
							assumed. However, "local time" is always local to some place, and
							without knowledge of that place, the time zone is unknown. Hence, a
							local time cannot be converted into UTC. <emph>timezone</emph> SHOULD be
							specified for all <emph>TS</emph> values in order to avoid a significant
							loss of precision when <emph>TS</emph>s are compared. The difference of
							two local times where the locality is unknown has an error of
							±12 hours.
						</p>
					<p>
							In administrative data context, some time values do not carry a time
							zone. For a date of birth in administrative data, for example, it
							would be incorrect to specify <emph>timezone</emph>, since this may effectively
							change the date of birth when converted into other time zones. For
							such administrative data the time zone is NULL (not applicable).
						</p>
				</div3>
				<div3 id="prop-TS.diffType">
					<head>DifferenceDataType (diffType) : <termref ref="dt-TYPE">TYPE</termref>, inherited from <termref ref="dt-QTY">QTY</termref>
					</head>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(TS x) {
   x.diffType.implies(PQ);
};</pre>
					</exhibit>
					<p>
							The difference between 2 <emph>TS</emph>s is a <termref ref="dt-PQ">PQ</termref> in
							the dimension of time.
						</p>
				</div3>
				<div3 id="prop-TS.plus">
					<head>Addition (plus) : <termref ref="dt-TS">TS</termref>, inherited from <termref ref="dt-QTY">QTY</termref>
					</head>
					<argument name="x" type="PQ"/>
					<p>
						<emph role="strong">Definition:     </emph>
							A <emph>TS</emph> plus an elapsed time (i.e., <termref ref="dt-PQ">PQ</termref> in the
							dimension of time) is a <emph>TS</emph>.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(TS x, PQ t)
      where x.nonNull.and(t.isComparableTo("1 s")) {
   x.plus(t).offset.equal(x.offset.plus(t));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-TS.minusTS">
					<head>Difference (minus) : <termref ref="dt-PQ">PQ</termref>, inherited from <termref ref="dt-QTY">QTY</termref>
					</head>
					<argument name="x" type="TS"/>
					<p>
						<emph role="strong">Definition:     </emph>
							The difference between two <emph>TS</emph>s is an elapsed time.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(TS x, y)
      where x.nonNull.and(y.nonNull) {
   x.minus(y).dataType.equal(PQ);
   x.minus(y).offset.equal(x.offset.plus(y.offset.negated));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-TS.minusPQ">
					<head>Difference (minus) : <termref ref="dt-TS">TS</termref>, inherited from <termref ref="dt-QTY">QTY</termref>
					</head>
					<argument name="x" type="PQ"/>
					<p>
						<emph role="strong">Definition:     </emph>
							The subtraction of a PQ from a <emph>TS</emph> is a <emph>TS</emph>.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(TS x, PQ y)
      where x.nonNull.and(y.nonNull) {
   x.minus(y).dataType.equal(TS);
   x.minus(y).equal(x.plus(y.negated));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-TS.literal">
					<head>Literal Form</head>
					<p>
						<emph>TS</emph> literals are simple calendar expressions, as defined by
							the calendar definition table. By default, the western (Gregorian)
							calendar shall be used (<tabref ref="domain-CalendarCycle"/>).
						</p>
					<p>
							For the default Gregorian calendar the calendar expression literals of
							this specification conform to the constrained ISO 8601 that is defined
							in ISO 8824 (ASN.1) under clause 32 (generalized time) and to the HL7
							Version 2 TS data type.
						</p>
					<p>
							Calendar expression literals are sequences of integer numbers ordered
							according to the "counter" column of <tabref ref="domain-CalendarCycle"/>.
							Periods with lower order numbers stand to the left of periods with higher order
							numbers. Periods with no assigned order number cannot occur in the calendar
							expression for <emph>TS</emph>.
						</p>
					<p>
							The "digits" column of <tabref ref="domain-CalendarCycle"/>
							specifies the exact number of digits for the counter number for any
							period.
						</p>
					<p>
							Thus, <tabref ref="domain-CalendarCycle"/> specifies that western
							calendar expressions begin with the 4-digit year (beginning counting
							at zero); followed by the 2-digit month of the year (beginning
							counting at one); followed by the 2-digit day of the month (beginning
							with one); followed by the 2-digit hour of the day (beginning with
							zero); and so forth. For example, "200004010315" is a valid expression
							for April 1, 2000, 3:15 am.
						</p>
					<p>
							A calendar expression can be of variable precision, omitting parts
							from the right.
						</p>
					<p>
							For example, "20000401" is precise only to the day of the month.
						</p>
					<p>
							The least defined calendar period (i.e. the second) may be written as
							a <termref ref="dt-REAL">REAL</termref>, with the number of integer digits specified, followed
							by the decimal point and any number of fractional digits.
						</p>
					<p>
							For example, "20000401031520.34" means April 1, 2000, 3:15 and 20.34
							seconds.
						</p>
					<p>
							When other calendars are used in the future, a prefix "GREG:" can
							be placed before the western (Gregorian) calendar expression to
							disambiguate from other calendars. Each calendar shall have its own
							prefix. However, the western calendar is the default if no prefix is
							present.
						</p>
					<p>
							In the modern Gregorian calendar (and all calendars where time of day
							is based on UTC), the calendar expression may contain a time zone
							suffix. The time zone suffix begins with a plus (+) or minus (-)
							followed by digits for the hour and, for non UTC times, minute cycles. UTC is designated
							as offset "+00" or "-00"; the ISO 8601 and ISO 8824 suffix "Z" for UTC
							is not permitted.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
TS.literal ST.SIMPLE {
   TS   : cal timestamp($1)                  { $.equal($2); }
        | timestamp(GREG)                    { $.equal($1); };

   TS timestamp(Calendar C)
        : cycles(C.head, C.epoch) zone(C)    { $.equal($1.minus($2)); }
                                               $.timezone.equal($2); }
        | cycles(C.head, C.epoch)            { $.equal($1);
                                               $.timezone.unknown; };
   Calendar cal
        : /[a-zA-Z_][a-zA-Z0-9_]*:/          { $.equal($1); };

   TS cycles(CalendarCycle c, TS t)
        : cycle(c, t) cycles(c.next, $1)     { $.equal($2); }
        | cycle(c, t) "." REAL.fractional    { $.equal(c.sum($1, $3));
                                               $.precision.equal(
                                                  t.precision.plus($3.precision)); }
        | cycle(c, t)                        { $.equal($1); };

   TS cycle(CalendarCycle c, TS t)
        : /[0-9]{c.ndigits}/                 { $.equal(c.sum(t, $1));
                                                $.precision.equal(
                                                   t.precision.plus(c.ndigits)); };

   PQ zone(Calendar C)
        : "+" cycles(C.zonehead, C.epoch)    { $.equal($2.minus(C.epoch)); }
        | "-" cycles(C.zonehead, C.epoch)    { $.equal(C.epoch.minus($2)); };
};</pre>
					</exhibit>
				</div3>
			</div2>
			<div2 id="dt-EXPR">
				<anchor id="EXPR"/>
				<head>Expression (EXPR) specializes T</head>
				<parameter name="T" type="QTY"/>
				<p>
					<emph role="strong">Definition:     </emph>
					A generic data type extension used to specify an expression
					that can be used to derive the actual value of T given information
					taken from the context of use.
				</p>
				<table id="dt-EXPR-prop-summary">
					<caption>Property Summary of
      Expression</caption>
					<col width="79"/>
					<col width="60"/>
					<col width="413"/>
					<thead>
						<tr>
							<th>Name</th>
							<th>Type</th>
							<th>Description</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>
								<termref ref="prop-EXPR.expression">expression</termref>
							</td>
							<td>
								<termref ref="dt-ED">ED</termref>
							</td>
							<td>
							The definition of the expression that can be evaluated to generate the actual value.
						</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-EXPR.evaluate">evaluate</termref>
							</td>
							<td>
								<termref ref="dt-EXPR">EXPR</termref>&lt;T&gt;</td>
							<td>
							The result of evaluating the expression.
						</td>
						</tr>
					</tbody>
				</table>
				<p>
					For example <emph>EXPR</emph> can be used for expressing dosage instructions that
					depend on patient body weight. 
				</p>
				<exhibit role="dtdl" id="dtdl-EXPR">
					<anchor id="dtdl-EXPR"/>
					<caption/>
					<pre>
template&lt;QTY T&gt;
type Expression&lt;T&gt; alias EXPR&lt;T&gt; specializes T {
  ED      expression;
  EXPR&lt;T&gt;  evaluate;
};</pre>
				</exhibit>
				<p>
				The expression specifies how the value of type T can be evaluated. 
				Either an expression or a value or both may be provided. It is at the
				discretion of the receiver of the information whether to evaluate the 
				expression when the information is being processed. If no value is 
				provided, then the value SHALL have a nullFlavor, whether or not an 
				expression is provided.
			</p>
				<p>
				Note that as a generic type extension, <emph>EXPR</emph> does not modify the
				meaning of equality for the type which it specializes.
			</p>
				<div3 id="prop-EXPR.expression">
					<head>Expression (expression) : <termref ref="dt-ED">ED</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
							The definition of the expression that can be evaluated to generate the actual value.
						</p>
					<p>
							The language of the expression SHALL be inferred from the mediatype of the content. If multiple translations are
							provided in the <termref ref="dt-ED">ED</termref>, the evaluator is free to choose whichever language is
							preferred; all translations SHALL specify the same outcome.
						</p>
					<p>
							The language of the <emph>EXPR</emph> defines the forms that the expression property can take,
							how the information available in the context of the <emph>EXPR</emph> is made available within
							the features of the language, and how the language declares the new form of the value.
							Implementers are not required to implement any languages in order to claim conformance to
							this specification, but SHOULD declare what languages are supported in their conformance
							statements.
						</p>
					<table>
						<caption>Known languages</caption>
						<tr>
							<th rowspan="1" colspan="1">Language</th>
							<th rowspan="1" colspan="1">Mediatype</th>
						</tr>
						<tr>
							<td rowspan="1" colspan="1">OCL</td>
							<td rowspan="1" colspan="1">text/plain+ocl</td>
						</tr>
						<tr>
							<td rowspan="1" colspan="1">Factor (see below)</td>
							<td rowspan="1" colspan="1">application/hl7-factor+xml</td>
						</tr>
						<tr>
							<td rowspan="1" colspan="1">MathML</td>
							<td rowspan="1" colspan="1">application/mathml+xml</td>
						</tr>
					</table>
					<p>
							This is not a list of allowed expression languages, just a convenient summary of some types that
							may be encountered. If no supported language is found in the expression, then the outcome of the
							evaluation is NULL.
						</p>
				</div3>
				<div3 id="prop-EXPR.evaluate">
					<head>Evaluate (evaluate) : <termref ref="dt-EXPR">EXPR</termref>&lt;T&gt;</head>
					<p>
						<emph role="strong">Definition:     </emph>
							The result of evaluating the expression.
						</p>
					<p>
							The result is also an expression so that the expression used to derive the result can be carried with
							the result of the evaluation. If the evaluation fails because required information is not available
							of the language is not supported by the implementation, then the value will have a nullFlavor.
						</p>
					<note>
						<p>
								In practice, evaluation of the expression may require access to information outside the scope 
								of the data type itself. How this is made available is outside the scope of this specification,
								and may be specified for specific languages in other HL7 publications.
							</p>
					</note>
				</div3>
				<div3>
					<head>Factor: A simple language for dosage quantities</head>
					<p>
     This is a very simple language to support 
     common dosage formulas that dependent on some patient observations, e.g., body mass or the body surface area.
     The language supports any formula that uses one or more input data as factors multiplied with some constant coefficient. 
     For example, a standard dose might be 30 mL per kg of body mass,
     i.e. the constant coefficient is 30 mL/kg and is multiplied with the body mass.
				</p>
					<div4>
						<head>Introduction</head>
						<p>
						A factor expression simply calculates the value from as specified from one or more derivedFrom
						observations on the context of the local act of which the expression is an attribute.
						Here is an example:
					</p>
						<exhibit role="example" verbatim="yes">
							<pre>
 &lt;substanceAdministration&gt;
   ...
   &lt;doseQuantity xsi:type="EXPR_PQ" unit="mL" mediatype="application/hl7-factor+xml"&gt;
     &lt;coefficient value="30" unit="mL/kg"&gt;
     &lt;factor&gt;bodyMass&lt;/factor&gt;
   &lt;/doseQuantity&gt;
   ...
   &lt;derivedFrom&gt;
     &lt;localVariableName&gt;bodyMass&lt;/localVariableName&gt;
     &lt;monitoringObservation&gt;
       &lt;code code="29463-7" codeSystem="2.16.840.1.113883.6.1" displayName="BODY WEIGHT:MASS:PT:^PATIENT:QN"/&gt;
     &lt;/monitoringObservation&gt;
   &lt;/derivedFrom&gt;
 &lt;/substanceAdministration&gt;</pre>
						</exhibit>
						<p>
      The value of the input observations that serve as factors is usually not provided but resolved at 
      the time of evaluating the expression; at that time the receiving application will have to source an
      appropriate observation in order to evaluate the expression. If no appropriate
      observation can be found, the result of the expression is null.     
					</p>
					</div4>
					<div4>
						<head>Formal Definition</head>
						<p>
      The mediatype for this language is "application/hl7-factor+xml".
      This language is only applicable to <termref ref="dt-PQ">PQ</termref>. The source SHALL be provided 
      in-line, and no translations are allowed. For interest, here is the formal definition:
					</p>
						<exhibit role="dtdl">
							<caption/>
							<pre>
invariant(EXPR x) where
  x.mediaType.equals("application/hl7-factor+xml") {
  x.expression.nonNull;
  x.expression.language.notApplicable;
  x.expression.compression.notApplicable;
  x.expression.reference.notApplicable;
  x.expression.integrityCheck.notApplicable;
  x.expression.integrityCheckAlgorithm.notApplicable;
  x.expression.description.notApplicable;
  x.expression.thumbnail.notApplicable;
  x.expression.translation.isEmpty;
};</pre>
						</exhibit>
						<p>
      The expression consists of a coefficient with a type of <termref ref="dt-PQ">PQ</termref>, and a 
      series of factors, which are simple names. Factors are specified as a simple <termref ref="dt-ST.SIMPLE">ST.SIMPLE</termref>
      data value, and refer to an ActRelationship.localVariableName of the relationship
	  specifying the input variable. The specific wire format for this is defined in the ITS specifications.
					</p>
						<p>
      An expression of this type SHALL only be used on an attribute that is part
      of an Act, and the Act SHALL have one ActRelationship for each named factor in
      the expression, where the ActRelationship has an Observation as target and
      a localVariableName attribute equal to the named factor.
      The target Observation SHALL 
      have a code that specifies the type of observation. 
      The target Observation MAY have a value, but typically NEED NOT carry a value. 
 					</p>
						<p>
      The result of the expression is the product of the coefficient and all the factors according to the 
      semantics of all data types involved.
      Specifically, Units in <termref ref="dt-PQ">PQ</termref> factors SHALL be carried through correctly and determine the dimension of the final result. 
      If a unit is specified in the <termref ref="dt-PQ">PQ</termref> itself, then the units of the result SHALL be compared to the units specified. If no
      conversion to the correct units is possible, the result of the evaluation SHALL be NULL. 
      In other words, specifying the unit will guarantee the dimension of the result.
   					</p>
						<p>
      This language is deliberately limited in scope for ease of implementation. For more
      sophisticated requirements other languages should be used instead.
      HL7 plans to develop separate appendix documents describing the use of other expression languages.
					</p>
					</div4>
				</div3>
			</div2>
		</div1>
		<div1 id="datyp2qtycol">
			<head>Collections of Quantities</head>
			<graphic source="graphics/dtUML-QuantityCollections.png" alt="Quantity Collection Data Types"/>
			<div2 id="prelim">
				<head>Preliminary Considerations</head>
				<p>
					This section defines data types that are collections of quantities
					and describes their behavior. These collection types are defined as generic
					(parameterized) types. The concept of generic types is described in
					<specref ref="generics"/>.					
				</p>
				<p>
					In many implementation technologies, "collections" are understood as
					containers of individually enumerated data items. Many of the types defined
					in this section cannot have their individual items enumerated, and therefore 
					other properties for interacting with complex sets are defined, such as 
					intervalAt. Nevertheless they are still collections, or sets, of items, and
					their behavior is described in these terms. Note that the foundation types
					<termref ref="dt-BAG">BAG</termref>, <termref ref="dt-DSET">DSET</termref>, and <termref ref="dt-LIST">LIST</termref> can
					be enumerated (or "iterated"), and this is also true of the types
					<termref ref="dt-GLIST">GLIST</termref> and <termref ref="dt-SLIST">SLIST</termref> defined in this section.
				</p>
				<p>
					Continuous Sets are a core underpinning of important types dealing with timing specifications, which are an
					important type in health care. The timing specification suite of data types is used to specify the
					complex timing of events and actions such as those that occur in order
					management and scheduling systems. These types also support the cyclical
					validity patterns that may exist for certain kinds of information,
					such as phone numbers (evening, daytime), office hours, and addresses
					of so-called "snowbirds" (i.e. people who choose to reside closer to
					the equator during winter and farther from the equator during summer).
				</p>
				<p>
					The timing specification data types include point in time (<termref ref="dt-TS">TS</termref>)
					and the interval of time (<termref ref="dt-IVL">IVL</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;)
					and add types that are specifically suited to repeated
					schedules. These additional types include <termref ref="dt-PIVL">PIVL</termref>, <termref ref="dt-EIVL">EIVL</termref>,
					and finally <termref ref="dt-GTS">GTS</termref> type itself, which is an alias for <termref ref="dt-QSET">QSET</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;
					All of these types describe the time distribution of repeating states or events.
				</p>
			</div2>
			<div2 id="dt-GLIST">
				<anchor id="GLIST"/>
				<head>GeneratedSequence (GLIST) specializes <termref ref="dt-LIST">LIST</termref>
				</head>
				<parameter name="T" type="QTY"/>
				<p>
					<emph role="strong">Definition:     </emph>
					A periodic or monotone sequence of values generated from
					parameters, rather than being enumerated. 
				</p>
				<p>
					<emph>GLIST</emph> is used to specify regular sampling points for biosignals.
				</p>
				<exhibit role="dtdl">
					<caption/>
					<pre>
template&lt;QTY T&gt;
type GeneratedSequence&lt;T&gt; alias GLIST&lt;T&gt; specializes LIST&lt;T&gt; {
   T.diffType  increment;
   INT  period;
   INT  denominator;
};</pre>
				</exhibit>
				<table id="dt-GLIST-prop-summary">
					<caption>Property Summary of
      GeneratedSequence</caption>
					<col width="79"/>
					<col width="60"/>
					<col width="413"/>
					<thead>
						<tr>
							<th>Name</th>
							<th>Type</th>
							<th>Description</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>
								<termref ref="prop-GLIST.head">head</termref>
							</td>
							<td>T</td>
							<td>
							The first item in this sequence.  
						</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-GLIST.increment">increment</termref>
							</td>
							<td>
								<termref ref="dt-T.diffType">T.diffType</termref>
							</td>
							<td>
						The difference between one value and the previous different value.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-GLIST.period">period</termref>
							</td>
							<td>
								<termref ref="dt-INT">INT</termref>
							</td>
							<td>
						If non-NULL, the duration over which the sequence repeats.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-GLIST.denominator">denominator</termref>
							</td>
							<td>
								<termref ref="dt-INT">INT</termref>
							</td>
							<td>
						The integer by which the index for the sequence is divided,
						giving the number of times the sequence generates the same
						sequence item value before incrementing to the next sequence item
						value. For example, to generate the sequence (1; 1; 1; 2; 2; 2; 3; 3;
						3; ...)  the denominator is 3.
					</td>
						</tr>
					</tbody>
				</table>
				<p>
					The item at a certain index in the list is calculated by performing an
					integer division on the index (<emph>i</emph>) with the
					<termref ref="prop-GLIST.denominator">denominator</termref> (<emph>d</emph>) and then take that
					value's remainder modulus <termref ref="prop-GLIST.period">period</termref>
					(<emph>p</emph>). Multiply this value with the
					<termref ref="prop-GLIST.increment">increment</termref> (<emph>&#916;x</emph>) and add to the
					<termref ref="prop-GLIST.head">head</termref> (<emph>x</emph>
					<emph role="sub">0</emph>).
				</p>
				<quote>
					<p>
						<emph>x</emph>
						<emph role="sub">
							<emph>i</emph>
						</emph>=<emph>x</emph>
						<emph role="sub">0</emph>
						+ <emph>&#916;x</emph> × (<emph>i</emph>/<emph>d</emph>)
						mod <emph>p</emph>.
					</p>
				</quote>
				<exhibit role="dtdl">
					<caption/>
					<pre>
invariant(GLIST&lt;T&gt; list, INT index)
      where list.nonNull.and(index.nonNull) {
   list.period.nonNull.implies(list.item(index).equal(
      list.head.plus(item.dividedBy(list.increment.denominator)
          .remainder(list.period)).times(increment)));
   list.period.isNull.implies(list.item(index).equal(
      list.head.plus(item.dividedBy(list.increment.denominator))
          .times(increment)));
};</pre>
				</exhibit>
				<div3 id="prop-GLIST.head">
					<head>Head Item (head) : T, inherited from <termref ref="dt-LIST">LIST</termref>
					</head>
					<p>
						The start-value of the generated list.
					</p>
					<!-- FIXME: This specification will probably have to be extended to
						 separate the head from the reset point of the sequence or else
						 we won't be able to have a GLIST.tail be a GLIST! -->
				</div3>
				<div3 id="prop-GLIST.increment">
					<head>Increment (increment) : <termref ref="dt-T.diffType">T.diffType</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The difference between one value and the previous different value.
					</p>
					<p>
						For example, to generate the sequence (1; 4; 7; 10; 13; ...) the
						increment is 3; likewise, to generate the sequence (1; 1; 4; 4; 7; 7;
						10; 10; 13; 13; ...), the increment is also 3.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(GLIST&lt;T&gt; x, T.diffType y) where x.nonNull.and(y.isZero) {
   x.increment.greaterThan(y);
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-GLIST.period">
					<head>Period Step Count (period) : <termref ref="dt-INT">INT</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						If non-NULL, the duration over which the sequence repeats.
					</p>
					<p> 
					    I.e., after this
						many increments, the sequence item values roll over to start from the
						initial sequence item value. For example, the sequence (1; 2; 3; 1; 2;
						3; 1; 2; 3; ...) has period 3; also the sequence (1; 1; 2; 2; 3; 3; 1;
						1; 2; 2; 3; 3; ...) has period 3 too.
					</p>
					<p>
						The period allows the <emph>GLIST</emph> to repeatedly sample the same value space.  The
						waveform of this periodic generator is always a "saw," just like the
						x-function of an oscilloscope.<footnote>
							<p>
								Note the difference to the <termref ref="dt-GTS">GTS</termref>. The <termref ref="dt-GTS">GTS</termref> is
								a generator for a <termref ref="dt-SET">SET</termref>&lt;<termref ref="dt-TS">TS</termref>&gt; not for a
								<termref ref="dt-LIST">LIST</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;.  A sequence of discrete
								values from a continuous domain makes not much sense other than in sampling
								applications. The <termref ref="dt-SET">SET</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;, however,
								can be thought of as a sequence of <termref ref="dt-IVL_TS">IVL&lt;TS&gt;</termref>, which still is different from a
								<termref ref="dt-LIST">LIST</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;.
							</p>
						</footnote>
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(GLIST&lt;T&gt; x) where x.nonNull {
   x.period.nonNull.implies(x.period.greaterThan(0));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-GLIST.denominator">
					<head>Denominator (denominator) : <termref ref="dt-INT">INT</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The integer by which the index for the sequence is divided,
						giving the number of times the sequence generates the same
						sequence item value before incrementing to the next sequence item
						value. For example, to generate the sequence (1; 1; 1; 2; 2; 2; 3; 3;
						3; ...)  the denominator is 3.
					</p>
					<p>
						The denominator allows multiple generated sequences to
						periodically scan a multidimensional space. For example, an (abstract)
						TV screen might use 2 such generators for the columns and rows of
						pixels. If there were 200 scan lines and 320 raster
						columns, the column-generator would have denominator 1, and the
						line-generator would have denominator 320.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(GLIST&lt;T&gt; x) where x.nonNull {
   x.denominator.nonNull;
   x.denominator.greaterThan(0);
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-GLIST.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<argument name="x" type="LIST&lt;T&gt;"/>
					<p>
						The evaluation of equality for <emph>GLIST</emph> is the same as
						the <termref ref="dt-LIST">LIST</termref> data type: Two nonNull <termref ref="dt-LIST">LIST</termref>s are
						equal if they have the same elements.<footnote>
							<p>
								This means that values of the type GLIST and any other kind of LIST may be equal.
							</p>
						</footnote>
					</p>
				</div3>
				<table id="table-GLIST.example">
					<caption>Examples for Generated Sequences</caption>
					<thead>
						<tr>
							<th rowspan="1" colspan="1">head</th>
							<th rowspan="1" colspan="1">increment</th>
							<th rowspan="1" colspan="1">denominator</th>
							<th rowspan="1" colspan="1">period</th>
							<th rowspan="1" colspan="1">meaning</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td rowspan="1" colspan="1">0</td>
							<td rowspan="1" colspan="1">1</td>
							<td rowspan="1" colspan="1">1</td>
							<td rowspan="1" colspan="1">&#8734;</td>
							<td rowspan="1" colspan="1">The identity-sequence where each item is equal to its index.</td>
						</tr>
						<tr>
							<td rowspan="1" colspan="1">198706052000</td>
							<td rowspan="1" colspan="1">2 hour</td>
							<td rowspan="1" colspan="1">1</td>
							<td rowspan="1" colspan="1">&#8734;</td>
							<td rowspan="1" colspan="1">
								Sequence starting on June 5, 1987 at 7 PM and
								incrementing every two hours: 9 PM, 11 PM, 1 AM (June 6), 3
								AM, 5 AM, and so on.
							</td>
						</tr>
						<tr>
							<td rowspan="1" colspan="1">0 V</td>
							<td rowspan="1" colspan="1">1 mV</td>
							<td rowspan="1" colspan="1">1</td>
							<td rowspan="1" colspan="1">100</td>
							<td rowspan="1" colspan="1">
								The x-wave of a digital oscillograph scanning between
								0 and 100 mV in 100 steps of 1 mV. The frequency is unknown
								from these data as we do not know how much time elapses
								between each step of the index.
							</td>
						</tr>
						<tr>
							<td rowspan="1" colspan="1">2002072920300</td>
							<td rowspan="1" colspan="1">100 us</td>
							<td rowspan="1" colspan="1">1</td>
							<td rowspan="1" colspan="1">&#8734;</td>
							<td rowspan="1" colspan="1">
								A timebase from June 29,
								2002 at 8:30 PM with 100 us between each steps of the
								index. If combined with the previous generator as a second
								sampling dimension this would now describe our digital
								oscilloscope's x-timebase as 1 mV per 100 us. At 100 steps
								per period, the period is 10 ms, which is equal to a
								frequency of 100 Hz.
							</td>
						</tr>
						<tr>
							<td rowspan="1" colspan="1">0 V</td>
							<td rowspan="1" colspan="1">1 mV</td>
							<td rowspan="1" colspan="1">100</td>
							<td rowspan="1" colspan="1">100</td>
							<td rowspan="1" colspan="1">
								Combining this generator to the previous two generators
								could describe a three-dimensional sampling space with two
								voltages and time. This generator also steps at 1 mV and has
								100 steps per period, however, it only steps every 100 index
								increments, so, the first voltage generator makes one full
								cycle before this generator is incremented. One can think of
								the two voltages as "rows" and "columns" of a "sampling
								frame". With the previous generator as the timebase, this
								results in a scan of sampling frames of 100 mV × 100
								mV with a framerate of 1 Hz.
							</td>
						</tr>
					</tbody>
				</table>
			</div2>
			<div2 id="dt-SLIST">
				<anchor id="SLIST"/>
				<head>SampledSequence (SLIST) specializes <termref ref="dt-LIST">LIST</termref>
				</head>
				<parameter name="T" type="QTY"/>
				<p>
					<emph role="strong">Definition:     </emph>
					A sequence of sampled values scaled and translated from a list of
					integer values.  
				</p>
				<p>
					<emph>SLIST</emph> is used to specify sampled biosignals. The parameter T must be a type of<termref ref="dt-QTY">QTY</termref>.
					A <emph>SLIST</emph> contains a list of integers. The item at a certain index (<emph>i</emph>) in the list is calculated
					by multiplying the item at the same index in the
					<termref ref="prop-SLIST.digits">digits</termref> sequence
					(<emph>d</emph>
					<emph role="sub">
						<emph>i</emph>
					</emph>) with the
					<termref ref="prop-SLIST.scale">scale</termref> (<emph>s</emph>)
					and then add that value to the <termref ref="prop-SLIST.origin">origin</termref>
					(<emph>x</emph>
					<emph role="sub">
						<emph>o</emph>
					</emph>).
				</p>
				<quote>
					<p>
						<emph>x</emph>
						<emph role="sub">
							<emph>i</emph>
						</emph>=<emph>x</emph>
						<emph role="sub">
							<emph>o</emph>
						</emph> + <emph>s</emph>
						× <emph>d</emph>
						<emph role="sub">
							<emph>i</emph>
						</emph>
					</p>
				</quote>
				<p>
					<emph>SLIST</emph> is usually used for measured values of type <termref ref="dt-PQ">PQ</termref>. 
					The <emph>SLIST</emph> is just a list of values; in order to 
					fully understand the data, information concerning the sampling conditions must be provided separately.
				</p>
				<exhibit role="dtdl">
					<caption/>
					<pre>
template&lt;QTY T&gt;
type SampledSequence&lt;T&gt; alias SLIST&lt;T&gt; specializes LIST&lt;T&gt; {
   T          origin;
   T.diffType        scale;
   LIST&lt;INT&gt;  digits;
};</pre>
				</exhibit>
				<table id="dt-SLIST-prop-summary">
					<caption>Property Summary of
      SampledSequence</caption>
					<col width="79"/>
					<col width="60"/>
					<col width="413"/>
					<thead>
						<tr>
							<th>Name</th>
							<th>Type</th>
							<th>Description</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>
								<termref ref="prop-SLIST.origin">origin</termref>
							</td>
							<td>T</td>
							<td>
						The origin of the list item value scale, i.e., the physical quantity
						that a zero-digit would represent in the sequence of values.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-SLIST.scale">scale</termref>
							</td>
							<td>
								<termref ref="dt-T.diffType">T.diffType</termref>
							</td>
							<td>
						A ratio-scale quantity that is factored out of the digit sequence.
					</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-SLIST.digits">digits</termref>
							</td>
							<td>
								<termref ref="dt-LIST">LIST</termref>&lt;<termref ref="dt-INT">INT</termref>&gt;</td>
							<td>
						A sequence of raw digits representing the sample values.
					</td>
						</tr>
					</tbody>
				</table>
				<exhibit role="dtdl">
					<caption/>
					<pre>
invariant(SLIST&lt;T&gt; list, INT index)
      where list.nonNull.and(index.nonNegative) {
   list.item(index).equal(
      list.scale.times(digits.item(index))
          .plus(list.origin));
};</pre>
				</exhibit>
				<div3 id="prop-SLIST.origin">
					<head>Scale Origin (origin) : T</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The origin of the list item value scale, i.e., the physical quantity
						that a zero-digit would represent in the sequence of values.
					</p>
				</div3>
				<div3 id="prop-SLIST.scale">
					<head>Scale Factor (scale) : <termref ref="dt-T.diffType">T.diffType</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
						A ratio-scale quantity that is factored out of the digit sequence.
					</p>
				</div3>
				<div3 id="prop-SLIST.digits">
					<head>Sampled Digits (digits) : <termref ref="dt-LIST">LIST</termref>&lt;<termref ref="dt-INT">INT</termref>&gt;</head>
					<p>
						<emph role="strong">Definition:     </emph>
						A sequence of raw digits representing the sample values.
					</p>
					<p>
						This is typically the
						raw output of an A/D converter.
					</p>
				</div3>
				<div3 id="prop-SLIST.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<argument name="x" type="LIST&lt;T&gt;"/>
					<p>
						The evaluation of equality for <emph>SLIST</emph> is the same as
						the <termref ref="dt-LIST">LIST</termref> data type: Two nonNull <termref ref="dt-LIST">LIST</termref>s are
						equal if they have the same elements.<footnote>
							<p>
								This means that values of the type SLIST and any other kind of LIST may be equal.
							</p>
						</footnote>
					</p>
				</div3>
			</div2>
			<div2 id="dt-QSET">
				<anchor id="QSET"/>
				<head>ContinuousSet (QSET) specializes <termref ref="dt-SET">SET</termref>&lt;<termref ref="dt-T">T</termref>,<termref ref="dt-CEQ">CEQ</termref>&lt;T&gt;&gt;</head>
				<parameter name="T" type="QTY"/>
				<p>
					<emph role="strong">Definition:     </emph>
					An unordered set of distinct values which are quantities.
				</p>
				<p>
					Continuous sets are distinguished from discrete sets in that they may contain an infinite number of elements, viz., 
					a period of time containing infinitely many points in time that can be defined to an arbitrary level of precision.
				</p>
				<p>
					Although <emph>QSET</emph> provides methods to test for membership of the set, it does not actually
					contain any properties that specify what the contents of the set are. An instance of a 
					<emph>QSET</emph> is constructed by combining the <emph>QSET</emph> builder types in an expression
					tree using mathematical operation types. The expression tree specifies exactly which 
					values are part of the <emph>QSET</emph>. The central <emph>QSET</emph> builder type is <termref ref="dt-IVL">IVL</termref>
					which specifies a contiguous range of values. Multiple intervals may be combined into 
					expressions using the <emph>QSET</emph> specializations for mathematical operations: 
					union (<termref ref="dt-QSU">QSU</termref>), intersection (<termref ref="dt-QSI">QSI</termref>), difference (<termref ref="dt-QSD">QSD</termref>), 
					and periodic hull (<termref ref="dt-QSP">QSP</termref>). In addition, there are special types for 
					periodically repeating intervals (<termref ref="dt-PIVL">PIVL</termref>), event-related intervals (<termref ref="dt-EIVL">EIVL</termref>),
					and <termref ref="dt-QSC">QSC</termref> which allows common timing expressions to be represented as simple codes.
					Note that <termref ref="dt-GTS">GTS</termref> is a full alias for <termref ref="dt-QSET">QSET</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;.
				</p>
				<p>
					Since the semantics of <emph>QSET</emph> are tightly bound to the definitions of equality in the <termref ref="dt-QTY">QTY</termref>
					specializations, it is never appropriate to redefine the meaning of uniqueness in these sets, and all
					<emph>QSET</emph>s use the default comparator <termref ref="dt-CEQ">CEQ</termref>. Membership of the set is always based on equality.
				</p>
				<exhibit role="dtdl" id="dtdl-QSET">
					<anchor id="dtdl-QSET"/>
					<caption/>
					<pre>
template&lt;QTY T&gt;
abstract type ContinuousSet&lt;T&gt; alias QSET&lt;T&gt; specializes SET&lt;T, CEQ&lt;T&gt;&gt; {
    IVL&lt;T&gt;    hull;
    IVL&lt;T&gt;    intervalAt(T x);
    IVL&lt;T&gt;    intervalAtOrAfter(T x);
    IVL&lt;T&gt;    intervalAfter(T x);
    BL        interleaves(QSET&lt;T&gt; x);
    QSET&lt;T&gt;   periodicHull(QSET&lt;T&gt; x);
    ED.TEXT   originalText;
  demotion  LIST&lt;IVL&lt;T&gt;&gt;;
};</pre>
				</exhibit>
				<div3 id="prop-QSET.hull">
					<head>Convex Hull of Totally Ordered Sets (hull) : <termref ref="dt-IVL">IVL</termref>&lt;T&gt;</head>
					<p>
						<emph role="strong">Definition:     </emph>
							Given a totally ordered set <emph>S</emph>, the smallest interval that is a superset of <emph>S</emph>. 
						</p>
					<p>
							Continuous Sets are totally ordered sets because there is an order
							relationship defined between any two elements in the set,<footnote>
							<p>
									Note that "ordered set" does not mean the same as Sequence (<termref ref="dt-LIST">LIST</termref>).
									For example, the set {3; 2; 4; 88; 1} is an ordered set. The ordering of the elements
									in the set notation is still irrelevant, but elements can be compared to establish an
									order (1; 2; 4; 88).
								</p>
						</footnote>
							and because all elements in the set must be comparable.<footnote>
							<p>
									Note that the data type of the elements itself need not be totally ordered. For
									example, the data type <termref ref="dt-PQ">PQ</termref> is only partially ordered (since only
									quantities of the same kind can be compared), but a <termref ref="dt-SET">SET</termref>&lt;<termref ref="dt-PQ">PQ</termref>&gt; may
									still be totally ordered if it contains only comparable quantities. For example,
									{4 s, 20 s, 55 s} is a valid <emph>QSET</emph>, while  is [4 s;55 s], while {2 m; 4 m; 8 s} is
									not a valid <emph>QSET</emph>, because it is not <emph>totally</emph> ordered (seconds are not
									comparable with meters).
								</p>
						</footnote>
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(QSET&lt;T&gt; s) where s.nonNull {
   forall(QTY x, y) where s.contains(x).and(s.contains(y)) {
      x.isComparableTo(y);
  };
};</pre>
					</exhibit>
					<p>
							As totally ordered sets, Continuous Sets have a convex hull. 
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(QSET&lt;T&gt; s) where s.nonNull {
   s.hull.contains(s);
   forall(T e)
         where s.contains(e) {
      s.hull.low.lessOrEqual(e);
      e.lessOrEqual(s.hull.high);
      };
};</pre>
					</exhibit>
					<graphic source="graphics/datyp2fig11.jpg" alt="Convex Hull of a Totally Ordered Set"/>
					<p>
						The convex hull of a <emph>QSET</emph> can less formally be called the "outer bound
						interval". Thus the convex hull of a <emph>QSET</emph>
						describes the absolute beginning and end of a schedule. For some set specifications,
						where there are infinite repetitions (e.g., a <termref ref="dt-PIVL">PIVL</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;) the
						convex hull has infinite bounds. The term schedule is used throughout this section
						in its general sense, that of an organized series of values. The more common meaning
						of the term schedule, that of a time-based plan of events, is exactly a 
						<emph>QSET</emph>&lt;<termref ref="dt-TS">TS</termref>&gt;.
					</p>
				</div3>
				<div3 id="prop-QSET.intervalAt">
					<head>Interval At (intervalAt) : <termref ref="dt-IVL">IVL</termref>&lt;T&gt;</head>
					<argument name="x" type="T"/>
					<p>
						<emph role="strong">Definition:     </emph>
							Given a value <emph>t</emph>,
							the greatest continuous subset <emph>v</emph> (an "occurrence interval") of
							the <emph>QSET</emph> value <emph>S</emph>, where <emph>v</emph> includes <emph>x</emph>.
							If there is no occurrence interval that includes v, intervalAt(x) will be null.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(QSET&lt;T&gt; s, TS t) {
   s.contains(t).not.implies(s.intervalAfter(t).equal(s.intervalAtOrAfter(t)));
   s.contains(t).implies(s.intervalAfter(t).equal(
               s.except(intervalAtOrAfter(t)).intervalAtOrAfter(t)));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-QSET.intervalAtOrAfter">
					<head>Interval At or After (intervalAtOrAfter) : <termref ref="dt-IVL">IVL</termref>&lt;T&gt;</head>
					<argument name="x" type="T"/>
					<p>
						<emph role="strong">Definition:     </emph>
							Given a value <emph>t</emph>, 
							the greatest continuous subset <emph>v</emph> (an "occurrence interval") of
							the <emph>QSET</emph> value <emph>S</emph>, where <emph>v</emph> is the interval that
							contains <emph>t</emph> or the first interval that has a low value greater
							than <emph>t</emph>.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(QSET&lt;T&gt; s, T t, IVL&lt;T&gt; v) {
   v.equal(s.intervalAtOrAfter(t)).equal(
      s.contains(o).and(
         forall(IVL&lt;T&gt; u) where x.contains(u) {
            u.contains(v).implies(u.equal(v));
            })
         .and(v.contains(t).or(forall(T i) where t.lessOrEqual(i)
               .and(i.lessThan(v.low)) {
            s.contains(i).not; })));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-QSET.intervalAfter">
					<head>Interval After (intervalAfter) : <termref ref="dt-IVL">IVL</termref>&lt;T&gt;</head>
					<argument name="x" type="T"/>
					<p>
						<emph role="strong">Definition:     </emph>
							Given a value <emph>t</emph>,
							the greatest continuous subset <emph>v</emph> (an "occurrence interval") of
							the <emph>QSET</emph> value <emph>S</emph>, where <emph>v</emph> is the first interval
							that has a low value greater than <emph>t</emph>.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(QSET&lt;T&gt; s, TS t) {
   s.contains(t).not.implies(s.intervalAfter(t).equal(s.intervalAtOrAfter(t)));
   s.contains(t).implies(s.intervalAfter(t).equal(
               s.except(intervalAtOrAfter(t)).intervalAtOrAfter(t)));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-QSET.interleaves">
					<head>Interleaves (interleaves) : <termref ref="dt-BL">BL</termref>
					</head>
					<argument name="x" type="QSET&lt;T&gt;"/>
					<p>
						<emph role="strong">Definition:     </emph>
							For two <emph>QSET</emph> values <emph>A</emph> and <emph>B</emph>, <emph>A</emph> interleaves <emph>B</emph> if their occurrence
							intervals alternate consistently with no overlap on the time line. This concept is visualized in the Figure below.
						</p>
					<graphic source="graphics/datyp2fig15.jpg" alt="Interleaving occurence intervals and Periodic Hull"/>
					<p>
						For <emph>QSET</emph> values <emph>A</emph> and <emph>B</emph>
						to interleave, the occurrence intervals of both groups must be capable of being arranged
						in pairs of corresponding occurrence intervals. It must further hold
						that for all corresponding occurrence intervals <emph>a</emph>
						&#8838; <emph>A</emph> and <emph>b</emph> &#8838; <emph>B</emph>,
						<emph>a</emph> starts before <emph>b</emph> starts (or at the same
						time) and <emph>b</emph> ends after <emph>a</emph> ends (or at the
						same time).
					</p>
					<p>
						The interleaves-relation holds when two schedules have the same
						average frequency, and when the second schedule never "outpaces" the
						first schedule. That is, no occurrence interval in the second schedule
						may start before its corresponding occurrence interval in the first
						schedule.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(QSET&lt;T&gt; A, B)
      where x.nonNull.and(y.nonNull) {
   A.interleaves(B).equal(
      forall(IVL&lt;T&gt; a, b, c; T t)
         where a.equal(A.intervalAtOrAfter(t))
                .and(b.equal(B.intervalAtOrAfter(a.low)))
                .and(c.equal(A.intervalAtOrAfter(b.high))) {
            b.equal(B.intervalAtOrAfter(a.high));
            a.low.lessOrEqual(b.low);
            c.equal(A.intervalAtOrAfter(b.high));
            c.equal(a).or(c.equal(A.intervalAfter(a.high)));
            });
};</pre>
					</exhibit>
					<p>
					The interleaves-relation is reflexive, asymmetric, and
					intransitive.<footnote>
							<p>
								The interleaves property may appear overly constrained. However, these
								constraints are reasonable for the use case for which the interleaves
								and periodic hull properties are defined. To safely and predictably
								combine two schedules one would want to know which of the operands
								sets the start points and which sets the endpoints of the periodic
								hull's occurrence intervals.
							</p>
						</footnote>
					</p>
				</div3>
				<div3 id="prop-QSET.periodicHull">
					<head>Periodic Hull (periodicHull) : <termref ref="dt-QSET">QSET</termref>&lt;T&gt;</head>
					<argument name="x" type="QSET&lt;T&gt;"/>
					<p>
						<emph role="strong">Definition:     </emph>
						For two <emph>QSET</emph> values <emph>A</emph> and <emph>B</emph>
						where <emph>A</emph> interleaves <emph>B</emph>, a periodic hull is
						defined as the set of convex hulls of the corresponding occurrence
						intervals of <emph>A</emph> and <emph>B</emph>.
						</p>
					<p>
						With two interleaving <emph>QSET</emph> values, one can derive a
						periodic hull such that each occurrence interval of the periodic hull
						is the convex hull of a pair of corresponding occurrence intervals.
					</p>
					<p>
						The periodic hull may be used to construct episodic durations by combining
						<termref ref="dt-QSET">QSET</termref>&lt;<termref ref="dt-TS">TS</termref>&gt; expressions. For example, to construct the periodic
						interval from Memorial Day to Labor Day every year, one first needs to
						set up the schedules <emph>M</emph> for Memorial Day (the last Monday
						in May) and <emph>L</emph> for Labor Day (the first Monday in
						September) and then combine these two schedules using the periodic
						hull of <emph>M</emph> and <emph>L</emph>.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(QSET&lt;T&gt; A, B, C)
      where A.interleaves(B) {
   A.periodicHull(B).equal(C).equal(
      forall(IVL&lt;T&gt; a, b; T t)
         where a.equal(A.intervalAtOrAfter(t))
                .and(b.equal(B.intervalAtOrAfter(a.low))) {
            C.contains(c).equal(c.equal(a.hull(b)));
            });
};</pre>
					</exhibit>
					<p>
						The periodic hull operation is non-commutative and
						non-associative.
					</p>
				</div3>
				<div3 id="prop-QSET.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<argument name="x" type="SET&lt;T&gt;"/>
					<p>
						The evaluation of equality for <emph>QSET</emph> is the same as
						the <termref ref="dt-SET">SET</termref> data type: Two nonNull <termref ref="dt-SET">SET</termref>s are
						equal if they have the same elements.<footnote>
							<p>
								This means that values of the type QSET and any other kind of SET may be equal.
							</p>
						</footnote>
					</p>
				</div3>
				<div3 id="prop-QSET.originalText">
					<head>Original Text (originalText) : <termref ref="dt-ED.TEXT">ED.TEXT</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
					    The text representation from which the <emph>QSET</emph> was encoded, if such a representation is the source
						of the <emph>QSET</emph>. Original text can be used in a structured user interface to capture what the user
						saw as a representation of the code on the data input screen, or in a situation where the user dictates
						or directly enters text, it is the text entered or uttered by the user.
					</p>
					<p>
						The originalText is not a substitute for a valid value. If the actual content of the <emph>QSET</emph> is not
						valid, then the <emph>QSET</emph> SHALL be null, irrespective of whether originalText has a value or not.
					</p>
					<p>
							Note that although post-coding is often performed from free text information,
							such as documents, scanned images or dictation, multi-media data is
							explicitly not permitted as original text. Also, the original text
							property is not meant to be a link into the entire source
							document. The link between different artifacts of medical information
							(e.g., document and coded result) is outside the scope of this
							specification and is maintained elsewhere in the HL7 standards. The
							original text SHALL be an excerpt of the relevant information in the
							original sources, rather than a pointer or exact reproduction. Thus
							the original text SHALL be represented in plain text form. In specific
							circumstances, as described in other HL7 specifications, the originalText
							may be a reference to some other text artefact for which the resolution
							scope is clearly described. 
						</p>
				</div3>
				<div3 id="prop-QSET.demotionList">
					<head>Demotion of QSET to LIST (demotion) : <termref ref="dt-LIST">LIST</termref>&lt;<termref ref="dt-IVL">IVL</termref>&lt;T&gt;&gt;</head>
					<p>
							A <emph>QSET</emph> value can be converted into a <termref ref="dt-LIST">LIST</termref>&lt;<termref ref="dt-IVL">IVL</termref>&lt;T&gt;&gt;.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(QSET&lt;T&gt;  x)
      where x.isEmpty {
   ((LIST&lt;IVL&lt;T&gt;&gt;)x).isEmpty; };

invariant(QSET&lt;T&gt; x, IVL&lt;T&gt; first)
      where x.notEmpty.and(x.hull.low.nonNull)
                      .and(first.equal(x.intervalAtOrAfter(x.hull.low))) {
   ((LIST&lt;IVL&lt;T&gt;&gt;)x).head.equal(first);
   ((LIST&lt;IVL&lt;T&gt;&gt;)x).tail.equal(
      (LIST&lt;IVL&lt;T&gt;&gt;)x.except(first));
};</pre>
					</exhibit>
				</div3>
			</div2>
			<div2 id="dt-QSU">
				<anchor id="QSU"/>
				<head>ContinuousSetUnion (QSU) specializes <termref ref="dt-QSET">QSET</termref>
				</head>
				<parameter name="T" type="QTY"/>
				<p>
					<emph role="strong">Definition:     </emph>
					A Term in a <termref ref="dt-QSET">QSET</termref> expression that builds a <termref ref="dt-QSET">QSET</termref> from a union
					of other <termref ref="dt-QSET">QSET</termref>s.
				</p>
				<exhibit role="dtdl" id="dtdl-QSU">
					<anchor id="dtdl-QSU"/>
					<caption/>
					<pre>
template&lt;QTY T&gt;
type ContinuousSetUnion&lt;T&gt; alias QSU&lt;T&gt; specializes QSET&lt;T&gt; {
    DSET&lt;QSET&lt;T&gt;&gt;   terms;
};</pre>
				</exhibit>
				<div3 id="prop-QSU.terms">
					<head>Terms (terms) : <termref ref="dt-DSET">DSET</termref>&lt;<termref ref="dt-QSET">QSET</termref>&lt;T&gt;&gt;</head>
					<p>
						<emph role="strong">Definition:     </emph>
						A <termref ref="dt-DSET">DSET</termref> of other <termref ref="dt-QSET">QSET</termref>s from which the union is
						built using the <termref ref="dt-SET">SET</termref> union operator.
					</p>
				</div3>
			</div2>
			<div2 id="dt-QSI">
				<anchor id="QSI"/>
				<head>ContinuousSetIntersection (QSI) specializes <termref ref="dt-QSET">QSET</termref>
				</head>
				<parameter name="T" type="QTY"/>
				<p>
					<emph role="strong">Definition:     </emph>
					A Term in a <termref ref="dt-QSET">QSET</termref> expression that builds a <termref ref="dt-QSET">QSET</termref> from an intersection
					of other <termref ref="dt-QSET">QSET</termref>s.
				</p>
				<exhibit role="dtdl" id="dtdl-QSI">
					<anchor id="dtdl-QSI"/>
					<caption/>
					<pre>
template&lt;QTY T&gt;
type ContinuousSetIntersection&lt;T&gt; alias QSI&lt;T&gt; specializes QSET&lt;T&gt; {
    DSET&lt;QSET&lt;T&gt;&gt;   terms;
};</pre>
				</exhibit>
				<div3 id="prop-QSI.terms">
					<head>Terms (terms) : <termref ref="dt-DSET">DSET</termref>&lt;<termref ref="dt-QSET">QSET</termref>&lt;T&gt;&gt;</head>
					<p>
						<emph role="strong">Definition:     </emph>
						A <termref ref="dt-DSET">DSET</termref> of other <termref ref="dt-QSET">QSET</termref>s from which the intersection is
						built using the <termref ref="dt-SET">SET</termref> intersection operator.
					</p>
				</div3>
			</div2>
			<div2 id="dt-QSD">
				<anchor id="QSD"/>
				<head>ContinuousSetDifference (QSD) specializes <termref ref="dt-QSET">QSET</termref>
				</head>
				<parameter name="T" type="QTY"/>
				<p>
					<emph role="strong">Definition:     </emph>
					A Term in a <termref ref="dt-QSET">QSET</termref> expression that builds a <termref ref="dt-QSET">QSET</termref> from the
					difference between 2 <termref ref="dt-QSET">QSET</termref>s.
				</p>
				<exhibit role="dtdl" id="dtdl-QSD">
					<anchor id="dtdl-QSD"/>
					<caption/>
					<pre>
template&lt;QTY T&gt;
type ContinuousSetDifference&lt;T&gt; alias QSD&lt;T&gt; specializes QSET&lt;T&gt; {
    QSET&lt;T&gt;   minuend;
    QSET&lt;T&gt;   subtrahend;
};</pre>
				</exhibit>
				<div3 id="prop-QSD.minuend">
					<head>Minuend (minuend) : <termref ref="dt-QSET">QSET</termref>&lt;T&gt;</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The set that performs the difference operation.
					</p>
				</div3>
				<div3 id="prop-QSD.subtrahend">
					<head>Subtrahend (subtrahend) : <termref ref="dt-QSET">QSET</termref>&lt;T&gt;</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The parameter to the difference operation.
					</p>
				</div3>
			</div2>
			<div2 id="dt-QSP">
				<anchor id="QSP"/>
				<head>ContinuousSetPeriodicHull (QSP) specializes <termref ref="dt-QSET">QSET</termref>
				</head>
				<parameter name="T" type="QTY"/>
				<p>
					<emph role="strong">Definition:     </emph>
					A Term in a <termref ref="dt-QSET">QSET</termref> expression that builds a <termref ref="dt-QSET">QSET</termref> from the
					difference between 2 <termref ref="dt-QSET">QSET</termref>s.
				</p>
				<exhibit role="dtdl" id="dtdl-QSP">
					<anchor id="dtdl-QSP"/>
					<caption/>
					<pre>
template&lt;QTY T&gt;
type ContinuousSetPeriodicHull&lt;T&gt; alias QSP&lt;T&gt; specializes QSET&lt;T&gt; {
    QSET&lt;T&gt;   low;
    QSET&lt;T&gt;   high;
};</pre>
				</exhibit>
				<div3 id="prop-QSD.low">
					<head>Low (low) : <termref ref="dt-QSET">QSET</termref>&lt;T&gt;</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The set that performs the periodic hull operation.
					</p>
				</div3>
				<div3 id="prop-QSD.high">
					<head>High (high) : <termref ref="dt-QSET">QSET</termref>&lt;T&gt;</head>
					<p>
						<emph role="strong">Definition:     </emph>
						The parameter to the periodic hull operation.
					</p>
				</div3>
			</div2>
			<div2 id="dt-QSC">
				<anchor id="QSC"/>
				<head>CodedContinuousSet (QSC) specializes <termref ref="dt-QSET">QSET</termref> and <termref ref="dt-CS">CS</termref>
				</head>
				<parameter name="T" type="QTY"/>
				<p>
					<emph role="strong">Definition:     </emph>
					A Term in a <termref ref="dt-QSET">QSET</termref> expression that builds a <termref ref="dt-QSET">QSET</termref> from a coded value.
				</p>
				<exhibit role="dtdl" id="dtdl-QSC">
					<anchor id="dtdl-QSC"/>
					<caption/>
					<pre>
template&lt;QTY T&gt;
type CodedContinuousSet&lt;T&gt; alias QSC&lt;T&gt; specializes QSET&lt;T&gt;, CS;</pre>
				</exhibit>
				<p>
					The code unambiguously describes a <termref ref="dt-QSET">QSET</termref>&lt;T&gt; 
					such that <termref ref="dt-QSET">QSET</termref> properties can be supported. <emph>QSC</emph> SHALL only be used with 
					parameter types for which HL7 has defined domains and their associated codeSystems. At present 
					HL7 has only done this for <termref ref="dt-TS">TS</termref>, which is the domain GTSAbbreviation, associated with
					the codeSystem defined below. 
				</p>
				<div3 id="datyp2gtslitsym">
					<head>GTSAbbreviation: Codes for <termref ref="dt-QSET">QSET</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;.</head>
					<table id="domain-GTSAbbreviation">
						<caption>Concept Domain GTSAbbreviation. ValueSet OID:  2.16.840.1.113883.11.10720. CodeSystem "GTSAbbreviation", OID: 2.16.840.1.113883.5.1022, Owner: HL7</caption>
						<thead>
							<tr valign="bottom">
								<th>code</th>
								<th>definition</th>
								<th width="20%">GTS Literal</th>
							</tr>
						</thead>
						<tbody>
							<tr valign="top">
								<td>AM </td>
								<td>Every morning at institution specified times. </td>
								<td>H00..11 IST </td>
							</tr>
							<tr valign="top">
								<td>PM </td>
								<td>Every afternoon at institution specified times. </td>
								<td>H12..23 IST </td>
							</tr>
							<tr valign="top">
								<td>BID </td>
								<td>Two times a day at institution specified time </td>
								<td>/(12 h) IST </td>
							</tr>
							<tr valign="top">
								<td>TID </td>
								<td>Three times a day at institution specified time </td>
								<td>/(8 h) IST </td>
							</tr>
							<tr valign="top">
								<td>QID </td>
								<td>Four times a day at institution specified time </td>
								<td>/(6 h) IST </td>
							</tr>
							<tr valign="top">
								<td>JB </td>
								<td>Regular business days (Monday to Friday excluding holidays) </td>
								<td>J1..5 \JH </td>
							</tr>
							<tr valign="top">
								<td>JE </td>
								<td>Regular weekends (Saturday and Sunday excluding holidays) </td>
								<td>J6..7 </td>
							</tr>
							<tr valign="top">
								<td>JH </td>
								<td>Holidays </td>
								<td> </td>
							</tr>
							<tr valign="top">
								<td> JHCHR </td>
								<td>Christian Holidays (Roman/Gregorian "Western" Tradition.) </td>
								<td> </td>
							</tr>
							<tr valign="top">
								<td>  JHCHRXME </td>
								<td>Christmas Eve (December 24) </td>
								<td>M1224 </td>
							</tr>
							<tr valign="top">
								<td>  JHCHRXMS </td>
								<td>Christmas Day (December 25) </td>
								<td>M1225 </td>
							</tr>
							<tr valign="top">
								<td>  JHCHRNEW </td>
								<td>New Year's Day (January 1) </td>
								<td>M0101 </td>
							</tr>
							<tr valign="top">
								<td>  JHCHREAS </td>
								<td>Easter Sunday.  The Easter date is a rather complex calculation based on Astronomical tables describing full moon dates.  Details can be found at [http://www.assa.org.au/edm.html, and http://aa.usno.navy.mil/AA/faq/docs/easter.html].  Note that the Christian Orthodox Holidays are based on the Julian calendar. </td>
								<td> </td>
							</tr>
							<tr valign="top">
								<td>  JHCHRGFR </td>
								<td>Good Friday, is the Friday right before Easter Sunday. </td>
								<td> </td>
							</tr>
							<tr valign="top">
								<td>  JHCHRPEN </td>
								<td>Pentecost Sunday, is seven weeks after Easter (the 50th day of Easter). </td>
								<td> </td>
							</tr>
							<tr valign="top">
								<td> JHNUS </td>
								<td>United States National Holidays (public holidays for federal employees established by U.S. Federal law 5 U.S.C. 6103.) </td>
								<td> </td>
							</tr>
							<tr valign="top">
								<td>  JHNUSMLK </td>
								<td>Dr. Martin Luther King, Jr. Day, the third Monday in January. </td>
								<td>M0115..21 J1 </td>
							</tr>
							<tr valign="top">
								<td>  JHNUSPRE </td>
								<td>Washington's Birthday (Presidential Day) the third Monday in February. </td>
								<td>M0215..21 J1 </td>
							</tr>
							<tr valign="top">
								<td>  JHNUSMEM </td>
								<td>Memorial Day, the last Monday in May. </td>
								<td>M0525..31 J1 </td>
							</tr>
							<tr valign="top">
								<td>  JHNUSMEM5 </td>
								<td>Friday before Memorial Day Weekend </td>
								<td>M0522..28 J5 </td>
							</tr>
							<tr valign="top">
								<td>  JHNUSMEM6 </td>
								<td>Saturday of Memorial Day Weekend </td>
								<td>M0523..29 J6 </td>
							</tr>
							<tr valign="top">
								<td>  JHNUSIND </td>
								<td>Independence Day (4th of July) </td>
								<td>M0704 </td>
							</tr>
							<tr valign="top">
								<td>  JHNUSIND5 </td>
								<td>Alternative Friday before 4th of July Weekend [5 U.S.C. 6103(b)]. </td>
								<td>M0703 J5 </td>
							</tr>
							<tr valign="top">
								<td>  JHNUSIND1 </td>
								<td>Alternative Monday after 4th of July Weekend [5 U.S.C. 6103(b)]. </td>
								<td>M0705 J1 </td>
							</tr>
							<tr valign="top">
								<td>  JHNUSLBR </td>
								<td>Labor Day, the first Monday in September. </td>
								<td>M0901..07 J1 </td>
							</tr>
							<tr valign="top">
								<td>  JHNUSCLM </td>
								<td>Columbus Day, the second Monday in October. </td>
								<td>M1008..14 J1 </td>
							</tr>
							<tr valign="top">
								<td>  JHNUSVET </td>
								<td>Veteran's Day, November 11. </td>
								<td>M1111 </td>
							</tr>
							<tr valign="top">
								<td>  JHNUSTKS </td>
								<td>Thanksgiving Day, the fourth Thursday in November. </td>
								<td>M1122..28 J4 </td>
							</tr>
							<tr valign="top">
								<td>  JHNUSTKS5 </td>
								<td>Friday after Thanksgiving. </td>
								<td>M1123..29 J5 </td>
							</tr>
						</tbody>
					</table>
					<note>
						<p>
								This table is not complete, nor does it include religious holidays
								other than Christian (of the Gregorian [Western] tradition) or
								national holidays countries other than those of the US. This
								is a limitation to be remedied by subsequent additions.
							</p>
					</note>
					<note>
						<p>
								Holidays are locale-specific. Exactly which religious holidays are
								subsumed under JH depends on the locale and other tradition. For
								global interoperability, using constructed <termref ref="dt-QSET">QSET</termref>
								expressions is safer than named holidays. However, some holidays that
								depend on moon phases (e.g., Easter) or ad-hoc decree cannot be easily
								expressed in a <termref ref="dt-QSET">QSET</termref> other than by use <emph>QSC</emph>.
							</p>
					</note>
					<note>
						<p>
							Where possible, table <tabref ref="domain-GTSAbbreviation"/> defines <termref ref="dt-GTS">GTS</termref>
							literal values for <emph>QSC</emph> values that could be used in
							<termref ref="dt-GTS">GTS</termref> literals in place of a coded value. Codes
							are defined for common periods of the day (AM, PM),
							for periods of the week (business day, weekend), and for holidays.
							The computation for the dates of some holidays, namely
							the Easter holiday, involve some sophistication that goes beyond what
							one would represent in a <termref ref="dt-GTS">GTS</termref> literal. It is
							assumed that the dates of these holidays are drawn from some table or
							some generator module that is outside the scope of this specification.
						</p>
					</note>
				</div3>
			</div2>
			<div2 id="dt-IVL">
				<anchor id="IVL"/>
				<head>Interval (IVL) specializes <termref ref="dt-QSET">QSET</termref>
				</head>
				<parameter name="T" type="QTY"/>
				<p>
					<emph role="strong">Definition:     </emph>
					A set of consecutive values of an ordered base data type.
				</p>
				<p>
					Any ordered type can be the basis of an <emph>IVL</emph>; it does not matter
					whether the base type is discrete or continuous. If the base data type
					is only partially ordered, all elements of <emph>IVL</emph> must be
					elements of a totally ordered subset of the partially ordered data
					type. 
				</p>
				<p>
					For example, <termref ref="dt-PQ">PQ</termref> is considered ordered. However the
					ordering of <termref ref="dt-PQ">PQ</termref>s is only partial; a total order is only
					defined among comparable quantities (quantities of the same physical
					dimension).  While <emph>IVL</emph>s between 2 and 4 meter exist, there is no
					<emph>IVL</emph> between 2 meters and 4 seconds.
				</p>
				<p>
					<emph>IVL</emph>s are <termref ref="dt-SET">SET</termref>s and have all the properties of
					<termref ref="dt-SET">SET</termref>s. However, union and difference of <emph>IVL</emph>s
					may not be <emph>IVL</emph>s, since the elements of these union and
					difference <termref ref="dt-SET">SET</termref>s might not be
					contiguous. Intersections of <emph>IVL</emph>s are always <emph>IVL</emph>s.
				</p>
				<p>
							An interval specifies a set where all values apply simultaneously 
							(e.g. The encounter lasted from January 6th through January 12th).  For situations 
							where only one value within the specified range (e.g. "Take 2-4 tablets"), the 
							<termref ref="dt-TS">TS</termref> type should be used. Intervals arise commonly with time, 
							so intervals of <termref ref="dt-TS">TS</termref> are the most common type encountered. 
							Uses for intervals of <termref ref="dt-PQ">PQ</termref> include age &gt; 65, blood 
							pressure &lt; 150 mm Hg, an instruction to keep systolic bp between 80 and 110 mmHg,
							or the width a stain on an electrophoresis gel.
						</p>
				<exhibit role="dtdl" id="dtdl-IVL">
					<anchor id="dtdl-IVL"/>
					<caption/>
					<pre>
template&lt;QTY T&gt;
type Interval&lt;T&gt; alias IVL&lt;T&gt; specializes QSET&lt;T&gt; {
              T       low;
              T       high;
              QTY     width;
              T       center;
              BL      lowClosed;
              BL      highClosed;
              T       any;
              IVL&lt;T&gt;  hull(IVL&lt;T&gt; x);
   literal    ST.SIMPLE;
   promotion  IVL&lt;T&gt;  (T x);
   demotion   T;
};</pre>
				</exhibit>
				<div3 id="prop-IVL.low">
					<head>Low Boundary (low) : T</head>
					<p>
						<emph role="strong">Definition:     </emph>
							The low limit of the interval.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(IVL&lt;T&gt; x; T e)
      where x.nonNull.and(x.contains(e)) {
   x.low.lessOrEqual(e);
   x.low.nullFlavor.implies(NullFlavor.PINF).not;
};</pre>
					</exhibit>
					<p>
							The low limit SHALL NOT be positive infinity. 
						</p>
				</div3>
				<div3 id="prop-IVL.high">
					<head>High Boundary (high) : T</head>
					<p>
						<emph role="strong">Definition:     </emph>
							The high limit of the interval.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(IVL&lt;T&gt; x; T e)
      where x.nonNull.and(x.contains(e)) {
   e.lessOrEqual(x.high);
   x.high.nullFlavor.implies(NullFlavor.NINF).not;
};

invariant(IVL&lt;T&gt; x)
    where x.low.nonNull.and(x.high.nonNull) {
	x.low.lessOrEqual(x.high);
};</pre>
					</exhibit>
					<p>
							The high limit SHALL NOT be negative infinity, and SHALL be higher than the low limit if one exists. 
						</p>
				</div3>
				<div3 id="prop-IVL.width">
					<head>Width (width) : <termref ref="dt-QTY">QTY</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
							The difference between <termref ref="prop-IVL.HIGH">HIGH</termref> and <termref ref="prop-IVL.LOW">LOW</termref>
							boundary. The purpose of distinguishing <emph>width</emph> is to handle all cases of incomplete
							information symmetrically. In any <emph>IVL</emph> representation only two of
							the three properties <termref ref="prop-IVL.HIGH">HIGH</termref>, <termref ref="prop-IVL.LOW">LOW</termref>,
							and <emph>width</emph> need to be stated: the third can be derived.
						</p>
					<p>
							When both boundaries are known, <emph>width</emph> can be derived as
							<termref ref="prop-IVL.HIGH">HIGH</termref> minus <termref ref="prop-IVL.LOW">LOW</termref>.
							When one boundary and <emph>width</emph> is known, the other boundary is
							also known. When no boundary is known, <emph>width</emph> may still be
							known. For example, one knows that an activity takes about 30 minutes,
							but one may not yet know when that activity is started.
						</p>
					<p>
							Note that the data type of <emph>width</emph> is not always the same as for the
							boundaries. For ratio scale quantities (<termref ref="dt-REAL">REAL</termref>,
							<termref ref="dt-PQ">PQ</termref>, <termref ref="dt-MO">MO</termref>) it is the same. For
							difference scale quantities (e.g., <termref ref="dt-TS">TS</termref>) is
							the data type of the difference (e.g., <termref ref="dt-PQ">PQ</termref> in
							the dimension of time for <termref ref="dt-TS">TS</termref>).
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(IVL&lt;T&gt; x) where x.low.nonNull.and(x.high.nonNull) {
   x.low.lessOrEqual(x.high);
   x.width.equal(x.high.minus(x.low));
};

invariant(IVL&lt;T&gt; x, T.diffType z) 
  where x.low.nonNull.and(x.high.nonNull).and(z.isZero) {
   x.width.greaterOrEqual(z);
};

invariant(IVL&lt;T&gt; x) {
   x.width.dataType.implies(T.diffType);
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-IVL.center">
					<head>Central Value (center) : T</head>
					<p>
						<emph role="strong">Definition:     </emph>
							The arithmetic mean of the <emph>IVL</emph>
							(<termref ref="prop-IVL.LOW">LOW</termref> plus <termref ref="prop-IVL.HIGH">HIGH</termref> divided by 2). The
							purpose of distinguishing <emph>center</emph> as a semantic property is for
							conversions of <emph>IVL</emph>s to and from point values. For discrete elements
							(<termref ref="dt-INT">INT</termref>) the center is the floor of true arithmetic center.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(IVL&lt;T&gt; x)
      where x.low.nonNull.and(x.high.nonNull) {
   x.center.equal(x.low.plus(x.width.dividedBy(2)));
};</pre>
					</exhibit>
					<p>
							Note that <emph>center</emph> doesn't always exist for every <emph>IVL</emph>.
							Notably <emph>IVL</emph>s that are infinite on one side do not have
							<emph>center</emph>. Also <emph>IVL</emph>s of discrete base types with an
							even number of elements do not have a <emph>center</emph>. 
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(IVL&lt;T&gt; x) 
   where x.low.nonNull.xor(x.high.nonNull) {
   x.low.nullFlavor.implies("NINF").implies(x.center.nullFlavor.implies("NINF"));
   x.high.nullFlavor.implies("PINF").implies(x.center.nullFlavor.implies("PINF"));
};</pre>
					</exhibit>
					<p>
							If the <emph>IVL</emph> only has one boundary, and the other is the appropriate
							flavor of infinity, the center is also infinity. If both boundaries
							are infinity, the <emph>IVL</emph> has no center.
						</p>
				</div3>
				<div3 id="prop-IVL.lowClosed">
					<head>Low Boundary Closed (lowClosed) : <termref ref="dt-BL">BL</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
							Specifies whether <termref ref="prop-IVL.LOW">LOW</termref> is included in the <emph>IVL</emph>
							(is closed) or excluded from the <emph>IVL</emph> (is open).
						</p>
					<p>
						 	 The default value is true (closed).
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(IVL&lt;T&gt; x)
      where x.nonNull {
   x.low.nonNull.implies(x.lowClosed.equal(x.contains(x.low)));
   x.low.isNull.implies(x.lowClosed.not);
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-IVL.highClosed">
					<head>High Boundary Closed (highClosed) : <termref ref="dt-BL">BL</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
							Specifies whether <termref ref="prop-IVL.HIGH">HIGH</termref> is included in the <emph>IVL</emph>
							(is closed) or excluded from the <emph>IVL</emph> (is open). 
						</p>
					<p>
						 	 The default value is true (closed).
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(IVL&lt;T&gt; x)
      where x.nonNull {
   x.high.nonNull.implies(x.highClosed.equal(x.contains(x.high)));
   x.high.isNull.implies(x.highClosed.not);
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-IVL.any">
					<head>Contained Value (any) : T</head>
					<p>
						<emph role="strong">Definition:     </emph>
							Specifies that nothing is known about the interval except that some particular value
							lies within the interval.
						</p>
					<p>
							This should be used when it is not known when something started, or will end, but
							it is known that it was happening at a given time. This is relatively common for observations
							(i.e. of disease processes), procedure, and scheduling.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(IVL&lt;T&gt; x)
      where x.nonNull.and(x.any.nonNull) {
   x.low.isNull;
   x.high.isNull;
   x.center.isNull;
   x.width.isNull;
   x.lowClosed.isNull;
   x.highClosed.isNull;
};

invariant(IVL&lt;T&gt; ivl, T t)
       where ivl.any.nonNull.and(vl.any.equals(t)) {
  ivl.contains(t);
};</pre>
					</exhibit>
					<p>
							If <emph>any</emph> has value, then nothing else is known about the interval, except that the
							interval contains any. Althought not much is known about the interval, it is still possible
							to determine whether the interval overlaps with another.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(SET&lt;T&gt; set, IVL&lt;T&gt; ivl)
    where set.nonNull.and(ivl.nonNull) {  
  set.contains(ivl.any).implies(set.intersection(ivl).isEmpty.not);
  set.contains(ivl.any).not.implies(set.intersection(ivl).isNull);
};
</pre>
					</exhibit>
				</div3>
				<div3 id="prop-IVL.hull">
					<head>Convex Hull (hull) : <termref ref="dt-IVL">IVL</termref>&lt;T&gt;, inherited from <termref ref="dt-QSET">QSET</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
							The convex hull of the set specified by the interval.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(IVL&lt;T&gt; i) 
    where i.nonNull {
   i.equal(i.hull());
};</pre>
					</exhibit>
					<p>
						  The interval is automatically the convex hull of set that it specifies, so the convex hull of an interval is itself.
						</p>
				</div3>
				<div3 id="prop-IVL.hull">
					<head>Convex Hull (hull) : <termref ref="dt-IVL">IVL</termref>&lt;T&gt;</head>
					<argument name="x" type="IVL&lt;T&gt;"/>
					<p>
						<emph role="strong">Definition:     </emph>
							A convex hull or "interval hull" of two <emph>IVL</emph>s is the least
							<emph>IVL</emph> that is a superset of its operands.
						</p>
					<graphic source="graphics/datyp2fig12.jpg" alt="Convex Hull of two Intervals"/>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(IVL&lt;T&gt; h, IVL&lt;T&gt; i, j)
      where h.nonNull.and(h.equal(i.hull(j))) {
   i.low.lessOrEqual(j.low).implies(h.low.equal(i.low));
   j.low.lessOrEqual(i.low).implies(h.low.equal(j.low));
   i.high.lessOrEqual(j.high).implies(h.high.equal(j.high));
   j.high.lessOrEqual(i.high).implies(h.high.equal(i.high));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-IVL.literal">
					<head>Literal Form</head>
					<p>
							The literal form for <emph>IVL</emph> is defined such that it is
							as intuitive to humans as possible. Seven different forms are
							defined:<footnote>
							<p>
									The presence of so many options deserves explanation. In principle,
									the interval form together with the width-only form would be
									sufficient. However, the interval form is felt alien to many in the
									field of medical informatics. One important purpose of the literal
									forms is to eradicate non-compliance through making compliance easy,
									without compromising on the soundness of the concepts.
								</p>
							<p>
									Furthermore, the different literal forms all have strength and
									weaknesses. The interval and center-width forms' strength is that they
									are most exact, showing closed and open boundaries. The interval
									form's weakness, however, is that infinite boundaries require special
									symbols for infinities, not necessary in the "comparator" form. The
									center-width form cannot specify intervals with an infinite boundary
									at all. The "comparator" form, however, can only represent
									single-bounded intervals (i.e., where the other boundary is infinite
									or unknown).  The dash form, while being the weakest of all, is the
									most intuitive form for double bounded intervals.
								</p>
						</footnote>
					</p>
					<list role="ordered">
						<item>
								the interval form using square brackets, e.g., "[3.5; 5.5["; (where the square brackets denote whether the interval is closed or not. Pointing in means closed, pointing out means not closed)
							</item>
						<item>
								the dash-form, e.g., "3.5-5.5";
							</item>
						<item>
								the "comparator" form, using relational operator symbols, e.g., "&lt;5.5";
							</item>
						<item>
								the center-width form, e.g., "4.5[2.0[".
							</item>
						<item>
								the width-only form using square brackets, e.g., "[2.0[".
							</item>
						<item>
								the center-only form which is simply the value of the center literal, e.g., "4.5".
							</item>
						<item>
								the any form which using question marks, e.g., "?4?".
							</item>
					</list>
					<exhibit role="dtdl">
						<caption/>
						<pre>
IVL&lt;T&gt;.literal ST.SIMPLE {
   IVL&lt;T&gt; range : interval                { $.equal($1); }
                | dash                    { $.equal($1); }
                | comparator              { $.equal($1); }
                | center_width            { $.equal($1); }
                | width                   { $.equal($1); }
                | center                  { $.equal($1); }
                | any                     { $.equal($1); };

   IVL&lt;T&gt; interval
                : open T ";" T close;     { $.low.equal($2);
                                            $.high.equal($4);
                                            $.lowClosed.equal($1);
                                            $.highClosed.equal($5); };
   BL open      : "["                     { $.equal(true); }
                | "]"                     { $.equal(false); };
   BL close     : "]"                     { $.equal(true); }
                | "["                     { $.equal(false); };
   IVL&lt;T&gt; width
                : open T.diffType close   { $.width.equal($2);
                                            $.lowClosed.equal($1);
                                            $.highClosed.equal($3); };
   IVL&lt;T&gt; center_width
                : T width                 { $.center.equal($1);
                                            $.width.equal($2.width);
                                            $.lowClosed.equal($2.lowClosed);
                                            $.highClosed.equal($2.highClosed); };

   IVL&lt;T&gt; center
                : T width                 { $.center.equal($1)};
                
   IVL&lt;T&gt; any
                : "? T "?"                 { $.any.equal($1)};
                
   IVL&lt;T&gt; dash  : T "-" T;                { $.low.equal($2);
                                            $.high.equal($4);
                                            $.lowClosed.equal(true);
                                            $.highClosed.equal(true); };
   IVL&lt;TS&gt; comparator
                : "&lt;"  T                  { $.high.equal(T);
                                            $.high.closed(false);
                                            $.low.negativelyInfinite; }
                | "&gt;"  T                  { $.low.equal(T);
                                            $.low.closed(false);
                                            $.high.positivelyInfinite; }
                | "&lt;=" T                  { $.high.equal(T);
                                            $.high.closed(true);
                                            $.low.negativelyInfinite; }
                | "&gt;=" T                  { $.low.equal(T);
                                            $.low.closed(true);
                                            $.high.positivelyInfinite; };
};</pre>
					</exhibit>
					<!-- FIXME!!! &IVL-literal-examples; -->
				</div3>
				<div3 id="prop-IVL.promotionT">
					<head>Promotion of Element Values to Intervals (promotion) : <termref ref="dt-IVL">IVL</termref>&lt;T&gt;</head>
					<argument name="x" type="T"/>
					<p>
							An integer can be promoted into a trivial <emph>IVL</emph>
							where <termref ref="prop-IVL.LOW">LOW</termref> and <termref ref="prop-IVL.HIGH">HIGH</termref>
							are equal and boundaries closed.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(INT x) where x.nonNull {
   ((IVL&lt;INT&gt;)x).low.equal(x);
   ((IVL&lt;INT&gt;)x).high.equal(x);
   ((IVL&lt;INT&gt;)x).highClosed;
   ((IVL&lt;INT&gt;)x).lowClosed;
};</pre>
					</exhibit>
					<p>
							Where T is a type that represents a continuous domain, the conversion
							to an interval is a function of the precision of the value. The value will convert
							to an interval centered on the value of T, with the lower and upper limits expressing
							the range that is implied by the precision.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(T x) where x.nonNull.and(T.equals(INT).not).and(T.equals(TS).not) {
   ((IVL&lt;T&gt;)x).center.equal(x);
   ((IVL&lt;T&gt;)x).highClosed.not;
   ((IVL&lt;T&gt;)x).lowClosed;
   /* cannot make formal statements about low and high*/
};</pre>
					</exhibit>
					<p>
						A <termref ref="dt-TS">TS</termref> is promoted to an <termref ref="dt-IVL_TS">IVL&lt;TS&gt;</termref>
						whereby the low boundary is the <termref ref="dt-TS">TS</termref> value itself, and
						the width is inferred from the precision of the <termref ref="dt-TS">TS</termref>
						and the duration of the least significant calendar period specified.
						The high boundary is open. For example, the <termref ref="dt-TS">TS</termref> literal
						"200009" is converted to an <termref ref="dt-IVL_TS">IVL&lt;TS&gt;</termref> with low
						boundary 200009 and width 30 days, which is the interval
						"[20000901000000.000;20001001000000.000[".
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(TS x) where x.nonNull {
   /*
   ((IVL&lt;TS&gt;)x).low.equal(x); 
   
   this is not true, the precision of low is arbitrarily high
   and therefore they are not equal */
   
   ((IVL&lt;T&gt;)x).highClosed.not;
   ((IVL&lt;T&gt;)x).lowClosed;
   
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-IVL.demotionT">
					<head>Demotion of Intervals to a Representative Element Value (demotion) : T</head>
					<p>
							An <emph>IVL</emph> can be demoted to a simple quantity of type T that is
							representative for the whole <emph>IVL</emph>. If the interval bounds
							match the bounds expected for a single value/precision combination,
							as defined in <termref ref="prop-IVL.promotionT">promotionT</termref> then that is
							the value.  If both boundaries are finite, it is the <termref ref="prop-IVL.center">center</termref>.
							If one boundary is infinite, the representative value is the other boundary. If both
							boundaries are infinite, the conversion to a point value is not applicable. If the
							contained value (<termref ref="prop-IVL.any">any</termref>) is not NULL, then that is the value.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(IVL&lt;T&gt; x)
      where x.nonNull {
   x.center.nonNull.implies(((T)x).equal(x.center));
   x.low.nonNull.and(x.high.nonNull).implies(((T)x).equal(x.center).or(((IVL&lt;T&gt;)((T)x)).equal(x)));
   x.high.nonNull.and(x.low.isNull).implies(((T)x).equal(x.high));
   x.low.nonNull.and(x.high.isNull).implies(((T)x).equal(x.low));
   x.low.isNull.and(x.high.isNull).and(x.any.isNull).implies(((T)x).notApplicable);
   x.any.nonNull.implies(((T)x).equal(x.any));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-IVL.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<argument name="x" type="SET&lt;T&gt;"/>
					<p>
						The evaluation of equality for <emph>IVL</emph> is the same as
						the <termref ref="dt-SET">SET</termref> data type: Two nonNull <termref ref="dt-SET">SET</termref>s are
						equal if they have the same elements. For IVLs, there are two special cases. 
						Highs are considered equal if they are both positive infinity, and lows are
						considered equal if they are both negative infinity.<footnote>
							<p>
								This means that values of the type <emph>IVL</emph> and any other kind of SET with an equal parameter type may be equal.
							</p>
						</footnote>. Note that if two intervals have the same width and the bounds are not known, 
						they are not considered equal. The same applies where the interval is known by a 
						contained value (<termref ref="prop-IVL.any">any</termref>): such intervals are never considered
						equal.
					</p>
				</div3>
			</div2>
			<div2 id="dt-IVL_PQ">
				<anchor id="IVL&lt;PQ&gt;"/>
				<head>Interval&lt;PhysicalQuantity&gt; (IVL&lt;PQ&gt;) specializes <termref ref="dt-IVL">IVL</termref>
				</head>
				<p>
					<emph role="strong">Definition:     </emph>
					A set of consecutive values of physical quantities.
				</p>
				<p>
					<emph>IVL&lt;PQ&gt;</emph> has a special literal form which is simply an interval of real numbers, a space,
					and the unit.
				</p>
				<exhibit role="dtdl">
					<caption/>
					<pre>
IVL&lt;PQ&gt;.literal ST.SIMPLE {
   IVL&lt;PQ&gt;  : IVL&lt;REAL&gt; " " unit       { $.low.value.equal($1.low);
                                      $.low.unit.equal($3);
                                      $.lowClosed.equal($1.lowClosed);
                                      $.high.value.equal($1.high);
                                      $.high.unit.equal($3);
                                      $.highClosed.equal($1.highClosed); }
            | IVL&lt;REAL&gt;             { $.low.value.equal($1.low);
                                      $.low.unit.equal("1");
                                      $.lowClosed.equal($1.lowClosed);
                                      $.high.value.equal($1.high);
                                      $.high.unit.equal("1");
                                      $.highClosed.equal($1.highClosed); };
   CS unit  : ST                    { $.code.equal($1);
                                      $.codeSystem(2.16.840.1.113883.3.2); };
};</pre>
				</exhibit>
				<p>
					For example: "[0;5] mmol/L" or "&lt;20 mg/dL" are valid literal forms
					of intervals of physical quantities. Note that the generic interval form, e.g.,
					"[50 nm; 2 m]" is also allowed.
				</p>
				<prop id="prop-IVL_PQ.value" longname="Value" shortname="value" type="IVL&lt;REAL&gt;" render="false"/>
				<prop id="prop-IVL_PQ.unit" longname="Unit" shortname="unit" type="CS" render="false"/>
			</div2>
			<div2 id="dt-IVL_TS">
				<anchor id="IVL&lt;TS&gt;"/>
				<head>Interval&lt;PointInTime&gt; (IVL&lt;TS&gt;) specializes <termref ref="dt-IVL">IVL</termref>
				</head>
				<p>
					<emph role="strong">Definition:     </emph>
					A set of consecutive values of time-stamps.
				</p>
				<p>
					The generic interval data type defines the interval of points in time
					too. However, there are some special considerations about literal
					representations and conversions of intervals of point in time, which
					are specified in this section.
				</p>
				<exhibit role="dtdl" id="dtdl-IVL_TS">
					<anchor id="dtdl-IVL_TS"/>
					<caption/>
					<pre>
type Interval&lt;PointInTime&gt; alias IVL&lt;TS&gt; specializes IVL&lt;T&gt;;</pre>
				</exhibit>
				<div3 id="prop-IVL_TS.literal">
					<head>Literal Form</head>
					<p>
						The literal form for interval of point in time is exceptional.
					</p>
					<list role="unordered">
						<item>
							The "dash form" is not allowed for intervals of point in time
						</item>
						<item>
							A "hull form" is defined instead
						</item>
					</list>
					<p>
						In order to avoid syntactic conflicts with the timezone and slightly
						different usage profiles of the ISO 8601 that occur on some ITS
						platforms, <emph role="strong">the dash form of the interval is not
						permitted for</emph>
						<termref ref="dt-IVL_TS">IVL&lt;TS&gt;</termref>. The
						interval-form using square brackets is preferred.
					</p>
					<p>
						Example: May 12, 1987 from 8 to 9:30 PM is k
						"<code>[198705122000;198705122130]</code>".
					</p>
					<note>
						<p>
							The precision of a stated interval boundary is irrelevant for the
							interval. One might wrongly assume that the interval
							"[19870901;19870930]" stands for the entire September 1987 until end
							of the day of September 30. However, this is not so!,  The proper way to
							denote an entire calendar cycle (e.g., hour, day, month, year, etc.)
							in the interval notation with is to use an open high boundary. For
							example, all of September 1987 is denoted as
							"[198709;198710[".<footnote>
								<p>
									This statement seems to directly contradict the ruling about the
									promotion of <termref ref="dt-TS">TS</termref> to <termref ref="dt-IVL_TS">IVL&lt;TS&gt;</termref>.
									However, there is no contradiction. The
									precision of a boundary does not have any relevance, but the precision
									of a simple timestamp (not as an interval boundary) is relevant, when that
									timestamp is promoted to an interval.
								</p>
							</footnote>
						</p>
					</note>
					<p>
						The "hull-form" of the literal is defined as the convex hull (see
						<termref ref="prop-IVL.hull">IVL.hull</termref>) of interval-promotions from two time
						stamps.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
   IVL&lt;TS&gt; hull : TS ".." TS     { $.equal(((IVL&lt;TS&gt;)$1)
                                    .hull((IVL&lt;TS&gt;)$3));
};</pre>
					</exhibit>
					<p>
						For example, "<code>19870901..19870930</code>" is a valid literal
						using the hull form. The value is equivalent to the interval form
						"<code>[19870901;19871001[</code>".<footnote>
							<p>
								The hull form may appear superfluous for the simple interval all by
								itself. However, the hull form will become important for the periodic
								interval notation as it shortens the notation and (perhaps arguably)
								makes the notation of more complex timing structures more intuitive.
							</p>
						</footnote>
					</p>
					<p>
						The hull-form further allows an abbreviation, where the higher
						timestamp literal does not need to repeat digits on the left that are
						the same as for the lower timestamp literal. The two timestamps are
						right-aligned and the digits to the left copied from the lower to the
						higher timestamp literal. This is a simple string operation and is not
						formally defined here.
					</p>
					<p>
						Example: May 12, 1987 to May, 23, 1987 is
						"<code>19870512..23</code>". However, note that May 12, 1987 to June
						2, 1987 is "<code>19870512..0602</code>", and not
						"<code>20000512..02</code>".
					</p>
				</div3>
			</div2>
			<div2 id="dt-PIVL">
				<anchor id="PIVL"/>
				<head>PeriodicInterval (PIVL) specializes <termref ref="dt-QSET">QSET</termref>
				</head>
				<parameter name="T" type="TS"/>
				<p>
					<emph role="strong">Definition:     </emph>
					An interval of time that recurs periodically. <emph>PIVL</emph> has
					two properties, <termref ref="prop-PIVL.phase">phase</termref> and <termref ref="prop-PIVL.period">period</termref>/<termref ref="prop-PIVL.frequency">frequency</termref>.
					<termref ref="prop-PIVL.phase">phase</termref> specifies the "interval
					prototype" that is repeated every <termref ref="prop-PIVL.period">period</termref> or <termref ref="prop-PIVL.frequency">frequency</termref>.
				</p>
				<table id="dt-PIVL-prop-summary">
					<caption>Property Summary of
      PeriodicInterval</caption>
					<col width="79"/>
					<col width="60"/>
					<col width="413"/>
					<thead>
						<tr>
							<th>Name</th>
							<th>Type</th>
							<th>Description</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>
								<termref ref="prop-PIVL.phase">phase</termref>
							</td>
							<td>
								<termref ref="dt-IVL">IVL</termref>&lt;T&gt;</td>
							<td>
							A interval specifying the duration of
							each occurrence and anchoring the <emph>PIVL</emph> sequence at a
							certain point in time.
						</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-PIVL.period">period</termref>
							</td>
							<td>
								<termref ref="dt-PQ">PQ</termref>
							</td>
							<td>
							A time duration specified as a reciprocal measure of the frequency at
							which the <emph>PIVL</emph> repeats.
						</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-PIVL.frequency">frequency</termref>
							</td>
							<td>
								<termref ref="dt-RTO">RTO</termref>&lt;<termref ref="dt-INT">INT</termref>,<termref ref="dt-PQ.TIME">PQ.TIME</termref>&gt;</td>
							<td>
							The number of times the <emph>PIVL</emph> repeats (numerator) within a specified time-period (denominator).
						</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-PIVL.count">count</termref>
							</td>
							<td>
								<termref ref="dt-INT.POS">INT.POS</termref>
							</td>
							<td>
							The number of times the period repeats in total. If count is null, then the period repeats indefinitely
							both before and after the anchor implicit in the phase.
						</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-PIVL.displayFrequencyInd">displayFrequencyInd</termref>
							</td>
							<td>
								<termref ref="dt-BL">BL</termref>
							</td>
							<td>
							If true, indicates that frequency takes priority over period for display purposes
						</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-PIVL.alignment">alignment</termref>
							</td>
							<td>
								<termref ref="dt-CS">CS</termref>
							</td>
							<td>
							Specifies if and how the repetitions are aligned to the cycles 
							of the underlying calendar (e.g., to distinguish every 30 days
							from "the 5th of every month"). A non-aligned <emph>PIVL</emph> recurs
							independently from the calendar. An aligned <emph>PIVL</emph> is
							synchronized with the calendar.
						</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-PIVL.isFlexible">isFlexible</termref>
							</td>
							<td>
								<termref ref="dt-BL">BL</termref>
							</td>
							<td>
							Indicates whether the exact timing is up to the party executing the
							schedule (e.g., to distinguish "every 8 hours" from "3 times a day".). 
						</td>
						</tr>
					</tbody>
				</table>
				<p>
					For example, "every eight hours for two minutes" is a <emph>PIVL</emph>
					where the interval's <termref ref="prop-IVL.WIDTH">IVL.WIDTH</termref> equals 2
					minutes and the <termref ref="prop-PIVL.period">period</termref>
					at which the interval recurs equals 8 hours.
				</p>
				<p>
					<termref ref="prop-PIVL.phase">phase</termref> also marks the anchor point
					in time for the entire series of periodically recurring intervals.
					If count is null, the recurrence of a <emph>PIVL</emph> has no
					beginning or ending, but is infinite in both future and past.
				</p>
				<exhibit role="dtdl" id="dtdl-PIVL">
					<anchor id="dtdl-PIVL"/>
					<caption/>
					<pre>
template&lt;TS T&gt;
type PeriodicInterval&lt;T&gt; alias PIVL&lt;T&gt;
            specializes  QSET&lt;T&gt; {
            IVL&lt;T&gt;       phase;
            PQ           period;
            RTO&lt;INT, PQ.TIME&gt;  frequency;
            INT.POS      count;
            BL           displayFrequencyInd;
            CS           alignment;
            BL           isFlexible;
   literal  ST.SIMPLE;
};</pre>
				</exhibit>
				<p>
					A <emph>PIVL</emph> is fully specified when both <termref ref="prop-PIVL.period">period</termref>/<termref ref="prop-PIVL.frequency">frequency</termref>
					and <termref ref="prop-PIVL.phase">phase</termref> are fully specified.
					The interval MAY be only partially specified where either
					only <termref ref="prop-IVL.WIDTH">IVL.WIDTH</termref> or only one boundary is
					specified. If count is null, then there is no limit to the number of repetitions.
				</p>
				<p>
					For example: "every eight hours for two minutes" specifies only
					<termref ref="prop-PIVL.period">period</termref> and <termref ref="prop-IVL.WIDTH">IVL.WIDTH</termref>
					of <termref ref="prop-PIVL.phase">phase</termref> but no boundary of the
					<termref ref="prop-PIVL.phase">phase</termref>. Conversely,
					"every eight hours starting at 4 o'clock" specifies only
					<termref ref="prop-PIVL.period">period</termref>
					and <termref ref="prop-IVL.LOW">IVL.LOW</termref> of <termref ref="prop-PIVL.phase">phase</termref>
					but not <termref ref="prop-IVL.HIGH">IVL.HIGH</termref> of <termref ref="prop-PIVL.phase">phase</termref>.
					"Every eight hours for two minutes starting at 4 o'clock" is fully specified
					since <termref ref="prop-PIVL.period">period</termref>, and both <termref ref="prop-IVL.LOW">IVL.LOW</termref>
					and <termref ref="prop-IVL.WIDTH">IVL.WIDTH</termref> of <termref ref="prop-PIVL.phase">phase</termref>
					are	specified.
				</p>
				<p>
					<emph>PIVL</emph> is a generic type whose type
					parameter T is restricted to a <termref ref="dt-TS">TS</termref>
					and its extensions. <termref ref="dt-PPD_TS">PPD&lt;TS&gt;</termref>&gt; is
					an extension of <termref ref="dt-TS">TS</termref> and therefore can be used to form
					<termref ref="dt-PIVL">PIVL</termref>&lt;<termref ref="dt-PPD_TS">PPD&lt;TS&gt;</termref>&gt; values. This approach can model schedules of varying specificity.
				</p>
				<p>
					Often times, repeating schedules are only approximately specified. For
					instance "three times a day for ten minutes each" does not usually
					mean a <termref ref="prop-PIVL.period">period</termref> of precisely 8 hours and does
					often not mean exactly 10 minutes intervals. Rather the distance
					between each occurrence may	vary as much as between 3 and 12 hours
					and the <termref ref="prop-IVL.WIDTH">IVL.WIDTH</termref> of the interval
					may be less than 5 minutes or more than 15 minutes.
					<termref ref="dt-PIVL">PIVL</termref>&lt;<termref ref="dt-PPD_TS">PPD&lt;TS&gt;</termref>&gt; can be used to indicate how much
					leeway is allowed or how critical timing is to the specification.
				</p>
				<p>
					Sometimes the periodic interval may occur a set number of times.
					For instance, the the schedule might be "2 minutes every 10 minutes 5 times".
					This can be represented with a phase of width 2 min, a period of 10 min, and
					a count of 5. Note that a more common use case is that the period only occurs
					for a limited time period, such as "once a day between June 3 and Jun 10. Though
					this may be represented using the count property, the proper way to implement
					this is to define the timing specification as an intersection between a <emph>PIVL</emph> and 
					an <termref ref="dt-IVL">IVL</termref>. The data type flavor <termref ref="GTS.BOUNDEDPIVL"/> represents
					this common pattern.   
				</p>
				<div3 id="prop-PIVL.phase">
					<head>Phase (phase) : <termref ref="dt-IVL">IVL</termref>&lt;T&gt;</head>
					<p>
						<emph role="strong">Definition:     </emph>
							A interval specifying the duration of
							each occurrence and anchoring the <emph>PIVL</emph> sequence at a
							certain point in time.
						</p>
					<p>
						<emph>phase</emph> is the prototype interval for the <emph>PIVL</emph>, and it also marks the anchor point in time for the entire series of
							periodically recurring intervals. If count is null, the recurrence of a <emph>PIVL</emph>
							has no begin or end but is infinite in both future and
							past. <termref ref="prop-IVL.WIDTH">IVL.WIDTH</termref> of <emph>phase</emph> SHALL
							be less than or equal to <termref ref="prop-PIVL.period">period</termref>.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (PIVL&lt;T&gt; x)
      where x.nonNull {
   x.phase.nonNull.implies(x.phase.width.lessThan(x.period));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-PIVL.period">
					<head>Period (period) : <termref ref="dt-PQ">PQ</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
							A time duration specified as a reciprocal measure of the frequency at
							which the <emph>PIVL</emph> repeats.
						</p>
					<p>
						<emph>period</emph> is a <termref ref="dt-PQ">PQ</termref> in the dimension of time
							(T.diff). For an uncertain <emph>PIVL</emph>
						<emph>period</emph> is a probability
							distribution over elapsed time.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(PIVL&lt;T&gt; x)
      where x.nonNull {
   x.period.nonNull;
};

invariant(PIVL x) {
   period.isZero.not;
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-PIVL.frequency">
					<head>Frequency (frequency) : <termref ref="dt-RTO">RTO</termref>&lt;<termref ref="dt-INT">INT</termref>,<termref ref="dt-PQ.TIME">PQ.TIME</termref>&gt;</head>
					<p>
						<emph role="strong">Definition:     </emph>
							The number of times the <emph>PIVL</emph> repeats (numerator) within a specified time-period (denominator).
						</p>
					<p>
							The denominator is a <termref ref="dt-PQ">PQ</termref> in the dimension of time (TS.diffType). For an
							uncertain periodic interval the numerator is a probability distribution.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(PIVL&lt;T&gt; x)
      where x.nonNull {
   x.frequency.nonNull;
   x.period.equal(x.frequency.denominator.dividedBy(x.frequency.numerator));
};
</pre>
					</exhibit>
					<note role="ITS">
						<p>
								It would generally be appropriate for only one of period and frequency to represented in an ITS. 
								Although one can be calculated from the other, the ITS SHOULD arrange for only the preferred form
								to be represented.
							</p>
					</note>
				</div3>
				<div3 id="prop-PIVL.count">
					<head>Count (count) : <termref ref="dt-INT.POS">INT.POS</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
							The number of times the period repeats in total. If count is null, then the period repeats indefinitely
							both before and after the anchor implicit in the phase.
						</p>
					<p>
					      It is often not necessary to use the <emph>count</emph>. Limits to the period over which the <emph>PIVL</emph> repeats
					      can be applied by combining the PIVL with other QSETs, for example intersecting it with an 
					      <termref ref="dt-IVL">IVL</termref>&lt;<termref ref="dt-TS">TS</termref>&gt; to determine the start and end times.
					     </p>
				</div3>
				<div3 id="prop-PIVL.displayFrequencyInd">
					<head>Display Frequency Indicator (displayFrequencyInd) : <termref ref="dt-BL">BL</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
							If true, indicates that frequency takes priority over period for display purposes
						</p>
					<p>
							While mathematically frequency and period are interchangeable, reliable human communication requires
							differentiation. For example "4 times per day" and "Every 6 hours" are mathematically equivalent.
							However, good clinical practice requires distinguishing which form was originally expressed as
							this conveys something of the intent.
						</p>
				</div3>
				<div3 id="prop-PIVL.alignment">
					<head>Alignment to the Calendar (alignment) : <termref ref="dt-CS">CS</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
							Specifies if and how the repetitions are aligned to the cycles 
							of the underlying calendar (e.g., to distinguish every 30 days
							from "the 5th of every month"). A non-aligned <emph>PIVL</emph> recurs
							independently from the calendar. An aligned <emph>PIVL</emph> is
							synchronized with the calendar.
						</p>
					<p>
							For example, "every 5th of the month" is a calendar aligned <emph>PIVL</emph>.
							<termref ref="prop-PIVL.period">period</termref> varies from 28 to 31 days depending
							on the calendar month. Conversely, "every 30 days" is an independent
							<termref ref="prop-PIVL.period">period</termref> that will
							fall on a different date each month.
						</p>
					<p>
							The calendar alignment specifies a calendar cycle to which the
							<emph>PIVL</emph> is aligned. The even flow of time will then be
							partitioned by the calendar cycle. The partitioning is called the
							calendar "grid" generated by the aligned-to calendar cycle. The
							boundaries of each occurrence interval will then have equal distance
							from the earliest point in each partition. In other words, the
							distance from the next lower grid-line to the beginning of the
							interval is constant.
						</p>
					<table id="domain-CalendarCycle">
						<caption>Concept Domain CalendarCycle. ValueSet OID:  2.16.840.1.113883.11.10684. CodeSystem "CalendarCycle", OID: 2.16.840.1.113883.5.9, Owner: HL7</caption>
						<thead>
							<tr valign="bottom">
								<th>name</th>
								<th>code</th>
								<th>counter</th>
								<th>digits</th>
								<th>start</th>
								<th>condition</th>
							</tr>
						</thead>
						<tbody>
							<tr valign="top">
								<td>year </td>
								<td>CY </td>
								<td>1 </td>
								<td>4 </td>
								<td>0 </td>
								<td>MY12 </td>
							</tr>
							<tr valign="top">
								<td>month of the year </td>
								<td>MY </td>
								<td>2 </td>
								<td>2 </td>
								<td>1 </td>
								<td>
                        MY01,03,05,07,08,10,12 &#8594; DM31<br/>
                        MY04,06,09,11 &#8594; DM30<br/>
                        MY02 Y/4 Y/100 &#8594; DM28<br/>
                        MY02 Y/4 &#8594; DM29<br/>
                        MY02 &#8594; DM28<br/> </td>
							</tr>
							<tr valign="top">
								<td>month (continuous) </td>
								<td>CM </td>
								<td> </td>
								<td> </td>
								<td>0 </td>
								<td>continuous MY </td>
							</tr>
							<tr valign="top">
								<td>week (continuous) </td>
								<td>CW </td>
								<td> </td>
								<td> </td>
								<td>0 </td>
								<td>CD7 </td>
							</tr>
							<tr valign="top">
								<td>week of the year </td>
								<td>WY </td>
								<td> </td>
								<td>2 </td>
								<td>1 </td>
								<td>continuous DW7 </td>
							</tr>
							<tr valign="top">
								<td>day of the month </td>
								<td>DM </td>
								<td>3 </td>
								<td>2 </td>
								<td>1 </td>
								<td>HD24 </td>
							</tr>
							<tr valign="top">
								<td>day (continuous) </td>
								<td>CD </td>
								<td> </td>
								<td> </td>
								<td>0 </td>
								<td>CH24 </td>
							</tr>
							<tr valign="top">
								<td>day of the year </td>
								<td>DY </td>
								<td> </td>
								<td>3 </td>
								<td>1 </td>
								<td>HD24 </td>
							</tr>
							<tr valign="top">
								<td>day of the week (begins with Monday) </td>
								<td>DW </td>
								<td> </td>
								<td>1 </td>
								<td>1 </td>
								<td>HD24 </td>
							</tr>
							<tr valign="top">
								<td>hour of the day </td>
								<td>HD </td>
								<td>4 </td>
								<td>2 </td>
								<td>0 </td>
								<td>MH60 </td>
							</tr>
							<tr valign="top">
								<td>hour (continuous) </td>
								<td>CH </td>
								<td> </td>
								<td> </td>
								<td>0 </td>
								<td>CN60 </td>
							</tr>
							<tr valign="top">
								<td>minute of the hour </td>
								<td>NH </td>
								<td>5 </td>
								<td>2 </td>
								<td>0 </td>
								<td>
                        UTC leap second &#8594; SN61 &#8594; SN60
		 		      </td>
							</tr>
							<tr valign="top">
								<td>minute (continuous) </td>
								<td>CN </td>
								<td> </td>
								<td> </td>
								<td>0 </td>
								<td>CS60 </td>
							</tr>
							<tr valign="top">
								<td>second of the minute </td>
								<td>SN </td>
								<td>6 </td>
								<td>2 </td>
								<td>0 </td>
								<td>CS1 </td>
							</tr>
							<tr valign="top">
								<td>second (continuous) </td>
								<td>CS </td>
								<td> </td>
								<td> </td>
								<td>0 </td>
								<td>basis </td>
							</tr>
						</tbody>
					</table>
					<p>
							For example, with "every 5th of the month" the alignment
							calendar cycle would be month of the year (<code>MY</code>).  The even
							flow of time is partitioned in months of the year. The distance
							between the beginning of each month and the beginning of its
							occurrence interval is 4 days (4 days because day of month (DM) starts
							counting with 1).  Thus, as months differ in their number of days, the
							distances between the recurring intervals will vary slightly, so that
							the interval occurs always on the 5th.
						</p>
				</div3>
				<div3 id="prop-PIVL.isFlexible">
					<head>Is Flexible (isFlexible) : <termref ref="dt-BL">BL</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
							Indicates whether the exact timing is up to the party executing the
							schedule (e.g., to distinguish "every 8 hours" from "3 times a day".). 
						</p>
					<p>
							For example, with a schedule "three times a day" the average time
							between repetitions is 8 hours, however, with isFlexible indicator 
							equal to <emph>true</emph>, the timing could follow some rule
							made by the executing person or organization that
							e.g., three times a day schedules are executed at 7 am, noon, and 7
							pm.
						</p>
				</div3>
				<div3 id="prop-PIVL.literal">
					<head>Literal Form</head>
					<p>
						<emph role="strong">Generic Literal Form</emph>. The generic
							literal form for periodic intervals of time is as follows:
						</p>
					<p>
							(<emph>phase</emph> : IVL&lt;T&gt;( <emph role="strong">/</emph>
							(<emph>period</emph> : QTY  ( [ <emph role="strong">@</emph>
							(<emph>alignment</emph>( ] [ <emph role="strong">IST</emph> ].
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
PIVL&lt;T&gt;.literal ST.SIMPLE {
   PIVL&lt;T&gt;    : S2                  { $.equal($1); }
              | S2 "IST"            { $.phase.equal($1.phase);
                                      $.period.equal($1.period);
                                      $.isFlexible.equal(true); };
   PIVL&lt;T&gt; S2 : S1                  { $.equal($1); }
              | S1 "@" "(" ST ")"   { $.phase.equal($1.phase);
                                      $.period.equal($1.period);
                                      $.alignment.equal($4); };
   PIVL&lt;T&gt; S1 :
      IVL&lt;T&gt; "/" "(" QTY ")"        { $.phase.equal($1);
                                      $.period.equal($3); }
              | "/" "(" QTY ")"     { $.period.equal($2); };
};</pre>
					</exhibit>
					<p>
							For example, "<code>[200004181100;200004181110]/(7 d)@DW</code>"
							specifies every Tuesday from 11:00 to 11:10 AM. Conversely,
							"<code>[200004181100;200004181110]/(1 mo)@DM</code>" specifies every
							18th of the month 11:00 to 11:10 AM.
						</p>
					<p>
						<emph role="strong">Calendar Pattern Form</emph>. This form is
							used to specify calendar-aligned timing more intuitively using "calendar
							patterns."  The calendar pattern syntax is (semi-formally) defined as
							follows:
						</p>
					<p>
							(<emph>anchor</emph>( [ (<emph>calendar digits</emph>(
							 [ <emph role="strong">..</emph> (<emph>calendar digits</emph>( ]]
							<emph role="strong">/</emph> (<emph>number</emph>
							 : INT( [ <emph role="strong">IST</emph> ]
						</p>
					<p>
							A calendar pattern is a calendar date where the higher significant
							digits (e.g., year and month) are omitted. In order to interpret the
							digits, a period identifier is prefixed that identifies the calendar
							period of the left-most digits. This calendar period identifier
							<emph>anchors</emph> the calendar digits following to the right.
						</p>
					<p>
							See <tabref ref="domain-CalendarCycle"/> for calendar-period codes
							defined for the Gregorian calendar. There are 1-character and
							2-character symbols. The 2-character symbols are preferred for the
							<termref ref="prop-PIVL.alignment">alignment</termref>. The 1-character symbols are preferred for the
							calendar pattern anchor.
						</p>
					<p>
							For example: "<code>M0219</code>" is February 19 the entire day every
							year. This periodic interval has the February 19 of any year as its
							phase (e.g., "<code>[19690219;19690220[</code>" ), a period of one
							year, and alignment month of the year (M). The alignment
							calendar-cycle is the same as the anchor (e.g., in this example, month
							of the year).
						</p>
					<p>
							The calendar digits may also omit digits on the right. When digits are
							omitted on the right, this means the interval from lowest to highest
							for these digits. For example, "<code>M0219</code>" is February 19 the
							entire day; "<code>M021918</code>" is February 19, the entire hour
							between 6 and 7 PM.
						</p>
					<p>
							In absence of a formal definition for this, the rules for parsing a
							calendar pattern are as follows (example is "<code>M021918..21</code>"):
						</p>
					<list role="ordered">
						<item>
								read the anchoring period identifier (e.g. "<code>M</code>")
							</item>
						<item>
								alignment is equal to this calendar period (e.g. month of
								the year)
							</item>
						<item>
								use the current point in time and format a literal exact to the next
								higher significant calendar period from the anchoring calendar period
								(e.g. year, "<code>2000</code>", constructing
								"<code>2000021918</code>"); this is the "stem literal"
							</item>
						<item>
								read this constructed literal (e.g., "<code>2000021918</code>") into a
								<termref ref="dt-TS">TS</termref> value and convert that value to an interval
								according to <termref ref="prop-IVL_TS.promotionTS">IVL_TS.promotionTS</termref> (e.g.,
								"[2000021918;2000021919[") this is the "low interval."
							</item>
						<item>
								if the hull-operator token ".." follows, read the following calendar
								digits (e.g., "21")
							</item>
						<item>
								right-align the stem literal and the calendar digits just read
								<pre>
     "2000021918"
     "        21"
								</pre>
						</item>
						<item>
								and copy all digits from the stem literal that are missing to the left
								of the calendar digits just read (e.g., yields "<code>2000021921</code>").
							</item>
						<item>
								read this constructed literal (e.g., "<code>2000021918</code>") into a
								<termref ref="dt-TS">TS</termref> value and convert that value to an <termref ref="dt-IVL_TS">IVL&lt;TS&gt;</termref>
								according to <termref ref="prop-IVL_TS.promotionTS">IVL_TS.promotionTS</termref>
								(e.g., "<code>[2000021921;2000021922[</code>") this is the "high interval."
							</item>
						<item>
							<termref ref="prop-PIVL.phase">phase</termref> is the convex hull of the low interval and the high
								interval (e.g., "<code>[2000021918;2000021922[</code>").
							</item>
						<item>
								if the hull-operator was not present, <termref ref="prop-PIVL.phase">phase</termref> is simply the low interval.
							</item>
					</list>
					<p>
						<emph role="strong">Interleave.</emph> A calendar pattern
							followed by a slash and an integer number <emph>n</emph> indicates that the
							given calendar pattern is to apply every nth time.
						</p>
					<p>
							For example: "<code>D19/2</code>" is the 19th of every second month.
						</p>
					<p>
							A calendar pattern expression is evaluated at the time the pattern is
							first encountered. At this time, the calendar digits missing from the left
							are completed using the earliest date matching the pattern (and
							following a preceding pattern in a combination of time sets).
						</p>
					<p>
							For example: "<code>D19/2</code>" is the 19th of every second
							month. If this expression is evaluated on March 14, 2000 
							<termref ref="prop-PIVL.phase">phase</termref> is
							completed to: "<code>[20000319;20000320[/(2 mo)@DM</code>" and thus
							the two-months cycle begins with March 19, followed by May 19, etc. If
							the expression were evaluated by March 20, the cycle would begin at
							April 19, followed by June 19, etc.
						</p>
					<p>
							If no calendar digits follow after the calendar period identifier, the
							pattern matches any date. The integer number following the slash
							indicates the length of the cycle. <termref ref="prop-PIVL.phase">phase</termref>
							in these cases
							has only the width specified to be the duration of the anchoring
							calendar-cycle (e.g., in this example 1 day).
						</p>
					<p>
							For example: "<code>CD/2</code>" is every other day,
							"<code>H/8</code>" is every 8th hour, for the duration of one hour.
						</p>
					<p>
						<emph role="strong">Institution Specified Time.</emph> Both a 
							<emph>PIVL</emph> literal and a calendar pattern may be followed by
							the three letters "IST" to indicate that within the larger calendar
							cycle (e.g., for "hour of the day" the larger calendar cycle is "day")
							the repeating events are to be appointed at institution specified
							times. This is used to specify such schedules as "three times a day"
							where the periods between two subsequent events may vary well between
							4 hours (between breakfast and lunch) and 10 hours (over night).
							</p>
					<table id="examples-PIVL.literal">
						<caption>
								Examples for literal expressions for <emph>PIVL</emph>s
              				</caption>
						<col width="2.58" span="1"/>
						<col width="1.37" span="1"/>
						<col width="5.13" span="1"/>
						<thead>
							<tr>
								<th rowspan="1" colspan="1">Generic Form</th>
								<th rowspan="1" colspan="1">Calendar Pattern Form</th>
								<th rowspan="1" colspan="1">Description</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td rowspan="1" colspan="1">[198709;198710[/(1 a)@MY</td>
								<td rowspan="1" colspan="1">M09</td>
								<td rowspan="1" colspan="1">
										September, the entire month, every year (note that in 
										the year 1987 in the generic form is irrelevant since the
										periodic interval recurs every year past and future).
									</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">[19870915;19870916[/(1 a)@DM</td>
								<td rowspan="1" colspan="1">M0915</td>
								<td rowspan="1" colspan="1">September 15, the entire day, every year</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">[1987091516;1987091517[/(1 a)@DM</td>
								<td rowspan="1" colspan="1">M091516</td>
								<td rowspan="1" colspan="1">September 15 at 4 PM, the entire hour, every year</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">[198709151630;198709151710]/(1 a)@DM</td>
								<td rowspan="1" colspan="1">M09151630..1710</td>
								<td rowspan="1" colspan="1">September 15 at 4:30 5:10 PM, every year</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">[1987091516;[/(1 a)@DM</td>
								<td rowspan="1" colspan="1"> </td>
								<td rowspan="1" colspan="1">September 15 at 4 PM, end time explicitly unknown, every year</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">[198709151630;198709151631[/(1 a)@DM</td>
								<td rowspan="1" colspan="1">M09151630</td>
								<td rowspan="1" colspan="1">September 15 at 4:30 PM, the entire minute, every year</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">[1987091516;1987091517[/(1 mo)@DM</td>
								<td rowspan="1" colspan="1">D1516..17</td>
								<td rowspan="1" colspan="1">every 15th day of the month at 4 to 5 PM</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">[1987091516;1987091517[/(1 mo)</td>
								<td rowspan="1" colspan="1"> </td>
								<td rowspan="1" colspan="1">
										September 15, 1987 from 4 to 5 PM and then every 730.5 
										hours continuously (this example has little practical value 
										beyond comparing the unaligned with the aligned form in the 
										preceding row).
									</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">[1987091516;1987091517[/(1 mo)@HD</td>
								<td rowspan="1" colspan="1"> </td>
								<td rowspan="1" colspan="1">
										September 15, 1987 from 4 to 5 PM and then every 30.4375
										days, but aligned to the hour of the day.
									</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">[1 mo]/(2 mo)@MY</td>
								<td rowspan="1" colspan="1">M/2</td>
								<td rowspan="1" colspan="1">
										every other month of the year; (Jan, Mar, ...) vs. (Feb, 
										Apr, ...) is undefined
									</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">[198701;197502[/(2 mo)@MY</td>
								<td rowspan="1" colspan="1">M01..12/2</td>
								<td rowspan="1" colspan="1">every other month of the year, Jan, Mar, ...</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">[198702;197503[/(2 mo)@MY</td>
								<td rowspan="1" colspan="1">M02..12/2</td>
								<td rowspan="1" colspan="1">every other month of the year, Feb, Apr, ...</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">[19870401;19870930[/(1 a)@DM</td>
								<td rowspan="1" colspan="1">M04..09</td>
								<td rowspan="1" colspan="1">April 1until (and including) September 30</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">19870401-0930/(1 a)@DM</td>
								<td rowspan="1" colspan="1">M0401..0930</td>
								<td rowspan="1" colspan="1">
										April 1 to September 30 (the generic form uses the 
										dash-form for the phase interval)
									</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">[20001202;20001203[/(1 wk)@DW</td>
								<td rowspan="1" colspan="1">J6</td>
								<td rowspan="1" colspan="1">every Saturday</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">[20001202;20001203[/(2 wk)@DW</td>
								<td rowspan="1" colspan="1">J6/2</td>
								<td rowspan="1" colspan="1">every other Saturday</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">[20001202;20001203[/(3 wk)@DW</td>
								<td rowspan="1" colspan="1">J6/3</td>
								<td rowspan="1" colspan="1">every third Saturday</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">[1 d]/(2 d)@DW</td>
								<td rowspan="1" colspan="1">J/2</td>
								<td rowspan="1" colspan="1">
										every other day of the week; (Mon, Wed, Fri, ...) vs. 
										(Tue, Thu, Sat, ...)  is undefined
									</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">[20001204;20001205[/(2 d)@DW</td>
								<td rowspan="1" colspan="1">J2..6/2</td>
								<td rowspan="1" colspan="1">
										every other day of the week (Tue, Thu, Sat, Tue, Thu, 
										Sat, ...)
									</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">[20001204;20001205[/(2 d)</td>
								<td rowspan="1" colspan="1">D/2</td>
								<td rowspan="1" colspan="1">
										every other day (Tue, Thu, Sat, Mon, Wed, Fri, Sun, 
										Tue, ...)
									</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">[19870601;19870606[/(1 wk)@DW</td>
								<td rowspan="1" colspan="1">J1..5</td>
								<td rowspan="1" colspan="1">Monday to Friday every week</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">[19870601;19870608[/(2 wk)</td>
								<td rowspan="1" colspan="1">W/2</td>
								<td rowspan="1" colspan="1">every other week (continuous)</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">[19870101;19870105[/(2 wk)@WY</td>
								<td rowspan="1" colspan="1">WY/2</td>
								<td rowspan="1" colspan="1">
										every other week of the year (a blunt example on the 
										impact of the calendar alignment: the phase interval spans 
										only 4 days and yet it represents an entire week in the 
										calendar alignment "week of the year").
									</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">[19870406;19870413[/(1 a)@WY</td>
								<td rowspan="1" colspan="1">WY15</td>
								<td rowspan="1" colspan="1">the 15th calendar week of every year</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">[19870105;19870112[/(1 mo)@WM</td>
								<td rowspan="1" colspan="1">WM2</td>
								<td rowspan="1" colspan="1">the second week of the month, every month</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">[19870508;19870509[/(1 a)@DY</td>
								<td rowspan="1" colspan="1">DY128</td>
								<td rowspan="1" colspan="1">the 128th day of the year, every year</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">[10 min]/(2 d)</td>
								<td rowspan="1" colspan="1"> </td>
								<td rowspan="1" colspan="1">
										every other day for 10 minutes (only width of repeating 
										interval is known)
									</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">[1 h]/(8 h)</td>
								<td rowspan="1" colspan="1">H/8</td>
								<td rowspan="1" colspan="1">every eighth hour (each time a 60 minutes interval)</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">[1 h]/(8 h) IST</td>
								<td rowspan="1" colspan="1">H/8 IST</td>
								<td rowspan="1" colspan="1">
										three times a day at institution specified times (each 
										time a 60 minutes interval)
									</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">/(8 h) IST</td>
								<td rowspan="1" colspan="1"> </td>
								<td rowspan="1" colspan="1">
										three times a day at institution specified times. 
										Nothing about the repeating interval is known i.e., this 
										includes only a period (frequency), while the phase is left 
										undefined
									</td>
							</tr>
						</tbody>
					</table>
				</div3>
				<div3 id="prop-PIVL.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<argument name="x" type="SET"/>
					<p>
						The evaluation of equality for <emph>PIVL</emph> is the same as
						the <termref ref="dt-SET">SET</termref> data type: Two nonNull <termref ref="dt-SET">SET</termref>s are
						equal if they have the same elements.<footnote>
							<p>
								This means that values of the type <emph>PIVL</emph> and any other kind of SET may be equal.
							</p>
						</footnote>
					</p>
				</div3>
				<div3>
					<head>Periodic Intervals as Sets</head>
					<p>
						The essential property of a set is that it contains elements. For
						non-aligned <emph>PIVL</emph>s, the <emph>contains</emph>-property is
						defined as follows. A <termref ref="dt-TS">TS</termref> <emph>t</emph> is
						contained in the <emph>PIVL</emph> if and only if there is an integer
						<emph>i</emph> for which <emph>t</emph> plus <termref ref="prop-PIVL.period">period</termref>
						times <emph>i</emph> is an element of <termref ref="prop-PIVL.phase">phase</termref>.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (PIVL&lt;TS&gt; x, TS t)
      where x.nonNull.and(x.alignment.isNull) {
   x.contains(t).equal(exists(INT i) {
      x.phase.contains(t.plus(x.period.times(i)));
      });
};</pre>
					</exhibit>
					<p>
						For calendar-aligned <emph>PIVL</emph>s the <emph>contains</emph>
						property is defined using the calendar-cycle's sum(<emph>t</emph>,
						<emph>n</emph>) property that adds <emph>n</emph> such calendar cycles
						to the time <emph>t</emph>.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (PIVL&lt;TS&gt; x, TS t, CalendarCycle c)
      where x.nonNull.and(c.equal(x.alignment)) {
   x.contains(t).equal(exists(INT i) {
      x.phase.contains(c.sum(t, i));
      });
};</pre>
					</exhibit>
				</div3>
			</div2>
			<div2 id="dt-EIVL">
				<anchor id="EIVL"/>
				<head>EventRelatedPeriodicInterval (EIVL) specializes <termref ref="dt-QSET">QSET</termref>
				</head>
				<parameter name="T" type="TS"/>
				<p>
					<emph role="strong">Definition:     </emph>
					Specifies a periodic interval of time where the recurrence is based on
					activities of daily living or other important events that are
					time-related but not fully determined by time.
				</p>
				<p>
					For example, "one hour after breakfast" specifies the beginning of the
					interval at one hour after breakfast is finished. Breakfast is assumed
					to occur before lunch but is not determined to occur at any specific
					time.
				</p>
				<exhibit role="dtdl" id="dtdl-EIVL">
					<anchor id="dtdl-EIVL"/>
					<caption/>
					<pre>
template&lt;TS T&gt;
type EventRelatedPeriodicInterval&lt;T&gt; alias EIVL&lt;T&gt;
           specializes  QSET&lt;T&gt; {
           CS           event;
           IVL&lt;PQ&gt;      offset;
  literal  ST.SIMPLE;
};</pre>
				</exhibit>
				<div3 id="prop-EIVL.event">
					<head>Event (event) : <termref ref="dt-CS">CS</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
							A code for a common (periodical) activity of daily living based on
							which the event related periodic interval is specified.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(EIVL&lt;T&gt; x)
     where x.nonNull {
   x.event.nonNull;
};</pre>
					</exhibit>
					<p>
							A proper EIVL requires the event to be specified.
						</p>
					<p>
							In order for an event to qualify for being adopted in the domain of this
							attribute, all of the following must be true:
						</p>
					<list role="unordered">
						<item>
								the event commonly occurs on a regular basis
							</item>
						<item>
								the event is being used for timing activities, and
							</item>
						<item>
								the event is not entirely determined by time
							</item>
					</list>
					<table id="domain-TimingEvent">
						<caption>Concept Domain TimingEvent. ValueSet OID:  2.16.840.1.113883.11.10706. CodeSystem "TimingEvent", OID: 2.16.840.1.113883.5.139, Owner: HL7</caption>
						<thead>
							<tr valign="bottom">
								<th>lvl</th>
								<th>code</th>
								<th>name</th>
								<th>definition</th>
							</tr>
						</thead>
						<tr valign="top">
							<td>1</td>
							<td>HS</td>
							<td>HS</td>
							<td>
								<p>the hour of sleep</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>WAKE</td>
							<td>Waking</td>
							<td>
								<p>upon waking</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>AC</td>
							<td>AC</td>
							<td>
								<p>before meal (from lat. ante cibus)</p>
							</td>
						</tr>
						<tr valign="top">
							<td>2</td>
							<td> ACM</td>
							<td>ACM</td>
							<td>
								<p>before breakfast (from lat. ante cibus matutinus)</p>
							</td>
						</tr>
						<tr valign="top">
							<td>2</td>
							<td> ACD</td>
							<td>ACD</td>
							<td>
								<p>before lunch (from lat. ante cibus diurnus)</p>
							</td>
						</tr>
						<tr valign="top">
							<td>2</td>
							<td> ACV</td>
							<td>ACV</td>
							<td>
								<p>before dinner (from lat. ante cibus vespertinus)</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>IC</td>
							<td>IC</td>
							<td>
								<p>between meals (from lat. inter cibus)</p>
							</td>
						</tr>
						<tr valign="top">
							<td>2</td>
							<td> ICM</td>
							<td>ICM</td>
							<td>
								<p>between breakfast and lunch</p>
							</td>
						</tr>
						<tr valign="top">
							<td>2</td>
							<td> ICD</td>
							<td>ICD</td>
							<td>
								<p>between lunch and dinner</p>
							</td>
						</tr>
						<tr valign="top">
							<td>2</td>
							<td> ICV</td>
							<td>ICV</td>
							<td>
								<p>between dinner and the hour of sleep</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>PC</td>
							<td>PC</td>
							<td>
								<p>after meal (from lat. post cibus)</p>
							</td>
						</tr>
						<tr valign="top">
							<td>2</td>
							<td> PCM</td>
							<td>PCM</td>
							<td>
								<p>after breakfast (from lat. post cibus matutinus)</p>
							</td>
						</tr>
						<tr valign="top">
							<td>2</td>
							<td> PCD</td>
							<td>PCD</td>
							<td>
								<p>after lunch (from lat. post cibus diurnus)</p>
							</td>
						</tr>
						<tr valign="top">
							<td>2</td>
							<td> PCV</td>
							<td>PCV</td>
							<td>
								<p>after dinner (from lat. post cibus vespertinus)</p>
							</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>C</td>
							<td>C</td>
							<td>
								<p>meal (from lat. cibus)</p>
							</td>
						</tr>
						<tr valign="top">
							<td>2</td>
							<td> CM</td>
							<td>CM</td>
							<td>
								<p>breakfast (from lat. cibus matutinus)</p>
							</td>
						</tr>
						<tr valign="top">
							<td>2</td>
							<td> CD</td>
							<td>CD</td>
							<td>
								<p>lunch (from lat. cibus diurnus)</p>
							</td>
						</tr>
						<tr valign="top">
							<td>2</td>
							<td> CV</td>
							<td>CV</td>
							<td>
								<p>dinner (from lat. cibus vespertinus)</p>
							</td>
						</tr>
					</table>
					<p>
					   Events that are not listed in this table, and that do not meet the criteria listed above are not
					   suitable for use with the EIVL data type. On such example is sequenced acitivities as part of 
					   a clinical trial. More sophisticated RIM derived pattern should be used for such event 
					   associations. 
					<footnote>
							<p>HL7 is preparing a document that contains common usage patterns that
					will discuss how to best handle event associations in common healthcare identification use cases.</p>
						</footnote>
					</p>
				</div3>
				<div3 id="prop-EIVL.offset">
					<head>Offset (offset) : <termref ref="dt-IVL">IVL</termref>&lt;<termref ref="dt-PQ">PQ</termref>&gt;</head>
					<p>
						<emph role="strong">Definition:     </emph>
							An interval of elapsed time (duration, not absolute point in time)
							that marks the offsets for the beginning, width and end of
							the <emph>EIVL</emph> measured from the time each such
							event actually occurred.
						</p>
					<p>
							For example: if the specification is "one hour before breakfast for 10
							minutes", the event is CM, <termref ref="prop-IVL.LOW">IVL.LOW</termref> of <emph>offset</emph> is -1 h
							and the <termref ref="prop-IVL.WIDTH">IVL.WIDTH</termref> of <emph>offset</emph> is
							10 min(consequently the offset's high boundary is -50 min).
						</p>
					<p>
							The <emph>offset</emph> SHALL be null if the event code specifies "before", "after" or "between meals". 
							The <emph>offset</emph> SHALL be nonNull if the <emph>EIVL</emph> is nonNull and the event code is C, CM, CD, or CV. 
							The <emph>offset</emph> may or may not be null for the event codes HS and WAKE.   
						</p>
				</div3>
				<div3 id="prop-EIVL.literal">
					<head>Literal Form</head>
					<p>
							The literal form for an <emph>EIVL</emph> begins with the event
							code followed by an optional interval of the time-difference.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
EIVL&lt;TS&gt;.literal ST.SIMPLE {
   EIVL&lt;TS&gt; : event          { $.event.equal($1); }
            | event offset   { $.event.equal($1);
                               $.offset.equal($2); };
   CS event : ST             { $.code.equal($1);
                               $.codeSystem.equal(2.16.840.1.113883.5.1019); }
   IVL&lt;PQ&gt; offset
            : "+" IVL&lt;PQ&gt;    { $.equal($2); }
            | "-" IVL&lt;PQ&gt;    { $.low.equal($2.high.negate);
                               $.high.equal($2.low.negate);
                               $.width.equal($2.width);
                               $.lowClosed($2.highClosed);
                               $.highClosed($2.lowClosed); };
};</pre>
					</exhibit>
					<p>
							For example, one hour after meal would be
							"<code>PC+[1h;1h]</code>". One hour before bedtime for 10 minutes:
							"<code>HS-[50min;40min]</code>".
						</p>
				</div3>
				<div3 id="prop-EIVL.intervalAt">
					<head>Interval At (intervalAt) : <termref ref="dt-IVL">IVL</termref>&lt;T&gt;, inherited from <termref ref="dt-QSET">QSET</termref>
					</head>
					<argument name="x" type="TS"/>
					<p>
					  An <emph>EIVL</emph> is a set of time, that is, one can test whether a particular time or time interval is an element of the set.
					  Whether an <emph>EIVL</emph> contains a given interval of time is decided using a relation event ? time referred to as
					  EVENT(event, time). The property prop-EIVL.intervalAt(t) is the occurrence interval that would exist if the event occurred
					  at time t.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(EIVL&lt;T&gt; x, T eventTime, IVL&lt;T&gt; v)
      where v.equal(x.intervalAt(eventTime)) {
   v.low.equal(eventTime.plus(x.offset.low));
   v.high.equal(eventTime.plus(x.offset.high));
   v.lowClosed.equal(x.offset.lowClosed);
   v.highClosed.equal(x.offset.highClosed);
};</pre>
					</exhibit>
					<p>
						Thus, an EIVL contains a <termref ref="dt-TS">TS</termref> t if there is an event time e with an occurrence interval v such that v contains t.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(EIVL&lt;T&gt; x, T y) {
   x.contains(y).equal(exists(T e, IVL&lt;T&gt; v)
      where EVENT(x.event, y).and(v.resolvedAt(y)) {
         v.contains(y);
         });
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-EIVL.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<argument name="x" type="SET"/>
					<p>
						The evaluation of equality for <emph>EIVL</emph> is the same as
						the <termref ref="dt-SET">SET</termref> data type: Two nonNull <termref ref="dt-SET">SET</termref>s are
						equal if they have the same elements.<footnote>
							<p>
								This means that values of the type <emph>EIVL</emph> and any other kind of SET may be equal.
							</p>
						</footnote>
					</p>
				</div3>
			</div2>
			<div2 id="dt-QSET_TS">
				<anchor id="QSET&lt;TS&gt;"/>
				<head>ContinuousSet&lt;PointInTime&gt; (QSET&lt;TS&gt;) specializes <termref ref="dt-QSET">QSET</termref>
				</head>
				<p>
					<emph role="strong">Definition:     </emph>
					A set of intervals constructed to describe specific and potentially complex schedules.
				</p>
				<p>
					<emph>QSET&lt;TS&gt;</emph> is used to specify the timing of schedules, events, actions and the cyclical validity-patterns
					that may exist for certain kinds of information, such as phone numbers (evening,
					daytime), addresses (so called "snowbirds," residing closer to the equator during
					winter and farther from the equator during summer) and office hours.
				</p>
				<exhibit role="dtdl" id="dtdl-QSET_TS">
					<anchor id="dtdl-QSET_TS"/>
					<caption/>
					<pre>
type ContinuousSet&lt;PointInTime&gt; alias QSET&lt;TS&gt; specializes QSET&lt;T&gt; {
  literal  ST.SIMPLE;  
};</pre>
				</exhibit>
				<p>
					<emph>QSET&lt;TS&gt;</emph> has the following aspects:
				</p>
				<list role="unordered">
					<item>
						<emph>QSET&lt;TS&gt;</emph> as a general <termref ref="dt-QSET">QSET</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;.
						From this aspect <emph>QSET&lt;TS&gt;</emph> answers whether any given
						<termref ref="dt-TS">TS</termref> falls in the schedule described by the
						<emph>QSET&lt;TS&gt;</emph> value.
					</item>
					<item>
						<emph>QSET&lt;TS&gt;</emph> as the combination of multiple <termref ref="dt-PIVL">PIVL</termref>s. This
						aspect describes how both simple and complex repeat-patterns are
						specified with <emph>QSET&lt;TS&gt;</emph>.
					</item>
					<item>
						<emph>QSET&lt;TS&gt;</emph> as a generator of a <termref ref="dt-LIST">LIST</termref>&lt;<termref ref="dt-IVL">IVL</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;&gt;.
						From this aspect, <emph>QSET&lt;TS&gt;</emph> can generate all occurrence
						intervals of an event or action, or all validity periods for a fact.
					</item>
					<item>
						<emph>QSET&lt;TS&gt;</emph> as an expression-syntax defined for a calendar. This aspect is the
						<emph>QSET&lt;TS&gt;</emph> literal form, defined below.
					</item>
				</list>
				<p>
					In all cases, <emph>QSET&lt;TS&gt;</emph> as a <termref ref="dt-SET">SET</termref>&lt;<termref ref="dt-TS">TS</termref>&gt; is built from one
					of the building blocks of <termref ref="dt-QSET">QSET</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;: <termref ref="dt-QSU">QSU</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;,
					<termref ref="dt-QSI">QSI</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;, <termref ref="dt-QSD">QSD</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;, <termref ref="dt-QSC">QSC</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;, <termref ref="dt-IVL">IVL</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;, 
					<termref ref="dt-PIVL">PIVL</termref>&lt;<termref ref="dt-TS">TS</termref>&gt; and <termref ref="dt-EIVL">EIVL</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;.
					Ultimately the building blocks from which all <emph>QSET&lt;TS&gt;</emph> values are constructed
					are <termref ref="dt-IVL">IVL</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;, <termref ref="dt-QSC">QSC</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;, <termref ref="dt-PIVL">PIVL</termref>, and <termref ref="dt-EIVL">EIVL</termref>.
					Since <termref ref="dt-TS">TS</termref> can be promoted to <termref ref="dt-IVL">IVL</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;, it is 
					also possible to use <termref ref="dt-TS">TS</termref> directly when building a <emph>QSET&lt;TS&gt;</emph>.
				</p>
				<p>
				 	This example specifies every other Tuesday in the season from the (US holidays) Memorial Day to Labor Day in the 
				 	years 2002 and 2003. This set of times is built as an expression of the intersection between 3 sets:
				</p>
				<list role="unordered">
					<item>
						<p>Every other tuesday</p>
					</item>
					<item>
						<p>The years 2002 and 2003</p>
					</item>
					<item>
						<p>The season between Memorial Day and Labor Day</p>
					</item>
				</list>
				<exhibit role="example" verbatim="yes">
					<pre>
&lt;example xsi:type="QSI_TS"&gt; 
	&lt;!-- intersection, because it is a QSI --&gt;

	&lt;!-- every other Tuesday --&gt;
	&lt;term xsi:type='PIVL_TS' alignment='DW'&gt;
		&lt;phase lowClosed='true' highClosed='false'&gt;
			&lt;low value='20001202'/&gt;
			&lt;high value='20001203'/&gt;
		&lt;/phase&gt;
		&lt;period value='2' unit='wk'/&gt;
	&lt;/term&gt;

	&lt;!-- 2002 and 2003 --&gt;
	&lt;term xsi:type='IVL_TS' lowClosed='true' highClosed='false'&gt;
		&lt;low value='20020101'/&gt;
		&lt;high value='20040101'/&gt;
	&lt;/term&gt;					
	
	&lt;!-- season between Memorial Day and Labor Day --&gt;
	&lt;!-- periodic hull between Memorial day and Labor Day --&gt;
	&lt;term xsi:type='QSP_TS'&gt;
		&lt;first type="QSI_TS"&gt; 
		&lt;!-- memorial day: intersection of mondays and last week of May --&gt;
			&lt;term xsi:type='PIVL_TS'&gt;
				&lt;phase highClosed='false'&gt;
					&lt;low value='19870525'/&gt;
					&lt;high value='19870601'/&gt;
				&lt;/phase&gt;
				&lt;period value='1' unit='a'/&gt;
			&lt;/term&gt;
			&lt;term xsi:type='PIVL_TS'&gt;
				&lt;phase highClosed='false'&gt;
					&lt;low value='19870105'/&gt;
					&lt;high value='19870106'/&gt;
				&lt;/phase&gt;
				&lt;period value='1' unit='wk'/&gt;
			&lt;/term&gt;
		&lt;/first&gt;
		&lt;second type="QSI_TS"&gt;
		&lt;!-- labor day :  intersection of mondays and first week of Sept --&gt;
			&lt;term xsi:type='PIVL_TS'&gt;
				&lt;phase highClosed='false'&gt;
					&lt;low value='19870901'/&gt;
					&lt;high value='19870908'/&gt;
				&lt;/phase&gt;
				&lt;period value='1' unit='a'/&gt;
			&lt;/term&gt;
			&lt;term xsi:type='PIVL_TS'&gt;
				&lt;phase highClosed='false'&gt;
					&lt;low value='19870105'/&gt;
					&lt;high value='19870106'/&gt;
				&lt;/phase&gt;
				&lt;period value='1' unit='wk'/&gt;
			&lt;/term&gt;
		&lt;/second&gt;
	&lt;/term&gt;
&lt;/example&gt;</pre>
				</exhibit>
				<div3 id="prop-QSET_TS.literal">
					<head>Literal Form</head>
					<p>
						The <emph>QSET&lt;TS&gt;</emph> literal is a direct representation of the <termref ref="dt-QSET">QSET</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;
						expression tree used to build a <emph>QSET&lt;TS&gt;</emph>.<footnote>
							<p>
								Since GTS is only an alias for <termref ref="dt-QSET">QSET</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;, the
								literal specification defined here actually applies to any 
								<termref ref="dt-QSET">QSET</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;.
							</p>
						</footnote>
					</p>
					<p>
						Unions are specified by a semicolon-separated list. Intersections
						are specified by a whitespace separated list. Intersection has higher
						priority than union. Set difference can be specified
						using a backslash; differences have an intermediate priority,
						i.e. weaker than intersection but stronger than union. Periodic 
						Hulls are indicated by separating two sets with "..".
						The hull operator has the same priority as set difference.
						Parentheses can be used to overcome operator precedence when
						necessary.<footnote>
							<p>
								This literal specification again looks surprisingly simple, so one
								might assume it is incomplete. However, the <emph>QSET&lt;TS&gt;</emph>
								literal is based on the <termref ref="dt-TS">TS</termref>, <termref ref="dt-IVL">IVL</termref>,
								<termref ref="dt-PIVL">PIVL</termref>, and <termref ref="dt-EIVL">EIVL</termref> literals
								and also implies the
								literals for the extensions of <termref ref="dt-TS">TS</termref>, notably the
								<termref ref="dt-PPD_TS">PPD&lt;TS&gt;</termref>. <termref ref="dt-QSC">QSC</termref> is represented 
								directly by its GTSAbbreviation (<tabref ref="domain-GTSAbbreviation"/>) code.								
								The <emph>QSET&lt;TS&gt;</emph> literal 
								specification itself only needs to tie the other literal
								forms together, which is indeed a fairly simple task by itself.
							</p>
						</footnote>
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
GTS.literal ST.SIMPLE {
   GTS symbol : union                      { $.equal($1); }
              | exclusion                  { $.equal($1); };
   SET&lt;TS&gt; union
              : symbol ";" intersection    { $.equal($1.union($3)); }
              | intersection               { $.equal($1); };
   SET&lt;TS&gt; exclusion
              : symbol "\" intersection    { $.equal($1.except($3)); }
              | intersection               { $.equal($1); };
   SET&lt;TS&gt; intersection
              : hull intersection          { $.equal($1.intersection($2)); }
              | hull                       { $.equal($1); };
   SET&lt;TS&gt; hull
              : hull ".." factor           { $.equal($1.periodicHull($3)); }
              | factor                     { $.equal($1); };
   SET&lt;TS&gt; factor
              : IVL&lt;TS&gt;                    { $.equal($1); }
              | QSC&lt;TS&gt;                    { $.code.equal($1); }
              | PIVL&lt;TS&gt;                   { $.equal($1); }
              | EIVL&lt;TS&gt;                   { $.equal($1); }
              | "(" GTS ")"                { $.equal($1); };
};</pre>
					</exhibit>
					<p>
						The following table contains paradigmatic examples for complex
						<emph>QSET&lt;TS&gt;</emph> literals. For simpler examples refer to the literal
						forms of <termref ref="dt-IVL">IVL</termref>, <termref ref="dt-PIVL">PIVL</termref>,
						and <termref ref="dt-EIVL">EIVL</termref>.
					</p>
					<table id="examples-GTS.literal">
						<caption>
							Examples for Literal Expressions for Generic Timing
							Specifications
						</caption>
						<col width="1.68" span="1"/>
						<col width="4.07" span="1"/>
						<thead>
							<tr>
								<th rowspan="1" colspan="1">Literal Expression</th>
								<th rowspan="1" colspan="1">Meaning</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td rowspan="1" colspan="1">M09 D15 H16 N30 S34.12</td>
								<td rowspan="1" colspan="1">
									September 15 at 4:30:34.12 PM as the intersection of
									multiple periodic intervals of times (calendar patterns)
								</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">M0915163034.12</td>
								<td rowspan="1" colspan="1">
									September 15 at 4:30:34.12 PM as one simple periodic
									interval of time (calendar pattern)
								</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">M01; M03; M07</td>
								<td rowspan="1" colspan="1">
									January, March, and July (a union of three periodic 
									intervals of time)
								</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">M04..09 M/2</td>
								<td rowspan="1" colspan="1">
									Every second month from April to September (April, June, 
									August)
								</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">J1; J2; J4</td>
								<td rowspan="1" colspan="1">Monday, Tuesday, Thursday</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">W/2 J2</td>
								<td rowspan="1" colspan="1">
									every other Tuesday (intersection of every other week and 
									every Tuesday)
								</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">1999 WY15</td>
								<td rowspan="1" colspan="1">
									the 15th calendar week in 1999 (period code is optional 
									for the highest calendar unit)
								</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">WM2 J6</td>
								<td rowspan="1" colspan="1">Saturday of the 2nd week of the month</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">M05 WM2 J6</td>
								<td rowspan="1" colspan="1">Saturday of the 2nd week of May</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">M05 DM08..14 J7</td>
								<td rowspan="1" colspan="1">Mother's day (second Sunday in May).</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">J1..5 H0800..1600</td>
								<td rowspan="1" colspan="1">Monday to Friday from 8 AM to 4 PM</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">
									J1..4 H0800..1600;<br/>
									J5    H0800..1200
								</td>
								<td rowspan="1" colspan="1">Monday to Thursday 8 AM to 4 PM and Friday 8 AM to 12 noon.</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">[10 d] H/8</td>
								<td rowspan="1" colspan="1">Three times a day over 10 days (each time a 60 minutes interval).</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">H0800..1600 \J3</td>
								<td rowspan="1" colspan="1">Every day from 8 AM to 4 PM, except Wednesday.</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">(M0825..31 J1)..M0831</td>
								<td rowspan="1" colspan="1">The last calendar week of August.</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">JHNUSMEM..JHNUSLBR</td>
								<td rowspan="1" colspan="1">The season from the U.S. holidays Memorial Day to Labor Day (typical midwestern swimming pool season)</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">JHCHRXME H08..12</td>
								<td rowspan="1" colspan="1">To indicate that the office hours on Christmas Eve are from 8 AM to 1PM only</td>
							</tr>
						</tbody>
					</table>
				</div3>
			</div2>
			<div2 id="dt-GTS">
				<anchor id="GTS"/>
				<head>GeneralTimingSpecification (GTS) Alias For <termref ref="dtimpl-QSET">QSET</termref>&lt;<termref ref="dtimpl-TS">TS</termref>&gt;</head>
				<p>
					<emph role="strong">Definition:     </emph>
					An alias for <termref ref="dt-QSET">QSET</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;. 
				</p>
				<p>
					<emph>GTS</emph>  is an alias for <termref ref="dt-QSET">QSET</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;, and the 
					terms may be freely used interchangeably to refer to the type semantically. 
				</p>
				<note role="ITS">
					<p>
							Implementation Technology Specifications MAY not support aliasing the type
							if this is not easily supported in the typing system. In such cases, the specification
							MAY only define types for <termref ref="dt-QSET">QSET</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;, and 
							not support <emph>GTS</emph> as an alias.
						</p>
				</note>
			</div2>
		</div1>
		<div1 id="datyp2unctyp">
			<head>Uncertainties</head>
			<graphic source="graphics/dtUML-Uncertainties.png" alt="Uncertainty Data Types"/>
			<div2 id="dt-UVP">
				<anchor id="UVP"/>
				<head>UncertainValueProbabilistic (UVP) specializes T</head>
				<parameter name="T" type="ANY"/>
				<p>
					<emph role="strong">Definition:     </emph>
					A generic data type extension used to specify a quantified probability expressing
					the information producer's belief that the given value is correct.
				</p>
				<p>
					How the probability number is determined is outside the scope of this
					specification.
				</p>
				<p>
					Probabilities are subjective and (as any data value) must be
					interpreted in their individual context; for example, when new
					information is found, the probability might change. Thus, for any
					message, document, or other information representation, the
					information &#8212; and particularly the probabilities &#8212; reflect
					what the information producer believed was appropriate for the purpose
					and at the time the message or document was created.
				</p>
				<p>
					For example, at the beginning of the 2000 baseball season (May), the
					Las Vegas odds makers may have given the New York Yankees a
					probability of 1 in 10 (0.100) of winning the World Series. At the
					time of this writing, the Yankees and Mets have won their respective
					pennants, but the World Series has yet to begin. The probability of
					the Yankees winning the World Series is obviously significantly
					greater at this point in time, perhaps 6 in 10 (0.600). The context,
					and in particular the time of year, make a significant difference.
				</p>
				<p>
					Since probabilities are subjective measures of belief, they can be
					stated without being "correct" or "incorrect" per se, let alone
					"precise" or "imprecise." Notably, one does not have to conduct
					experiments to measure a frequency of some outcome in order to specify
					a probability. In fact, whenever statements about individual people or
					events are made, it is not possible to confirm such probabilities with
					"frequentist" experiments.
				</p>
				<p>
					Returning to our example, the Las Vegas odds makers can not insist on
					the Yankees and Mets playing 1000 trial games prior to the Series;
					and even if they could, they would not have the fervor of the real Series
					and therefore not be accurate. Instead, the odds makers must derive
					the probability from history and judgment.
				</p>
				<exhibit role="dtdl" id="dtdl-UVP">
					<anchor id="dtdl-UVP"/>
					<caption/>
					<pre>
template&lt;ANY T&gt;
type UncertainValueProbabilistic&lt;T&gt; alias UVP&lt;T&gt; specializes T {
   REAL  probability;
};</pre>
				</exhibit>
				<p>
					The type T is not formally constrained. In theory, discrete
					probabilities can only be stated for discrete data values. Thus,
					generally <emph>UVP</emph> SHOULD NOT be used with <termref ref="dt-REAL">REAL</termref>,
					<termref ref="dt-PQ">PQ</termref>, or <termref ref="dt-MO">MO</termref> values. 
				</p>
				<div3 id="prop-UVP.probability">
					<head>Probability (probability) : <termref ref="dt-REAL">REAL</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
							The probability assigned to the value, a decimal number between 0
							(impossible) and 1 (certain), inclusive.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(UVP&lt;T&gt; x)
      where x.nonNull.and(x.probability.nonNull) {
   ((IVL&lt;REAL&gt;)"[0;1]").contains(x.probability);
};</pre>
					</exhibit>
					<p>
							There is no "default probability" that one can assume when the
							probability is unstated. Therefore, it is impossible to make any
							semantic difference between an <emph>UVP</emph> without probability and
							a simple T. <emph>UVP</emph> does not mean "uncertain", and a simple T
							does not mean "certain". In fact, the probability of the <emph>UVP</emph>
							could be 0.999 or 1, which is quite certain, where a simple T value
							could be a very vague guess.
						</p>
				</div3>
			</div2>
			<div2 id="dt-NPPD">
				<anchor id="NPPD"/>
				<head>NonParametricProbabilityDistribution (NPPD) specializes <termref ref="dt-DSET">DSET</termref>&lt;<termref ref="dt-UVP">UVP</termref>&lt;T&gt;&gt;</head>
				<parameter name="T" type="ANY"/>
				<p>
					<emph role="strong">Definition:     </emph>
					A set of <termref ref="dt-UVP">UVP</termref> with explicit probabilities.
				</p>
				<p>
				   An <emph>NPPD</emph> is a histogram).  All the elements in the set are considered alternatives, and each is assigned a number expressing either the probability that its value is correct or the frequency with which it occurs in a sample.
				</p>
				<p>
					The purpose of <emph>NPPD</emph> is chiefly
					to support statistical data reporting as it occurs in measurements
					taken from many subjects and consolidated in a histogram. This occurs
					in epidemiology, veterinary medicine and laboratory medicine, but also in
					cost controlling and business process engineering.
				</p>
				<p>
					Semantically, the information of a stated value exists in contrast to
					the complement set of unstated possible values. Thus, semantically, an
					<emph>NPPD</emph> contains <emph>all</emph>
					possible values and assigns probabilities to each of them.
				</p>
				<p>
					The easiest way to visualize this is a bar chart as shown in this figure:
				</p>
				<graphic source="graphics/DT-NPPD-ex1.gif" alt="Example of a Histogram"/>
				<p>
					This example illustrates the probability of selected major league
					baseball teams winning the World Series (prior to the season
					start). Each team is mutually exclusive, and were we to include all of
					the teams, the sum of the probabilities would equal 1 (i.e., it is
					certain that one of the teams will win).
				</p>
				<note role="ITS">
					<p>
						Even though semantically <emph>NPPD</emph> assigns probabilities to all
						possible values, not all values need to be represented
						explicitly. Those possible values that are not mentioned
						will have the remaining probability distributed equally over
						all unmentioned values. For example, if the value set is {A; B; C; D}
						but the <emph>NPPD</emph> value states just {(B; 0.5); (C; 0.25)} then the
						remaining probability is 1 - 0.75 = 0.25, which is distributed evenly over
						the complement set: {(A; 0.125); (D; 0.125)}. Semantically, the <emph>NPPD</emph>
						is the union of the stated probability distribution and the unstated
						complement with the remaining probability distributed evenly.
					</p>
					<p>
						<emph>NPPD</emph> SHALL be used where only one value for T may be true. The sum of the probabilities assigned
						to the mentioned values should be &lt;= 1, but due to estimating and rounding inaccuracies, the total 
						MAY actually exceed 1.
					</p>
				</note>
				<exhibit role="dtdl" id="dtdl-NPPD">
					<anchor id="dtdl-NPPD"/>
					<caption/>
					<pre>
template&lt;ANY T&gt;
type NonParametricProbabilityDistribution&lt;T&gt; alias NPPD&lt;T&gt;
      specializes DSET&lt;UVP&lt;T&gt;&gt; {
   UVP&lt;T&gt; mostLikely(INT n);
};</pre>
				</exhibit>
				<p>
					Just as with <termref ref="dt-UVP">UVP</termref>, the type T is not formally
					constrained, even though there are reasonable and unreasonable
					uses. Typically one would use <emph>NPPD</emph> for unordered types, if
					only a "small" set of possible values is assigned explicit
					probabilities, or if the probability distribution cannot (or should
					not) be approximated with parametric methods. For other cases, one may
					prefer <termref ref="dt-PPD">PPD</termref>.
				</p>
				<div3 id="prop-NPPD-mostLikely">
					<head>Most Likely (mostLikely) : <termref ref="dt-UVP">UVP</termref>&lt;T&gt;</head>
					<argument name="n" type="INT"/>
					<p>
						<emph role="strong">Definition:     </emph>
					  The value identified as the most likely in the <emph>NPPD</emph>. If 
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(NPPD&lt;T&gt; x)
      where x.nonNull {
   x.notEmpty;
   x.contains(x.mostLikely(n));
   forall(UVP&lt;T&gt; d, e; DSET&lt;UVP&lt;T&gt;&gt; m; INT n)
         where x.contains(d).and(m.equal(x.mostLikely(n)))
                .and(m.contains(e)) {
      e.greaterOrEqual(d).or(m.contains(d));
      };
};</pre>
					</exhibit>
					<p>
						Note that a non-null <emph>NPPD</emph> must have at least one member.
					</p>
				</div3>
				<div3 id="prop-NPPD.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<argument name="x" type="BL"/>
					<p>
						The evaluation of equality for <emph>NPPD</emph> is the same as the <termref ref="dt-DSET">DSET</termref> data type.<footnote>
							<p>
								This means that values of the type NPPD and DSET may be equal.
							</p>
						</footnote>
					</p>
				</div3>
			</div2>
			<div2 id="dt-URG">
				<anchor id="URG"/>
				<head>UncertainRange (URG) specializes T</head>
				<parameter name="T" type="QTY"/>
				<p>
					<emph role="strong">Definition:     </emph>
					Indicates that the value comes from a range of possible values of an ordered base data type.
				</p>
				<p>
					<emph>URG</emph> is used where the actual value is unknown, but it is known that the 
					value comes from a known range of possible values (e.g. "Take 2-4 tablets").
					For situations where all values apply simultaneously (e.g. The encounter lasted 
					from January 6th through January 12th) the <termref ref="dt-URG"/> type should be used.
				</p>
				<p>
					<emph>URG</emph> differs from <termref ref="dt-PPD">PPD</termref> in that <termref ref="dt-PPD">PPD</termref> is used to report a 
					particular value along with an associated distribution of uncertainty for the 
					value, or to report the summary distribution of a set of data, whereas <emph>URG</emph> indicates
					that there is a single value that, although unknown, must come from a particular range
					of values. No inference regarding distribution of values can be taken. <emph>URG</emph> 
					is often associated with an instruction to perform a particular operation at 
					some point within a given time interval.  
				</p>
				<exhibit role="dtdl" id="dtdl-URG">
					<anchor id="dtdl-URG"/>
					<caption/>
					<pre>
template&lt;QTY T&gt;
type UncertainRange&lt;T&gt; alias URG&lt;T&gt; specializes T {
   IVL&lt;T&gt;   range;
   BL       couldBe(T value);
};</pre>
				</exhibit>
				<p>
					Any ordered type can be the basis of an <emph>URG</emph>; it does not matter
					whether the base type is discrete or continuous. If the base data type
					is only partially ordered, all possible values for the <emph>URG</emph> SHALL be
					elements of a totally ordered subset of the partially ordered data
					type.
				</p>
				<p>
					For example, <termref ref="dt-PQ">PQ</termref> is considered ordered. However the
					ordering of <termref ref="dt-PQ">PQ</termref>s is only partial; a total order is only
					defined among comparable quantities (quantities of the same physical
					dimension).  While <emph>URG</emph>s between 2 and 4 meter exists, there is no
					<emph>URG</emph> between 2 meters and 4 seconds.
				</p>
				<!-- TODO: 
  this was true but too unpalatable to even the insider users that 
  it was taken out. But this means that some of the predicates are 
  broken, particularly around equality. Need to sort this out.
   
                                <constraint>
				<p>
					Implicit in the use of <dtname/> is a statement that the actual value is
					unknown.
				</p>
				<dtdl for="dt-URG" xml:space="preserve">
invariant(URG&lt;T&gt; x) {
  x.unknown;
};
</dtdl></constraint>
				<note>
					<p>
						Since the nullFlavor of a <dtname/>&lt;T&gt; is fixed to "UNK", 
						ITSs MAY choose not to represent the nullFlavor in the instance.
					</p>
				</note>
-->
				<div3 id="prop-URG.range">
					<head>Range (range) : <termref ref="dt-IVL">IVL</termref>&lt;T&gt;</head>
					<p>
						<emph role="strong">Definition:     </emph>
							The range of possible values.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(URG&lt;T&gt; x) 
      where x.range.nonNull {
   x.range.any.isNull;
   x.range.center.nonNull;
};</pre>
					</exhibit>
					<p>
							When a range is specified, it SHALL be anchored to known values, not just a width,
							and the property <termref ref="prop-IVL.any">IVL.any</termref> SHALL be null.
						</p>
				</div3>
				<div3 id="prop-URG.couldBe">
					<head>Could Be (couldBe) : <termref ref="dt-BL">BL</termref>
					</head>
					<argument name="value" type="T"/>
					<p>
						<emph role="strong">Definition:     </emph>
							Whether a given value can be in the specified range.
						</p>
					<p>
							Although the actual value is unknown, it is possible to determine whether
							a <emph>URG</emph> could be a particular value. A particular value is possible if
							it is contained within the specified range.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(URG&lt;T&gt; x, T t) 
    where x.range.nonNull {
  x.couldBe(t).equals(x.range.contains(t));
};</pre>
					</exhibit>
				</div3>
				<div3 id="prop-URG.equal">
					<head>Equality (equal) : <termref ref="dt-BL">BL</termref>, inherited from <termref ref="dt-ANY">ANY</termref>
					</head>
					<argument name="x" type="T"/>
					<p>
						The criteria for equality of <emph>URG</emph> are taken from the range.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(URG&lt;T&gt; x, y) 
    where x.nonNull.and(y.nonNull) {
  x.equal(y).equal(x.range.equal(y));
};</pre>
					</exhibit>
				</div3>
			</div2>
		</div1>
		<div1 id="datyp2flavors">
			<head>Data Type Flavors</head>
			<div2 id="flavorDetails">
				<head>Flavor Concepts</head>
				<p>
				  Data type flavors are named constraints on the existing data types.
				  The flavors SHALL NOT introduce any new semantics to the data type, but 
				  constrain an existing data type for a particular purpose. Flavors
				  SHALL NOT add new properties, or set default values for properties;
				  the value of properties can be fixed, but not defaulted.
				</p>
				<p>
				  Flavors MAY be used as types in other models within the realm scope of the 
				  definition of the flavors. For instance in the RIM, and in RIM-derived models, 
				  attributes may be assigned a type that is a flavor.
                  However flavors are not true types; when used in this fashion, they designate that
                  the type of the attribute is the type from which the flavor is derived, with the 
                  constraints indicated in the flavor definition applied. For an instance of the 
                  data value assigned to the attribute, the type property is always that of the 
                  underlying type. It follows that a value may be constrained by multiple flavors at once, where 
                  each flavor makes different rules about how the type is used; this is not an assertion
                  that the value conforms to multiple different types of behaviors.   
                </p>
				<p>
				Flavors MAY constrain other flavors. When a flavor constrains another flavor, the 
				flavor adds new constraints to those already specified in the other flavor. 
			</p>
				<p>
                  Flavors are limited in this fashion so that a single implementation based on 
                  this specification will always be able to process all instances, but local 
                  implementations may describe a number of different constraint patterns on the 
                  data types defined in this specification.
			</p>
				<p>	
				The flavors defined in here are universal scope, and MAY be used in any HL7 
				models, including the RIM.
			</p>
				<p>
					<specref ref="RepresentationalProperties"/> documents the property flavorId. When
				this representational property is used in association with one of the flavors 
				documented here, it MAY contain the value of the flavor name. 
			</p>
			</div2>
			<div2>
				<head>Flavors of BL</head>
				<div3 id="dt-BN">
					<anchor id="BN"/>
					<head>BooleanNonNull (BN)</head>
					<p>
						<emph role="strong">Definition:     </emph>
						<emph>BN</emph> constrains the <termref ref="dt-BL">BL</termref> so that it is not null.
						This is defined for use within the data types specification where it is not
						appropriate for a null value to be used.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
flavor BooleanNonNull alias BN constrains BL;
</pre>
					</exhibit>
					<p>
						Values conforming to the BN flavor SHALL NOT have null values.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (BN x) {
   x.isNull.not;
};</pre>
					</exhibit>
					<prop id="prop-BN.isNull" base="prop-ANY.isNull" fixed="true" fixedValue="false" render="false"/>
					<prop id="prop-BN.nonNull" base="prop-ANY.nonNull" fixed="true" fixedValue="true" render="false"/>
					<prop id="prop-BN.other" base="prop-ANY.other" fixed="true" fixedValue="false" render="false"/>
					<prop id="prop-BN.notApplicable" base="prop-ANY.notApplicable" fixed="true" fixedValue="false" render="false"/>
					<prop id="prop-BN.unknown" base="prop-ANY.unknown" fixed="true" fixedValue="false" render="false"/>
					<prop id="prop-BN.nullFlavor" base="prop-ANY.nullFlavor" role="exclude" fixedValue="NullFlavor.NA" render="false"/>
				</div3>
			</div2>
			<div2>
				<head>Flavors of ED</head>
				<div3 id="dt-ED.TEXT">
					<anchor id="ED.TEXT"/>
					<head>TextWithReference (ED.TEXT)</head>
					<p>
						<emph role="strong">Definition:     </emph>
						<emph>ED.TEXT</emph> constrains <termref ref="dt-ED">ED</termref> so that it  
						only contains plain text. 
					</p>
					<p>
						This is useful because there is sometimes
						a need to allow for references, but the content must be a simple
						string. In addition, no translations are allowed.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
flavor TextWithReference alias ED.TEXT constrains ED;
</pre>
					</exhibit>
					<p>
						The mediaType of the ED content SHALL be plain text, like the type <termref ref="dt-ST">ST</termref>
						but a reference is allowed.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (ED.TEXT x) where x.nonNull {
  x.mediaType.equal("text/plain");
  x.integrityCheck.isNull;
  x.thumbnail.isNull;
  x.compression.isNull;
  x.translation.isEmpty;
};</pre>
					</exhibit>
					<p>
						The mediaType of the ED content SHALL be plain text, like the type <termref ref="dt-ST">ST</termref>
						but a reference is allowed.
					</p>
					<prop id="prop-ED.TEXT.mediaType" base="prop-ED.mediaType" render="false" fixed="true" fixedValue="text/plain"/>
					<prop id="prop-ED.TEXT.compression" base="prop-ED.compression" render="false" role="exclude"/>
					<prop id="prop-ED.TEXT.integrityCheck" base="prop-ED.integrityCheck" render="false" role="exclude"/>
					<prop id="prop-ED.TEXT.integrityCheckAlgorithm" base="prop-ED.integrityCheckAlgorithm" render="false" role="exclude"/>
					<prop id="prop-ED.TEXT.thumbnail" base="prop-ED.thumbnail" render="false" role="exclude"/>
					<prop id="prop-ED.TEXT.translation" base="prop-ED.translation" render="false" role="exclude"/>
				</div3>
				<!-- 
				<dt id="dt-ED.DOC" longname="Document" shortname="ED.DOC" constrains="dt-ED" flavor="true" access="public">
					<definition>
						<dtname/> constrains <dtref ref="dt-ED"/> so that the contents are a document
						or a reference to one. 
					</definition>
					<dtdl for="dt-ED.DOC" xml:space="preserve">
flavor Document alias ED.DOC constrains ED;
</dtdl>
					<p>
						The "mediaType" value SHALL be one of "text/plain", "text/html",
						"text/xhtml", "multipart/x-hl7-cda-level1" or "application/pdf". 
					</p>
					<constraint>
                                        <dtdl xml:space="preserve">
invariant (ED.DOC x) where x.nonNull {
  x.mediaType.equal("text/plain").or(
   x.mediaType.equal("text/html").or(
    x.mediaType.equal("text/xhtml").or(
     x.mediaType.equal("multipart/x-hl7-cda-level1").or(
      x.mediaType.equal("application/pdf")))));
};</dtdl></constraint>					
					<prop id="prop-ED.DOC.mediaType" base="prop-ED.mediaType" render="false" valueSet="UV.DT.ED.DOC.MediaType"/> 
				</dt>
				<dt id="dt-ED.DOC.INLINE" longname="DocumentInline" shortname="ED.DOC.INLINE" constrains="dt-ED.DOC" flavor="true" access="public">
					<definition>
						<dtname/> constrains <dtref ref="dt-ED.DOC"/> so that the document is not
						provided by means of a reference.
					</definition>
					<dtdl for="dt-ED.DOC.INLINE" xml:space="preserve">
flavor DocumentInline alias ED.DOC.INLINE constrains ED.DOC;
</dtdl>					
					<p>
						The reference SHALL be null.
					</p>
					<constraint>
                                        <dtdl xml:space="preserve">
invariant (ED.DOC.INLINE x) where x.nonNull {
  x.reference.isNull;
};</dtdl></constraint>					
					<prop id="prop-ED.DOC.INLINE.reference" base="prop-ED.reference" render="false" role="exclude"/>
				</dt>
				<dt id="dt-ED.DOC.REF" longname="DocumentReference" shortname="ED.DOC.REF" constrains="dt-ED.DOC" flavor="true" access="public">
					<definition>
						<dtname/> constrains <dtref ref="dt-ED.DOC"/> so that the document is  
						provided by means of a reference.
					</definition>
					<dtdl for="dt-ED.DOC.REF" xml:space="preserve">
flavor DocumentReference alias ED.DOC.REF constrains ED.DOC;
</dtdl>
					<p>
						If the <dtref ref="ED"/> is not null, then the reference property
						SHALL NOT be null.
					</p>
					<constraint>
                                        <dtdl xml:space="preserve">
invariant (ED.DOC.REF x) where x.nonNull {
  x.reference.nonNull;
};</dtdl></constraint>					
				<prop id="prop-ED.DOC.REF.reference" base="prop-ED.reference" render="false" mandatory="true"/>
				</dt>
-->
				<div3 id="dt-ED.SIGNATURE">
					<anchor id="ED.SIGNATURE"/>
					<head>DigitalSignature (ED.SIGNATURE)</head>
					<p>
						<emph role="strong">Definition:     </emph>
						<emph>ED.SIGNATURE</emph> constrains <termref ref="dt-ED">ED</termref> so that the contents are an 
						XML digital Signature according the W3C Signature specifications. 
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
flavor DigitalSignature alias ED.SIGNATURE constrains ED;
</pre>
					</exhibit>
					<p>
						Reference, integrityCheck, thumbnail, compression, and language SHALL be null.
						ED.mediaType SHALL be "text/xml". Translations SHALL be not applicable.
						The content SHALL conform to the w3c XML digital signature specification
						 ([<loc href="http://www.w3.org/Signature/" xlink-form="simple" show="embed" actuate="auto"/>]).
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (ED.SIGNATURE x) where x.nonNull {
  x.reference.isNull;
  x.integrityCheck.isNull;
  x.thumbnail.isNull;
  x.description.isNull;
  x.compression.isNull;
  x.language.isNull;
  x.mediaType.equal("text/xml");
  x.translation.isEmpty;
};</pre>
					</exhibit>
					<prop id="prop-ED.SIGNATURE.mediaType" base="prop-ED.mediaType" render="false" fixed="true" fixedValue="text/xml"/>
					<prop id="prop-ED.SIGNATURE.language" base="prop-ED.language" render="false" role="exclude"/>
					<prop id="prop-ED.SIGNATURE.compression" base="prop-ED.compression" render="false" role="exclude"/>
					<prop id="prop-ED.SIGNATURE.reference" base="prop-ED.reference" render="false" role="exclude"/>
					<prop id="prop-ED.SIGNATURE.integrityCheck" base="prop-ED.integrityCheck" render="false" role="exclude"/>
					<prop id="prop-ED.SIGNATURE.integrityCheckAlgorithm" base="prop-ED.integrityCheckAlgorithm" render="false" role="exclude"/>
					<prop id="prop-ED.SIGNATURE.description" base="prop-ED.description" render="false" role="exclude"/>
					<prop id="prop-ED.SIGNATURE.thumbnail" base="prop-ED.thumbnail" render="false" role="exclude"/>
					<prop id="prop-ED.SIGNATURE.translation" base="prop-ED.translation" render="false" role="exclude"/>
				</div3>
				<div3 id="dt-ED.IMAGE">
					<anchor id="ED.IMAGE"/>
					<head>Image (ED.IMAGE)</head>
					<p>
						<emph role="strong">Definition:     </emph>
						<emph>ED.IMAGE</emph> constrains <termref ref="dt-ED">ED</termref> so that the contents are an 
						image. 
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
flavor Image alias ED.IMAGE constrains ED;
</pre>
					</exhibit>
					<p>
						The mediaType SHALL start with "image/".
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (ED.IMAGE x) where x.nonNull {
  x.mediaType.code.subList(0,6).equal("image/");
};</pre>
					</exhibit>
					<prop id="prop-ED.IMAGE.data" base="prop-ED.data" render="false" valueSet="UV.DT.ED.IMAGE.MediaType"/>
				</div3>
				<div3 id="dt-ED.STRUCTURED_TEXT">
					<anchor id="ED.STRUCTURED_TEXT"/>
					<head>StructuredText (ED.STRUCTURED_TEXT)</head>
					<p>
						<emph role="strong">Definition:     </emph>
						<emph>ED.STRUCTURED_TEXT</emph> constrains <termref ref="dt-ED">ED</termref> so that the contents are structured
						text. 
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
flavor StructuredText alias ED.STRUCTURED_TEXT constrains ED;
</pre>
					</exhibit>
					<p>
						The mediaType SHALL be "text/x-hl7-text+xml". The contents of the ED SHALL be a valid
						structured text as described by CDA and SPL. No translations are allowed.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (ED.STRUCTURED_TEXT x) where x.nonNull {
  x.mediaType.equal("text/x-hl7-text+xml");
  x.translation.isEmpty;
  x.description.notApplicable;
  x.thumbnail.notApplicable;
  x.compression.notApplicable;
  x.reference.notApplicable;
  x.integrityCheck.notApplicable;
};</pre>
					</exhibit>
					<prop id="prop-ED.STRUCTURED_TEXT.mediaType" base="prop-ED.mediaType" render="false" fixed="true" fixedValue="text/x-hl7-text+xml"/>
					<prop id="prop-ED.STRUCTURED_TEXT.description" base="prop-ED.description" render="false" role="exclude"/>
					<prop id="prop-ED.STRUCTURED_TEXT.thumbnail" base="prop-ED.thumbnail" render="false" role="exclude"/>
					<prop id="prop-ED.STRUCTURED_TEXT.translation" base="prop-ED.translation" render="false" role="exclude"/>
					<prop id="prop-ED.STRUCTURED_TEXT.compression" base="prop-ED.compression" render="false" role="exclude"/>
					<prop id="prop-ED.STRUCTURED_TEXT.reference" base="prop-ED.reference" render="false" role="exclude"/>
					<prop id="prop-ED.STRUCTURED_TEXT.integrityCheck" base="prop-ED.integrityCheck" render="false" role="exclude"/>
				</div3>
				<div3 id="dt-ED.STRUCTURED_TITLE">
					<anchor id="ED.STRUCTURED_TITLE"/>
					<head>StructuredTitle (ED.STRUCTURED_TITLE)</head>
					<p>
						<emph role="strong">Definition:     </emph>
						<emph>ED.STRUCTURED_TITLE</emph> constrains <termref ref="dt-ED">ED</termref> so that the contents are a structured title. 
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
flavor StructuredTitle alias ED.STRUCTURED_TITLE constrains ED;
</pre>
					</exhibit>
					<p>
						The mediaType SHALL be "text/x-hl7-title+xml". The contents of the ED SHALL be a valid
						title as described by CDA and SPL. No translations are allowed.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (ED.STRUCTURED_TITLE x) where x.nonNull {
  x.mediaType.equal("text/x-hl7-title+xml");
  x.translation.isEmpty;
  x.description.notApplicable;
  x.thumbnail.notApplicable;
  x.compression.notApplicable;
  x.reference.notApplicable;
  x.integrityCheck.notApplicable;
};</pre>
					</exhibit>
					<prop id="prop-ED.STRUCTURED_TITLE.mediaType" base="prop-ED.mediaType" render="false" fixed="true" fixedValue="text/x-hl7-title+xml"/>
					<prop id="prop-ED.STRUCTURED_TITLE.description" base="prop-ED.description" render="false" role="exclude"/>
					<prop id="prop-ED.STRUCTURED_TITLE.thumbnail" base="prop-ED.thumbnail" render="false" role="exclude"/>
					<prop id="prop-ED.STRUCTURED_TITLE.translation" base="prop-ED.translation" render="false" role="exclude"/>
					<prop id="prop-ED.STRUCTURED_TITLE.compression" base="prop-ED.compression" render="false" role="exclude"/>
					<prop id="prop-ED.STRUCTURED_TITLE.reference" base="prop-ED.reference" render="false" role="exclude"/>
					<prop id="prop-ED.STRUCTURED_TITLE.integrityCheck" base="prop-ED.integrityCheck" render="false" role="exclude"/>
				</div3>
			</div2>
			<div2>
				<head>Flavors of ST</head>
				<div3 id="dt-ST.NT">
					<anchor id="ST.NT"/>
					<head>StringNoTranslations (ST.NT)</head>
					<p>
						<emph role="strong">Definition:     </emph>
						<emph>ST.NT</emph> constrains <termref ref="dt-ST">ST</termref> so that it there are no translations.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
flavor StringNoTranslations alias ST.NT constrains ST;
</pre>
					</exhibit>
					<p>
						Translations SHALL be empty.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (ST.NT x) where x.nonNull {
  x.translation.isEmpty;
};</pre>
					</exhibit>
					<prop id="prop-ST.NT.translation" base="prop-ED.translation" render="false" role="exclude"/>
				</div3>
				<div3 id="dt-ST.SIMPLE">
					<anchor id="ST.SIMPLE"/>
					<head>StringSimple (ST.SIMPLE)</head>
					<p>
						<emph role="strong">Definition:     </emph>
						<emph>ST.SIMPLE</emph> constrains <termref ref="dt-ST.NT">ST.NT</termref> so that it does not specify a language.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
flavor StringSimple alias ST.SIMPLE constrains ST.NT;
</pre>
					</exhibit>
					<p>
						language SHALL be not applicable. 
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (ST.SIMPLE x) where x.nonNull {
  x.language.notApplicable;
};</pre>
					</exhibit>
					<p>
						The concept of language does not apply to these strings - they are always to be understood as a sequence of 
						characters that identify a concept in some language independent fashion.
					</p>
					<note role="ITS">
						<p>
							This type corresponds to a simple string in most implementation technologies (i.e. xs:string in W3C Schema).
						</p>
					</note>
					<prop id="prop-ST.SIMPLE.language" base="prop-ED.language" render="false" role="exclude"/>
				</div3>
			</div2>
			<div2>
				<head>Flavors of SC</head>
				<div3 id="dt-SC.NT">
					<anchor id="SC.NT"/>
					<head>CodedStringNoTranslations (SC.NT)</head>
					<p>
						<emph role="strong">Definition:     </emph>
						<emph>SC.NT</emph> constrains <termref ref="dt-SC">SC</termref> so that it has no translations.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
flavor CodedStringNoTranslations alias SC.NT constrains SC;
</pre>
					</exhibit>
					<p>
						Translations SHALL be empty.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (SC.NT x) where x.nonNull {
  x.translation.isEmpty;
};</pre>
					</exhibit>
				</div3>
				<prop id="prop-SC.NT.translation" base="prop-ED.translation" render="false" role="exclude"/>
			</div2>
			<div2>
				<head>Flavors of CD</head>
				<div3 id="dt-CV">
					<anchor id="CV"/>
					<head>CodedValue (CV)</head>
					<p>
						<emph role="strong">Definition:     </emph>
						<emph>CV</emph> constrains <termref ref="dt-CD">CD</termref> so that there is no translations,
						and only a single concept is allowed.
					</p>
					<p>
						<emph>CV</emph> is used when any reasonable use case will require only a
						single code value. Thus, it should not be used in circumstances where
						multiple alternative codes for a given value are desired. Note that this 
						prevents graceful migration from one code system to another, so <emph>CV</emph> is not usually
						used outside the data types specification.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
flavor CodedValue alias CV constrains CD;
</pre>
					</exhibit>
					<p>
						There SHALL be no translations, and there SHALL be no source.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (CV x) where x.nonNull {
  x.translation.isEmpty;
  x.source.isNull;
};</pre>
					</exhibit>
					<prop id="prop-CV.translation" base="prop-CD.translation" render="false" role="exclude"/>
					<prop id="prop-CV.source" base="prop-CD.source" render="false" role="exclude"/>
				</div3>
			</div2>
			<div2>
				<head>Flavors of TEL</head>
				<div3 id="dt-TEL.URL">
					<anchor id="TEL.URL"/>
					<head>LocatableResource (TEL.URL)</head>
					<p>
						<emph role="strong">Definition:     </emph>
						<emph>TEL.URL</emph> constrains <termref ref="dt-TEL">TEL</termref>  so that it points to a locatable resource that returns binary content.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
flavor LocatableResource alias TEL.URL constrains TEL;
</pre>
					</exhibit>
					<p>
						The URL scheme SHALL be "file", "ftp", "cid", "http", "https" or "nfs". Use "cid" is for soap attachments.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (TEL.URL x) where x.nonNull {
 x.use.isEmpty.and(
  x.scheme.equal("file").or(
   x.scheme.equal("ftp").or(
    x.scheme.equal("http").or(
     x.scheme.equal("https").or(
      x.scheme.equal("cid").or(
       x.scheme.equal("nfs")))))));
};</pre>
					</exhibit>
					<prop id="prop-TEL.URL.use" base="prop-TEL.use" render="false" role="exclude"/>
					<prop id="prop-TEL.URL.scheme" base="prop-URL.scheme" render="false" valueSet="UV.DT.TEL.URL.Scheme"/>
				</div3>
				<!-- 				<dt id="dt-TEL.PERSON" longname="PersonalContact" shortname="TEL.PERSON" constrains="dt-TEL" flavor="true" access="public">
					<definition>
						<dtname/> constrains <dtref ref="dt-TEL"/>  so that it refers to a method of communication with a person.
					</definition>
					<dtdl for="dt-TEL.PERSON" xml:space="preserve">
flavor PersonalContact alias TEL.PERSON constrains TEL;
</dtdl>					
					<p>
						The URL schema SHALL be either tel or mailto.
					</p>
					<constraint>
                                        <dtdl xml:space="preserve">
invariant (TEL.PERSON x) where x.nonNull {
  x.scheme.equal("tel").or(x.scheme.equal("mailto"));
};</dtdl></constraint>					
					<prop id="prop-TEL.PERSON.scheme" base="prop-URL.scheme" render="false" valueSet="UV.DT.TEL.PERSON.Scheme"/>
				</dt>
-->
				<div3 id="dt-TEL.PHONE">
					<anchor id="TEL.PHONE"/>
					<head>TelephoneAddress (TEL.PHONE)</head>
					<p>
						<emph role="strong">Definition:     </emph>
						<emph>TEL.PHONE</emph> constrains <termref ref="dt-TEL.PERSON">TEL.PERSON</termref>  so it refers to some telephone based
						communication system with a person or organisation.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
flavor TelephoneAddress alias TEL.PHONE constrains TEL.PERSON;
</pre>
					</exhibit>
					<p>
						The URL scheme SHALL be "tel".
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (TEL.PHONE x) where x.nonNull {
  x.scheme.equal("tel");
};</pre>
					</exhibit>
					<prop id="prop-TEL.PHONE.scheme" base="prop-URL.scheme" render="false" valueSet="UV.DT.TEL.PHONE.Scheme"/>
				</div3>
				<div3 id="dt-TEL.EMAIL">
					<anchor id="TEL.EMAIL"/>
					<head>EmailAddress (TEL.EMAIL)</head>
					<p>
						<emph role="strong">Definition:     </emph>
						<emph>TEL.EMAIL</emph> constrains the <termref ref="dt-TEL.PERSON">TEL.PERSON</termref>  type so that it is an SMTP email address.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
flavor EmailAddress alias TEL.EMAIL constrains TEL.PERSON;
</pre>
					</exhibit>
					<p>
						The URL scheme SHALL be "mailto:".
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (TEL.EMAIL x) where x.nonNull {
  x.scheme.equal("mailto");
};</pre>
					</exhibit>
					<prop id="prop-TEL.EMAIL.scheme" base="prop-URL.scheme" render="false" role="fixedValue" fixedValue="mailto"/>
				</div3>
			</div2>
			<div2>
				<head>Flavors of EN</head>
				<div3 id="dt-PN">
					<anchor id="PN"/>
					<head>PersonName (PN)</head>
					<binds type="LIST&lt;PNXP&gt;"/>
					<p>
						<emph role="strong">Definition:     </emph>
						<emph>PN</emph> constrains <termref ref="dt-EN">EN</termref> for use when the named Entity
						is a Person. 
					</p>
					<p>
						It constrains <termref ref="dt-ENXP">ENXP</termref> used in the parts 
						so that only those entity name parts qualifiers applicable to person names
						are allowed. Since the structure of entity name is mostly determined by the
						requirements of person name, the restriction is very minor.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
flavor PersonName alias PN constrains EN;
</pre>
					</exhibit>
					<p>
						The qualifier on any part SHALL NOT include the code "LS".
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (PN x) where x.nonNull {
   forall(ENXP part)
         where x.contains(part) {
      part.qualifier.contains(EntityPartNameQualifier.LS).not;
      }
};</pre>
					</exhibit>
				</div3>
				<div3 id="dt-ON">
					<anchor id="ON"/>
					<head>OrganizationName (ON)</head>
					<binds type="LIST&lt;ONXP&gt;"/>
					<p>
						<emph role="strong">Definition:     </emph>
						<emph>ON</emph> constrains <termref ref="dt-EN">EN</termref> for use when the named Entity
						is an Organization. 
					</p>
					<p>
						It constrains <termref ref="dt-ENXP">ENXP</termref> used in the parts 
						so that only those entity name part types and qualifiers applicable to organization names
						are allowed. 
						Organization names, such as "Health Level Seven, Inc." mostly consist only
						of untyped name parts, prefixes, suffixes, and delimiters.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
flavor OrganizationName alias ON constrains EN;
</pre>
					</exhibit>
					<p>
						The family and given name part types SHALL not be used in the name of an organisation.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (ON x) where x.nonNull {
  forall(ENXP part)
         where x.contains(part) {
      part.type.implies(EntityNamePartType.FAM).not;
      part.type.implies(EntityNamePartType.GIV).not;
      }
};</pre>
					</exhibit>
					<p>
						The following qualifiers SHALL not be used in the parts of the name of an organisation: BR, AD, SP, MID, AC, PR, NB, HON. 
						The following codes SHALL not be used in the organisation name use: I, P, R, DN, M.
					</p>
					<div4 id="ON-examples">
						<head>Examples</head>
						<p>
							The following is the organization name, "Health Level Seven, Inc." in
							a simple string form:
						</p>
						<exhibit role="example" verbatim="yes">
							<pre>&lt;name&gt;Health Level Seven, Inc.&lt;/name&gt;</pre>
						</exhibit>
						<p>
							And with the legal status "Inc." as a distinguished name part:
						</p>
						<exhibit role="example" verbatim="yes">
							<pre>&lt;name&gt;Health Level Seven, &lt;suffix qualifier="LS"&gt;Inc.&lt;/suffix&gt;&lt;/name&gt;</pre>
						</exhibit>
					</div4>
				</div3>
				<div3 id="dt-TN">
					<anchor id="TN"/>
					<head>TrivialName (TN)</head>
					<binds type="LIST&lt;TNXP&gt;"/>
					<p>
						<emph role="strong">Definition:     </emph>
						<emph>TN</emph> constrains <termref ref="dt-EN">EN</termref>  so that it is effectively a simple string, suitable
						for use as a simple name for things and places.
					</p>
					<p>
						<emph>TN</emph> with its
						single name part is therefore equivalent to a simple character
						string.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
flavor TrivialName alias TN constrains EN;
</pre>
					</exhibit>
					<p>
						There SHALL only be one part type, its type SHALL be unknown, and it SHALL have 
						no qualifiers. As a consequence of this, the formatted rendition of then name
						is exactly equal to the one part of the name itself.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (TN x) where x.nonNull {
   x.head.nonNull;
   x.head.partType.isNull;
   x.tail.isEmpty;
   x.formatted.equal(x.head);
};</pre>
					</exhibit>
					<p>
						Trivial names are typically used for places and things, such as
						<emph>Lake Erie</emph> or <emph>Washington-Reagan National Airport</emph>:
					</p>
					<exhibit role="example" verbatim="yes">
						<pre>
&lt;name&gt;Lake Erie&lt;/name&gt;
&lt;name&gt;Washington-Reagan National Airport&lt;/name&gt;</pre>
					</exhibit>
					<prop id="prop-TN.length" base="prop-LIST.length" role="fixedValue" fixedValue="1" render="false"/>
				</div3>
			</div2>
			<div2>
				<head>Flavors of INT</head>
				<div3 id="dt-INT.NONNEG">
					<anchor id="INT.NONNEG"/>
					<head>IntegerNonNegative (INT.NONNEG)</head>
					<p>
						<emph role="strong">Definition:     </emph>
						<emph>INT.NONNEG</emph> constrains <termref ref="dt-INT">INT</termref>  so that it has a value of 0 or greater.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
flavor IntegerNonNegative alias INT.NONNEG constrains INT;
</pre>
					</exhibit>
					<p>
						The value of the INT SHALL be equal or greater than 0 if it is not null.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (INT.NONNEG x) where x.nonNull {
  x.greaterOrEqual(0);
  x.nullFlavor.implies(NullFlavor.NINF).not;
  x.isNegative.not;
};</pre>
					</exhibit>
					<prop id="prop-INT.NONNEG.isNegative" base="prop-INT.isNegative" render="false" role="fixedValue" fixedValue="false"/>
				</div3>
				<div3 id="dt-INT.POS">
					<anchor id="INT.POS"/>
					<head>IntegerPositive (INT.POS)</head>
					<p>
						<emph role="strong">Definition:     </emph>
						<emph>INT.POS</emph> constrains <termref ref="dt-INT.NONNEG">INT.NONNEG</termref>  so that it has a value greater than 0.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
flavor IntegerPositive alias INT.POS constrains INT.NONNEG;
</pre>
					</exhibit>
					<p>
						The value of the INT SHALL be greater than 0 if it is not null.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (INT.POS x) where x.nonNull {
  x.greaterThan(0);
  x.isZero.not;
};</pre>
					</exhibit>
					<prop id="prop-INT.NONNEG.isZero" base="prop-QTZ.isZero" render="false" role="fixedValue" fixedValue="false"/>
				</div3>
			</div2>
			<div2>
				<head>Flavors of PQ</head>
				<div3 id="dt-PQ.TIME">
					<anchor id="PQ.TIME"/>
					<head>LengthOfTime (PQ.TIME)</head>
					<p>
						<emph role="strong">Definition:     </emph>
						<emph>PQ.TIME</emph> constraints <termref ref="dt-PQ">PQ</termref> so that it has units that describe a period of time.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
flavor LengthOfTime alias PQ.TIME constrains PQ;
</pre>
					</exhibit>
					<p>
						The units SHALL be some UCUM code that refers to a measurement of time. Translations are not allowed.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (PQ.TIME x, PQ y) where x.nonNull.and(y.unit.equal("s")) {
  x.isComparableTo(y);
  x.translation.isEmpty;
};</pre>
					</exhibit>
					<prop id="prop-PQ.TIME.unit" base="prop-PQ.unit" render="false" valueSet="UV.DT.PQ.TIME.Unit"/>
					<prop id="prop-PQ.TIME.translation" base="prop-PQ.translation" render="false" role="exclude"/>
				</div3>
			</div2>
			<div2>
				<head>Flavors of TS</head>
				<div3 id="dt-TS.DATE">
					<anchor id="TS.DATE"/>
					<head>Date (TS.DATE)</head>
					<p>
						<emph role="strong">Definition:     </emph>
						<!-- Lloyd: Can we add "Allows for partial dates"? -->
						<emph>TS.DATE</emph> constrains <termref ref="dt-TS">TS</termref>  so that it only contains a date value.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
flavor Date alias TS.DATE constrains TS;
</pre>
					</exhibit>
					<p>
						If the value is not null, there SHALL be 8 or fewer digits, and there can be no timezone. This flavor is specific
						to the gregorian calendar.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (TS.DATE x) where x.nonNull {
  x.timezone.isNull;
  x.precision.lessOrEqual(8);
  x.calendar.implies(Calendar.GREG);
};</pre>
					</exhibit>
					<p>
						The string literal representation of this form is YYYY[MM[DD]].
					</p>
					<prop id="prop-TS.DATE.timezone" base="prop-TS.timezone" render="false" role="exclude"/>
					<prop id="prop-TS.DATE.precision" base="prop-TS.precision" render="false" role="fixedSet">
						<fixed value="4"/>
						<fixed value="6"/>
						<fixed value="8"/>
					</prop>
				</div3>
				<div3 id="dt-TS.DATE.FULL">
					<anchor id="TS.DATE.FULL"/>
					<head>FullDate (TS.DATE.FULL)</head>
					<p>
						<emph role="strong">Definition:     </emph>
						<emph>TS.DATE.FULL</emph> constrains <termref ref="dt-TS.DATE">TS.DATE</termref>  so that it contains a reference to a particular day.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
flavor FullDate alias TS.DATE.FULL constrains TS.DATE;
</pre>
					</exhibit>
					<p>
						If the value is not null, there SHALL be 8 digits in the literal form, with no timezone. This flavor is specific
						to the gregorian calendar.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (TS.DATE.FULL x) where x.nonNull {
  x.precision.equal(8);
};</pre>
					</exhibit>
					<p>
						The string literal representation of this form is YYYYMMDD.
					</p>
					<prop id="prop-TS.DATE.FULL.precision" base="prop-TS.DATE.precision" render="false" role="fixedValue" fixedValue="8"/>
				</div3>
				<div3 id="dt-TS.DATETIME">
					<anchor id="TS.DATETIME"/>
					<head>DateTime (TS.DATETIME)</head>
					<p>
						<emph role="strong">Definition:     </emph>
						<emph>TS.DATETIME</emph> constrains a <termref ref="dt-TS">TS</termref>  so that it is not more precise
						than seconds.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
flavor DateTime alias TS.DATETIME constrains TS;
</pre>
					</exhibit>
					<p>
						If the value is not null, there SHALL be 14 or less digits, and there can be a timezone. This flavor is specific
						to the gregorian calendar.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (TS.DATETIME x) where x.nonNull {
  x.precision.lessOrEqual(14);
  x.calendar.implies(Calendar.GREG);
};</pre>
					</exhibit>
					<p>
						The string literal representation of this form is YYYY[MM[DD[hh[mm[ss]]]]][+/-ZZZZ].
					</p>
					<prop id="prop-TS.DATETIME.precision" base="prop-TS.precision" render="false" role="fixedSet">
						<fixed value="4"/>
						<fixed value="6"/>
						<fixed value="8"/>
						<fixed value="10"/>
						<fixed value="12"/>
						<fixed value="14"/>
					</prop>
				</div3>
				<div3 id="dt-TS.DATETIME.FULL">
					<anchor id="TS.DATETIME.FULL"/>
					<head>FullDateTime (TS.DATETIME.FULL)</head>
					<p>
						<emph role="strong">Definition:     </emph>
						<emph>TS.DATETIME.FULL</emph> constrains <termref ref="dt-TS.DATETIME">TS.DATETIME</termref> so that it contains a reference to a particular second with a timezone.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
flavor FullDateTime alias TS.DATETIME.FULL constrains TS.DATETIME;
</pre>
					</exhibit>
					<p>
						If the value is not null, there SHALL be 14 digits in the literal form. There SHALL be a timezone. This flavor
						is specific to the gregorian calendar.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (TS.DATETIME.FULL x) where x.nonNull {
  x.precision.equal(14);
  x.timezone.nonNull;
};</pre>
					</exhibit>
					<p>
						The string literal representation of this form is YYYYMMDDhhmmss+/-ZZZZ.
					</p>
					<prop id="prop-TS.DATETIME.FULL.precision" base="prop-TS.DATETIME.precision" render="false" role="fixedValue" fixedValue="14"/>
				</div3>
				<div3 id="dt-TS.INSTANT">
					<anchor id="TS.INSTANT"/>
					<head>InstantInTime (TS.INSTANT)</head>
					<p>
						<emph role="strong">Definition:     </emph>
						<emph>TS.INSTANT</emph> constrains <termref ref="dt-TS.DATETIME">TS.DATETIME</termref> so that it contains a reference to a particular millisecond with a timezone.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
flavor InstantInTime alias TS.INSTANT constrains TS.DATETIME;
</pre>
					</exhibit>
					<p>
						If the value is not null, there SHALL be 17 digits in the literal form. There SHALL be a timezone. This flavor
						is specific to the gregorian calendar.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (TS.DATETIME.FULL x) where x.nonNull {
  x.precision.equal(17);
  x.timezone.nonNull;
};</pre>
					</exhibit>
					<p>
						The string literal representation of this form is YYYYMMDDhhmmss.zzz+/-ZZZZ.
					</p>
					<prop id="prop-TS.INSTANT.precision" base="prop-TS.DATETIME.precision" render="false" role="fixedValue" fixedValue="17"/>
				</div3>
				<!-- 				<dt id="dt-TS.BIRTH" longname="BirthDate" shortname="TS.BIRTH" constrains="dt-TS" flavor="true" access="public">
					<definition>
						<dtname/> constrains <dtref ref="dt-TS"/> so that it refers to a birth date.
					</definition>
					<p>
						 The generally accepted 
						convention for birth dates is either a year, a particular day, or a fully 
						specified date time may be known. 
					</p>
					<dtdl for="dt-TS.BIRTH" xml:space="preserve">
flavor BirthDate alias TS.BIRTH constrains TS;
</dtdl>
					<p>
						If the value is not null, there SHALL either be a year, a particular day, or a fully specified date time specified.
					</p>
					<constraint>
                                        <dtdl xml:space="preserve">
invariant (TS.BIRTH x) where x.nonNull {
  x.timezone.isNull.implies(x.precision.equal(8).or(x.precision.equal(4)).or(
   x.timezone.nonNull.implies(x.precision.equal(14)));
};</dtdl></constraint>					
					<p>
						The string literal representation of this form is YYYY[MMDD[hhmmss+/-ZZZZ]].
					</p>
				</dt> -->
			</div2>
			<div2>
				<head>Flavors of IVL</head>
				<div3 id="dt-IVL.LOW">
					<anchor id="IVL.LOW"/>
					<head>IntervalLow (IVL.LOW)</head>
					<p>
						<emph role="strong">Definition:     </emph>
						<emph>IVL.LOW</emph> constrains <termref ref="dt-IVL">IVL</termref> so that low is provided and lowClosed is true.
						All other properties are prohibited.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
flavor IntervalLow alias IVL.LOW constrains IVL&lt;T&gt;;
</pre>
					</exhibit>
					<p>
						If the value is not null, low SHALL be provided and lowClosed SHALL be true. high and highClosed are prohibited.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (IVL.LOW x) where x.nonNull {
  x.low.nonNull;
  x.lowClosed;
  x.high.isNull;
  x.highClosed.isNull;
};</pre>
					</exhibit>
					<prop id="prop-IVL.LOW.low" base="prop-IVL.low" render="false" mandatory="true"/>
					<prop id="prop-IVL.LOW.lowClosed" base="prop-IVL.lowClosed" render="false" role="fixedValue" fixedValue="true"/>
					<prop id="prop-IVL.LOW.high" base="prop-IVL.high" render="false" role="exclude"/>
					<prop id="prop-IVL.LOW.highClosed" base="prop-IVL.highClosed" render="false" role="exclude"/>
				</div3>
				<div3 id="dt-IVL.HIGH">
					<anchor id="IVL.HIGH"/>
					<head>IntervalHigh (IVL.HIGH)</head>
					<p>
						<emph role="strong">Definition:     </emph>
						<emph>IVL.HIGH</emph> constrains <termref ref="dt-IVL">IVL</termref> so that high is provided and highClosed is true.
						All other properties are prohibited.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
flavor IntervalHigh alias IVL.HIGH constrains IVL&lt;T&gt;;
</pre>
					</exhibit>
					<p>
						If the value is not null, high SHALL be provided and highClosed SHALL be true. low and lowClosed SHALL be null.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (IVL.HIGH x) where x.nonNull {
  x.high.nonNull;
  x.highClosed;
  x.low.isNull;
  x.lowClosed.isNull;
};</pre>
					</exhibit>
					<prop id="prop-IVL.HIGH.low" base="prop-IVL.low" render="false" role="exclude"/>
					<prop id="prop-IVL.HIGH.lowClosed" base="prop-IVL.lowClosed" render="false" role="exclude"/>
					<prop id="prop-IVL.HIGH.high" base="prop-IVL.high" render="false" mandatory="true"/>
					<prop id="prop-IVL.HIGH.highClosed" base="prop-IVL.highClosed" render="false" role="fixedValue" fixedValue="true"/>
				</div3>
				<div3 id="dt-IVL.WIDTH">
					<anchor id="IVL.WIDTH"/>
					<head>IntervalWidth (IVL.WIDTH)</head>
					<p>
						<emph role="strong">Definition:     </emph>
						<emph>IVL.WIDTH</emph> constrains <termref ref="dt-IVL">IVL</termref> so that width is mandatory and low, lowClosed, high and highClosed are prohibited.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
flavor IntervalWidth alias IVL.WIDTH constrains IVL&lt;T&gt;;
</pre>
					</exhibit>
					<p>
						if the value is not null, Width SHALL be provided. low, lowClosed, high and highClosed  SHALL be null.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (IVL.WIDTH x) where x.nonNull {
  x.width.nonNull;
  x.low.isNull;
  x.lowClosed.isNull;
  x.high.isNull;  /* strictly this is superfluous */
  x.highClosed.isNull;
};</pre>
					</exhibit>
					<prop id="prop-IVL.WIDTH.low" base="prop-IVL.low" render="false" role="exclude"/>
					<prop id="prop-IVL.WIDTH.lowClosed" base="prop-IVL.lowClosed" render="false" role="exclude"/>
					<prop id="prop-IVL.WIDTH.high" base="prop-IVL.high" render="false" role="exclude"/>
					<prop id="prop-IVL.WIDTH.highClosed" base="prop-IVL.highClosed" render="false" role="exclude"/>
					<prop id="prop-IVL.WIDTH.width" base="prop-IVL.width" render="false" mandatory="true"/>
				</div3>
			</div2>
			<div2>
				<head>Flavors of URG</head>
				<div3 id="dt-URG.LOW">
					<anchor id="URG.LOW"/>
					<head>UncertainRangeLow (URG.LOW)</head>
					<p>
						<emph role="strong">Definition:     </emph>
						<emph>URG.LOW</emph> constrains <termref ref="dt-URG">URG</termref> so that low and lowClosed are required.
						high and highClosed are prohibited.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
flavor UncertainRangeLow alias URG.LOW constrains URG&lt;T&gt;;
</pre>
					</exhibit>
					<p>
						If the value is not null, range.low SHALL be provided and range.lowClosed SHALL be true. range.high and range.highClosed SHALL be null.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (URG.LOW x) {
  exists(IVL.LOW r) {
    x.range.equal(r);
  }
};</pre>
					</exhibit>
					<prop id="prop-URG.LOW.range" base="prop-URG.range" render="false" type="IVL.LOW&lt;T&gt;"/>
				</div3>
				<div3 id="dt-URG.HIGH">
					<anchor id="URG.HIGH"/>
					<head>UncertainRangeHigh (URG.HIGH)</head>
					<p>
						<emph role="strong">Definition:     </emph>
						<emph>URG.HIGH</emph> constrains <termref ref="dt-URG">URG</termref> so that high and highClosed are required.
						low and lowClosed are prohibited.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
flavor UncertainRangeHigh alias URG.HIGH constrains URG&lt;T&gt;;
</pre>
					</exhibit>
					<p>
						If the value is not null, high SHALL be provided and highClosed SHALL be true. low and lowClosed SHALL be null.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (URG.HIGH x) where x.unknown {
  exists(IVL.HIGH r) {
    x.range.equal(r);
  }
};</pre>
					</exhibit>
					<prop id="prop-URG.HIGH.range" base="prop-URG.range" render="false" type="IVL.HIGH&lt;T&gt;"/>
				</div3>
			</div2>
			<div2>
				<head>Flavors of GTS</head>
				<div3 id="dt-GTS.BOUNDEDPIVL">
					<anchor id="GTS.BOUNDEDPIVL"/>
					<head>BoundedPeriodicInterval (GTS.BOUNDEDPIVL)</head>
					<p>
						<emph role="strong">Definition:     </emph>
						<emph>GTS.BOUNDEDPIVL</emph> constrains <termref ref="dt-QSI">QSI</termref>&lt;<termref ref="dt-TS">TS</termref>&gt; (GTS) so that it only allows an intersection of <termref ref="dt-IVL">IVL</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;
						and <termref ref="dt-PIVL">PIVL</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;. 
					</p>
					<p>
						This allows a system to capture a frequency together with an outer time boundary
						and is useful for things like dosage instructions.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
flavor BoundedPeriodicInterval alias GTS.BOUNDEDPIVL constrains QSI&lt;TS&gt;;
</pre>
					</exhibit>
					<p>
						The Bounded PIVL SHALL contain 2 terms. One of the terms SHALL be an <termref ref="dt-IVL">IVL</termref>&lt;<termref ref="dt-TS">TS</termref>&gt; and one
						SHALL be a <termref ref="dt-PIVL">PIVL</termref>&lt;<termref ref="dt-TS">TS</termref>&gt;.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant (GTS.BOUNDEDPIVL x) where x.nonNull {
  x.dataType.equals(QSI&lt;TS&gt;);
  ((QSI&lt;TS&gt;)x).terms.cardinality.equal(2);
  exists(IVL&lt;TS&gt; y) {((QSI&lt;TS&gt;)x).terms.contains(y)};
  exists(PIVL&lt;TS&gt; z) {((QSI&lt;TS&gt;)x).terms.contains(z)};  
};</pre>
					</exhibit>
				</div3>
			</div2>
		</div1>
	</body>
	<back>
		<div1 id="informativetypes">
			<head>Informative Types</head>
			<div2 id="dt-PPD">
				<anchor id="PPD"/>
				<head>ParametricProbabilityDistribution (PPD) specializes T</head>
				<parameter name="T" type="QTY"/>
				<p>
					<emph role="strong">Definition:     </emph>
					A generic data type extension specifying uncertainty of quantitative
					data using a distribution function and its parameters. 
				</p>
				<p>
					Aside from the 
					specific parameters of the distribution, a mean (expected value) and 
					standard deviation is always given to help maintain a minimum layer
					of interoperability if receiving applications cannot process a
					given probability distribution.
				</p>
				<table id="dt-PPD-prop-summary">
					<caption>Property Summary of
      ParametricProbabilityDistribution</caption>
					<col width="79"/>
					<col width="60"/>
					<col width="413"/>
					<thead>
						<tr>
							<th>Name</th>
							<th>Type</th>
							<th>Description</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>
								<termref ref="prop-PPD.standardDeviation">standardDeviation</termref>
							</td>
							<td>
								<termref ref="dt-T.diffType">T.diffType</termref>
							</td>
							<td>
							The root-mean-square deviation of the values from the mean
						</td>
						</tr>
						<tr>
							<td>
								<termref ref="prop-PPD.distributionType">distributionType</termref>
							</td>
							<td>
								<termref ref="dt-CS">CS</termref>
							</td>
							<td>
							A code specifying the type of probability distribution. 
						</td>
						</tr>
					</tbody>
				</table>
				<exhibit role="dtdl" id="dtdl-PPD">
					<anchor id="dtdl-PPD"/>
					<caption/>
					<pre>
template&lt;QTY T&gt;
type ParametricProbabilityDistribution&lt;T&gt; alias PPD&lt;T&gt; specializes T {
   T.diffType  standardDeviation;
   CS          distributionType;
   literal  ST.SIMPLE;
};</pre>
				</exhibit>
				<!-- 
Gunther: The following properties are not documented:
   IVL&lt;T&gt;      confidenceInterval(REAL p);
   REAL        probability(IVL&lt;T&gt; x);
   PPD&lt;T&gt;      times(REAL x);
 -->
				<p>
					For example, the most common college entrance exam in the United
					States is the SAT, which includes three parts: reading, math and writing. 
					Each part has a minimum score of 400 (no questions answered
					correctly) and a perfect score of 800. In 1998, according to the
					College Board, 1,172,779 college-bound seniors took the test. The mean
					score for the math portion of the test was 512, and the standard
					deviation 112. These parameter values (512, 112), tagged as the normal
					distribution parameters, paint a pretty good picture of test score
					distribution. In most cases, there is no need to specify all
					1-million+ points of data when just 2 parameters will do!
				</p>
				<graphic source="graphics/DT-PPD-ex1.gif" alt="Example for a parametric probability distribution"/>
				<p>
					Note that the normal distribution is only one of several distributions
					defined for HL7.
				</p>
				<exhibit role="dtdl" id="dtdl-PPD">
					<anchor id="dtdl-PPD"/>
					<caption/>
					<pre>
invariant (PPD&lt;T&gt; x)  {
  x.datatype.implies(INT).not;
  x.datatype.implies(RTO).not;
};</pre>
				</exhibit>
				<p>
					<emph>PPD</emph> SHALL only be applied to value domains that have a continuous distribution
					(<termref ref="dt-REAL">REAL</termref>, <termref ref="dt-PQ">PQ</termref>, <termref ref="dt-MO">MO</termref>, and
					<termref ref="dt-TS">TS</termref>). Uncertainty (<emph>PPD</emph>) MAY be applied to the numerator
					and denominator of a <termref ref="dt-RTO">RTO</termref> separately.
				</p>
				<p>
					Since a <emph>PPD</emph> specializes T, a simple T value is
					the mean (expected value or first moment) of the probability
					distribution. Applications that cannot deal with distributions will
					take the simple T value neglecting the uncertainty. That simple value
					of type T is also used to standardize the data for computing the
					distribution.
					</p>
				<!-- deleted per Jay's suggestion - how is this valuable to the definition of the type? 
				<p>
					Probability distributions are defined over integer or real numbers and
					normalized to a certain reference point (typically zero) and reference
					unit (e.g., <propref ref='prop-PPD.standardDeviation'/> = 1).
					When other quantities defined in
					this specification are used as base types, the mean and the
					<propref ref='prop-PPD.standardDeviation'/> are used to scale the
					probability distribution. For example,
					if a <dtref ref='dt-PPD_PQ'/> for a length is given with mean 20 ft
					and a <propref ref='prop-PPD.standardDeviation'/> of 2 in,
					the normalized distribution function
					<var>f</var>(<var>x</var>) that maps a real number <var>x</var>
					to a probability density would be translated to
					<emph>f</emph>&prime;(<emph>x</emph>&prime;) that maps
					a length <emph>x</emph>&prime; to a probability density as
					<emph>f</emph>&prime;(<emph>x</emph>&prime;) =
					<emph>f</emph>((<emph>x</emph>&prime; - &mu;) / &sigma;).
				</p> -->
				<p>
					Where applicable, <emph>PPD</emph> conforms to
					the ISO <emph>Guide to the Expression of Uncertainty in
					Measurement</emph> (GUM) as reflected by NIST publication 1297
					<emph>Guidelines for Evaluating and Expressing the Uncertainty of NIST
					Measurement Results</emph>. <emph>PPD</emph> does not
					describe how uncertainty is to be evaluated but only how it is
					expressed. The concept of "standard uncertainty" as set forth by the
					ISO GUM corresponds to <termref ref="prop-PPD.standardDeviation">standardDeviation</termref>.
				</p>
				<div3 id="prop-PPD.standardDeviation">
					<head>Standard Deviation (standardDeviation) : <termref ref="dt-T.diffType">T.diffType</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
							The root-mean-square deviation of the values from the mean
						</p>
					<p>
							The <emph>standardDeviation</emph> is the primary measure of variance/uncertainty of the value,
							computed as the square
							root of the sum of the squares of the differences between the data
							points and the mean. <emph>standardDeviation</emph> is used to normalize the
							data for computing the distribution function. Applications that cannot
							deal with probability distributions can still get an idea about the
							confidence level by looking at <emph>standardDeviation</emph>.
						</p>
					<p>
						<emph>standardDeviation</emph> is
							a specialization of <termref ref="dt-QTY">QTY</termref> (from T.diffType)
							that expresses differences between values of type T. If T is
							<termref ref="dt-REAL">REAL</termref> or <termref ref="dt-INT">INT</termref>,
							T.diffType is also <termref ref="dt-REAL">REAL</termref> or <termref ref="dt-INT">INT</termref>
							respectively. However if T is <termref ref="dt-TS">TS</termref>,
							T.diffType is a <termref ref="dt-PQ">PQ</termref> in the dimension
							of time.
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
invariant(PPD x) {
   x.standardDeviation.dataType.implies(T.diffType);
};</pre>
					</exhibit>
					<!--
						<p>
							The standard deviation is what ISO GUM calls "standard uncertainty."
						</p>
  -->
				</div3>
				<div3 id="prop-PPD.distributionType">
					<head>Probability Distribution Type (distributionType) : <termref ref="dt-CS">CS</termref>
					</head>
					<p>
						<emph role="strong">Definition:     </emph>
							A code specifying the type of probability distribution. 
						</p>
					<p>	Possible
							values for <emph>distributionType</emph> are as shown in the attached table. The NULL value (unknown)
							for the type code indicates that the probability distribution type is
							unknown. In that case, <termref ref="prop-PPD.standardDeviation">standardDeviation</termref>
							has the meaning of an informal guess.
						</p>
					<p>
						<tabref ref="domain-ProbabilityDistributionType"/> 
							lists the 
							probability distributions defined for this specification. Many distribution types are defined in
							terms of special parameters (e.g., the parameters &#945; and &#946;
							for the &#947;-distribution, number of degrees of freedom for the
							<emph>t</emph>-distribution, etc.).  For all distribution types,
							however, the mean and standard deviation are defined. 
							<!-- FIXME: Paul Schluter has shown that this doesn't work:
							The PPD data type is specified with the parameters mean and standard
							distribution only. The definition column contains the relationship
							between the special parameters and the mean &mu; and standard
							deviation &sigma;. -->
					</p>
					<table id="domain-ProbabilityDistributionType">
						<caption>Concept Domain ProbabilityDistributionType. ValueSet OID:  2.16.840.1.113883.11.10747. CodeSystem "ProbabilityDistributionType", OID: 2.16.840.1.113883.5.1020, Owner: HL7</caption>
						<thead>
							<tr valign="bottom">
								<th>lvl</th>
								<th>code</th>
								<th>name</th>
								<th>definition</th>
							</tr>
						</thead>
						<tr valign="top">
							<td>1</td>
							<td>(NULL)</td>
							<td>(NULL)</td>
							<td>
									Used to indicate that the mean is estimated without any closer
									consideration of its probability distribution. In this case, the
									meaning of the standard deviation is not crisply defined. However,
									interpretation should be along the lines of the normal distribution,
									e.g., the interval covered by the mean ±1 standard 
									deviation should be at the level of about two thirds confidence.
								</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>U</td>
							<td>uniform</td>
							<td>
									The uniform distribution assigns a constant probability over the
									entire interval of possible outcomes, while all outcomes outside this
									interval are assumed to have zero probability. The width of this
									interval is 2 s v3. Thus, the uniform distribution assigns
									the probability densities <emph>f</emph>(x) = (2 s v3)<emph role="sup">-1</emph>
									to values µ - s v3 = x = µ + s v3 and <emph>f</emph>(x) = 0 otherwise.
								</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>N</td>
							<td>normal (Gaussian)</td>
							<td>
									This is the well-known bell-shaped normal distribution. Because of the
									central limit theorem, the normal distribution is the distribution of
									choice for an unbounded random variable that is an outcome of a
									combination of many stochastic processes. Even for values bounded on a
									single side (i.e. greater than 0) the normal distribution may be
									accurate enough if the mean is "far away" from the bound of the scale
									measured in terms of standard deviations.
								</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>LN</td>
							<td>log-normal</td>
							<td>
									The logarithmic normal distribution is used to transform skewed random
									variable X into a normally distributed random variable <emph>U</emph>
									= log <emph>X</emph>. The log-normal distribution can be specified
									with the properties mean µ and standard deviation s. Note
									however that mean µ and standard deviation s are the
									parameters of the raw value distribution, not the transformed
									parameters of the lognormal distribution that are conventionally
									referred to by the same letters. Those log-normal parameters µ<emph role="sub">
									log</emph> and s<emph role="sub">log</emph> relate to
									the mean µ and standard deviation s of the data value through
									s<emph role="sub">log</emph>
								<emph role="sup">2</emph> = log
									(s<emph role="sup">2</emph>/µ<emph role="sup">2</emph> + 1)
									and µlog = log µ - s<emph role="sub">log</emph>
								<emph role="sup">2</emph>/2.
								</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>G</td>
							<td>? (gamma)</td>
							<td>
									The gamma-distribution used for data that is skewed and bounded to the
									right, i.e. where the maximum of the distribution curve is located
									near the origin. The ?-distribution has two parameters a
									and ß. The relationship to mean µ and variance s<emph role="sup">2</emph> 
									is µ = a ß and s<emph role="sup">2</emph> = a ß<emph role="sup">2</emph>.
								</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>E</td>
							<td>exponential</td>
							<td>
									Used for data that describes extinction. The exponential distribution
									is a special form of ?-distribution where a = 1, hence,
									the relationship to mean µ and variance s<emph role="sup">2</emph> are µ = ß 
									and s<emph role="sup">2</emph> = ß<emph role="sup">2</emph>.
								</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>X2</td>
							<td>?</td>
							<td>
									Used to describe the sum of squares of random variables that occurs
									when a variance is estimated (rather than presumed) from the
									sample. The only parameter of the ?<emph role="sup">2</emph>-distribution 
									is ?, so called the
									<emph>number of degrees of freedom</emph> (which is the number of
									independent parts in the sum). The ?<emph role="sup">2</emph>-distribution is 
									a special type of ?-distribution with parameter a = ? /2 and ß
									= 2. Hence, µ = ? and s<emph role="sup">2</emph> = 2 ?.
								</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>T</td>
							<td>t (Student)</td>
							<td>
									Used to describe the quotient of a normal random variable and the
									square root of a ?<emph role="sup">2</emph> random variable. The
									<emph>t</emph>-distribution has one parameter ?, the number of
									degrees of freedom. The relationship to mean µ and variance
									s<emph role="sup">2</emph> are: µ = 0 and s<emph role="sup">2</emph> 
									= ? / (? - 2)
								</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>F</td>
							<td>F</td>
							<td>
									Used to describe the quotient of two ?<emph role="sup">2</emph>
									random variables. The <emph>F</emph>-distribution has two parameters
									?<emph role="sub">1</emph> and ?<emph role="sub">2</emph>, which are the
									numbers of degrees of freedom of
									the numerator and denominator variable respectively. The relationship
									to mean µ and variance s<emph role="sup">2</emph> are: µ =
									?<emph role="sub">2</emph> / (?<emph role="sub">2</emph> - 2) and s
									<emph role="sup">2</emph> = (2 ?<emph role="sub">2</emph>
								<emph role="sup">2</emph> (?<emph role="sub">
									2</emph> + ?<emph role="sub">1</emph> - 2)) / (?<emph role="sub">1</emph>
									(?<emph role="sub">2</emph> - 2)<emph role="sup">2</emph>
									(?<emph role="sub">2</emph> - 4)).
									</td>
						</tr>
						<tr valign="top">
							<td>1</td>
							<td>B</td>
							<td>ß (beta)</td>
							<td>
									The beta-distribution is used for data that is bounded on both sides
									and may or may not be skewed (e.g., occurs when probabilities are
									estimated).  Two parameters a and ß are available to adjust
									the curve. The mean µ and variance s<emph role="sup">2</emph>
									relate as follows: µ = a / (a + ß) and
									(s<emph role="sup">2</emph> = a ß/((a +
									ß)<emph role="sup">2</emph> (a + ß + 1)).
								</td>
						</tr>
					</table>
					<p>
							The three distribution-types <emph>unknown</emph> (NULL),
							<emph>uniform</emph> and <emph>normal</emph> SHALL be supported by
							every system that claims to support <emph>PPD</emph>. All other distribution
							types are optional. When a system interpreting a <emph>PPD</emph>
							representation encounters a distribution type that it does not
							recognize, it SHOULD map this type to the unknown (NULL) distribution-type.
						</p>
				</div3>
				<div3 id="prop-PPD.literal">
					<head>Literal Form</head>
					<p>
							 The general syntax of the literal form for <emph>PPD</emph> is as follows:
						</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
PPD&lt;T&gt;.literal ST.SIMPLE {
   PPD&lt;T&gt;  : T "(" type QTY ")"  { ((T)$).equal($1);
                                   $.distributionType.equal($3);
                                   $.standardDeviation.equal($4); };
   CV type : ST                  { $.value.equal($1);
                                   $.codeSystem.equal(2.16.840.1.113883.5.1020); };
};</pre>
					</exhibit>
					<p>
							Examples: an example for a <termref ref="dt-PPD_REAL">PPD&lt;REAL&gt;</termref>
							is "1.23(N0.005)" for a normal <termref ref="prop-PPD.distributionType">distributionType</termref>
							around 1.23 with a <termref ref="prop-PPD.standardDeviation">standardDeviation</termref> of 0.005.
							An example for a <termref ref="dt-PPD_PQ">PPD&lt;PQ&gt;</termref> is "1.23 m (5 mm)" for
							an unknown <termref ref="prop-PPD.distributionType">distributionType</termref> around the
							length 1.23 meter with a <termref ref="prop-PPD.standardDeviation">standardDeviation</termref>
							of 5 millimeter. An example for a <termref ref="dt-PPD_TS">PPD&lt;TS&gt;</termref>
							is "2000041113(U4 h)" for a	uniform
							<termref ref="prop-PPD.distributionType">distributionType</termref> around April 11, 2000
							at 1pm with <termref ref="prop-PPD.standardDeviation">standardDeviation</termref> of 4 hours.
						</p>
				</div3>
				<!-- FIXME!!! -->
			</div2>
			<div2 id="dt-PPD_REAL">
				<anchor id="PPD&lt;REAL&gt;"/>
				<head>ParametricProbabilityDistribution&lt;RealNumber&gt; (PPD&lt;REAL&gt;) specializes <termref ref="dt-PPD">PPD</termref>
				</head>
				<exhibit role="dtdl" id="dtdl-PPD_REAL">
					<anchor id="dtdl-PPD_REAL"/>
					<caption/>
					<pre>
type ParametricProbabilityDistribution&lt;RealNumber&gt; alias PPD&lt;REAL&gt; specializes PPD&lt;T&gt;;</pre>
				</exhibit>
				<p>
					The parametric probability distribution of real numbers is fully defined by
					the generic data type.
					However, there are some special considerations about literal representations
					and conversions of probability distributions over <termref ref="dt-REAL">REAL</termref>s, which are
					specified in this section.
				</p>
				<div3>
					<head>
						Converting a real number (REAL) to an uncertain real number
						(PPD&lt;REAL&gt;)
					</head>
					<p>
						When converting a <termref ref="dt-REAL">REAL</termref> into a <termref ref="dt-PPD_REAL">PPD&lt;REAL&gt;</termref>,
						<termref ref="prop-PPD.standardDeviation">PPD.standardDeviation</termref> is calculated from the
						<termref ref="dt-REAL">REAL</termref> value's order of magnitude and
						<termref ref="prop-REAL.precision">REAL.precision</termref>
						(number of significant digits).
						Let <emph>x</emph> be a <termref ref="dt-REAL">REAL</termref> with
						<termref ref="prop-REAL.precision">REAL.precision</termref> <emph>n</emph>. We can
						determine the order of magnitude <emph>e</emph> of <emph>x</emph> as
						<emph>e</emph> = log10 |<emph>x</emph>| where <emph>e</emph> is rounded to
						the next integer that is closer to zero (special case: if <emph>x</emph>
						is zero, <emph>e</emph> is zero).  The value of the least significant digit
						<emph>l</emph> is then <emph>l</emph> = 10<emph role="sup">e-n</emph>
						and the <termref ref="prop-PPD.standardDeviation">PPD.standardDeviation</termref> &#963; = <emph>l</emph> /
						<emph>2</emph>.
					</p>
					<table id="PPD-standard-deviation-examples">
						<caption>Examples of standard deviations computed from precision p and order of magnitude e</caption>
						<thead>
							<tr>
								<th rowspan="1" colspan="1">Representation</th>
								<th rowspan="1" colspan="1">x</th>
								<th rowspan="1" colspan="1">e</th>
								<th rowspan="1" colspan="1">p</th>
								<th rowspan="1" colspan="1">e - p + 1</th>
								<th rowspan="1" colspan="1">l</th>
								<th rowspan="1" colspan="1">&#963;</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td rowspan="1" colspan="1">0</td>
								<td rowspan="1" colspan="1">0</td>
								<td rowspan="1" colspan="1">(0)</td>
								<td rowspan="1" colspan="1">1</td>
								<td rowspan="1" colspan="1">0</td>
								<td rowspan="1" colspan="1">1</td>
								<td rowspan="1" colspan="1">0.5</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">1</td>
								<td rowspan="1" colspan="1">1</td>
								<td rowspan="1" colspan="1">0</td>
								<td rowspan="1" colspan="1">1</td>
								<td rowspan="1" colspan="1">0</td>
								<td rowspan="1" colspan="1">1</td>
								<td rowspan="1" colspan="1">0.5</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">2</td>
								<td rowspan="1" colspan="1">2</td>
								<td rowspan="1" colspan="1">0</td>
								<td rowspan="1" colspan="1">1</td>
								<td rowspan="1" colspan="1">0</td>
								<td rowspan="1" colspan="1">1</td>
								<td rowspan="1" colspan="1">0.5</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">9</td>
								<td rowspan="1" colspan="1">9</td>
								<td rowspan="1" colspan="1">0</td>
								<td rowspan="1" colspan="1">1</td>
								<td rowspan="1" colspan="1">0</td>
								<td rowspan="1" colspan="1">1</td>
								<td rowspan="1" colspan="1">0.5</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">10</td>
								<td rowspan="1" colspan="1">10</td>
								<td rowspan="1" colspan="1">1</td>
								<td rowspan="1" colspan="1">2</td>
								<td rowspan="1" colspan="1">0</td>
								<td rowspan="1" colspan="1">1</td>
								<td rowspan="1" colspan="1">0.5</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">100</td>
								<td rowspan="1" colspan="1">100</td>
								<td rowspan="1" colspan="1">2</td>
								<td rowspan="1" colspan="1">3</td>
								<td rowspan="1" colspan="1">0</td>
								<td rowspan="1" colspan="1">1</td>
								<td rowspan="1" colspan="1">0.5</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">1e+1</td>
								<td rowspan="1" colspan="1">10</td>
								<td rowspan="1" colspan="1">1</td>
								<td rowspan="1" colspan="1">1</td>
								<td rowspan="1" colspan="1">1</td>
								<td rowspan="1" colspan="1">10</td>
								<td rowspan="1" colspan="1">5</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">1e+2</td>
								<td rowspan="1" colspan="1">100</td>
								<td rowspan="1" colspan="1">2</td>
								<td rowspan="1" colspan="1">1</td>
								<td rowspan="1" colspan="1">2</td>
								<td rowspan="1" colspan="1">100</td>
								<td rowspan="1" colspan="1">50</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">10e+1</td>
								<td rowspan="1" colspan="1">100</td>
								<td rowspan="1" colspan="1">2</td>
								<td rowspan="1" colspan="1">2</td>
								<td rowspan="1" colspan="1">1</td>
								<td rowspan="1" colspan="1">10</td>
								<td rowspan="1" colspan="1">5</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">1.1</td>
								<td rowspan="1" colspan="1">1.1</td>
								<td rowspan="1" colspan="1">0</td>
								<td rowspan="1" colspan="1">2</td>
								<td rowspan="1" colspan="1">-1</td>
								<td rowspan="1" colspan="1">0.1</td>
								<td rowspan="1" colspan="1">0.05</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">10.1</td>
								<td rowspan="1" colspan="1">10.1</td>
								<td rowspan="1" colspan="1">1</td>
								<td rowspan="1" colspan="1">3</td>
								<td rowspan="1" colspan="1">-1</td>
								<td rowspan="1" colspan="1">0.1</td>
								<td rowspan="1" colspan="1">0.05</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">1.1e+2</td>
								<td rowspan="1" colspan="1">110</td>
								<td rowspan="1" colspan="1">2</td>
								<td rowspan="1" colspan="1">2</td>
								<td rowspan="1" colspan="1">1</td>
								<td rowspan="1" colspan="1">10</td>
								<td rowspan="1" colspan="1">5</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">1.1e-2</td>
								<td rowspan="1" colspan="1">0.011</td>
								<td rowspan="1" colspan="1">-2</td>
								<td rowspan="1" colspan="1">2</td>
								<td rowspan="1" colspan="1">-3</td>
								<td rowspan="1" colspan="1">0.001</td>
								<td rowspan="1" colspan="1">0.0005</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">1.1e-4</td>
								<td rowspan="1" colspan="1">0.00011</td>
								<td rowspan="1" colspan="1">-4</td>
								<td rowspan="1" colspan="1">2</td>
								<td rowspan="1" colspan="1">-5</td>
								<td rowspan="1" colspan="1">0.00001</td>
								<td rowspan="1" colspan="1">0.000005</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">10.1e-4</td>
								<td rowspan="1" colspan="1">0.00101</td>
								<td rowspan="1" colspan="1">-3</td>
								<td rowspan="1" colspan="1">3</td>
								<td rowspan="1" colspan="1">-5</td>
								<td rowspan="1" colspan="1">0.00001</td>
								<td rowspan="1" colspan="1">0.000005</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">0.1e-1</td>
								<td rowspan="1" colspan="1">0.01</td>
								<td rowspan="1" colspan="1">-2</td>
								<td rowspan="1" colspan="1">1</td>
								<td rowspan="1" colspan="1">-2</td>
								<td rowspan="1" colspan="1">0.01</td>
								<td rowspan="1" colspan="1">0.005</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">0.01e-1</td>
								<td rowspan="1" colspan="1">0.001</td>
								<td rowspan="1" colspan="1">-3</td>
								<td rowspan="1" colspan="1">1</td>
								<td rowspan="1" colspan="1">-3</td>
								<td rowspan="1" colspan="1">0.001</td>
								<td rowspan="1" colspan="1">0.0005</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">0.01e-2</td>
								<td rowspan="1" colspan="1">0.0001</td>
								<td rowspan="1" colspan="1">-4</td>
								<td rowspan="1" colspan="1">1</td>
								<td rowspan="1" colspan="1">-4</td>
								<td rowspan="1" colspan="1">0.0001</td>
								<td rowspan="1" colspan="1">0.00005</td>
							</tr>
							<tr>
								<td rowspan="1" colspan="1">0.00</td>
								<td rowspan="1" colspan="1">0</td>
								<td rowspan="1" colspan="1">(0)</td>
								<td rowspan="1" colspan="1">3</td>
								<td rowspan="1" colspan="1">-2</td>
								<td rowspan="1" colspan="1">0.01</td>
								<td rowspan="1" colspan="1">0.005</td>
							</tr>
						</tbody>
					</table>
				</div3>
				<div3 id="prop-PPD_REAL.literal">
					<head>Concise Literal Form</head>
					<p>
						Besides the generic literal form of <emph>PPD&lt;REAL&gt;</emph>, a
						concise literal form is defined for <emph>PPD&lt;REAL&gt;</emph> over real
						numbers. This concise literal form is defined such that
						<termref ref="prop-PPD.standardDeviation">PPD.standardDeviation</termref> can be expressed
						in terms of the least significant digit in the mantissa.
						This literal is defined as an extension of the <termref ref="dt-REAL">REAL</termref> literal:
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
PPD&lt;REAL&gt;.literal ST.SIMPLE {
   PPD&lt;REAL&gt; mantissa
           : REAL.mantissa "(" type QTY ")"  { ((T)$).equal($1);
                                                   $.distributionType.equal($3);
                                                   $.standardDeviation.equal($4); }
           | REAL.mantissa                   { $.equal($1);
                                               $.distributionType.equal($3);
                                               $.standardDeviation.equal(
                                                  $1.leastSignificantDigit.times(0.5)); };
   CS type : ST                              { $.value.equal($1);
                                               $.system.equal(2.16.840.1.113883.5.1019); };
};</pre>
					</exhibit>
					<p>
						Examples: "1.23e-3 (U5e-6)" is the uniform
						<termref ref="prop-PPD.distributionType">PPD.distributionType</termref> around 1.23
						× 10<emph role="sup">-3</emph> with 5 × 10<emph role="sup">-6</emph>
						 <termref ref="prop-PPD.standardDeviation">PPD.standardDeviation</termref> in generic
						literal form. "1.230(U5)e-3" is the same value in
						concise literal form.
					</p>
				</div3>
			</div2>
			<div2 id="dt-PPD_PQ">
				<anchor id="PPD&lt;PQ&gt;"/>
				<head>ParametricProbabilityDistribution&lt;PhysicalQuantity&gt; (PPD&lt;PQ&gt;) specializes <termref ref="dt-PPD">PPD</termref>
				</head>
				<p>
					<emph>PPD&lt;PQ&gt;</emph> is constructed from <termref ref="dt-PPD">PPD</termref>. However,
					recognizing that the <termref ref="prop-PQ.unit">PQ.unit</termref> can be factored
					from the boundaries, we add additional semantics and a
					separate literal form. The additional view of a <emph>PPD&lt;PQ&gt;</emph>
					is a probability distribution over real numbers with one unit.
				</p>
				<exhibit role="dtdl" id="dtdl-PPD_PQ">
					<anchor id="dtdl-PPD_PQ"/>
					<caption/>
					<pre>
type ParametricProbabilityDistribution&lt;PhysicalQuantity&gt; alias PPD&lt;PQ&gt; specializes PPD&lt;T&gt; {
   PPD&lt;REAL&gt; value;
   CS  unit;
};</pre>
				</exhibit>
				<p>
					The unit applies to both mean and <termref ref="prop-PPD.standardDeviation">PPD.standardDeviation</termref>.
				</p>
				<exhibit role="dtdl">
					<caption/>
					<pre>
invariant(PPD&lt;PQ&gt; x)
      where x.nonNull {
   x.value.nonNull;
   ((REAL)x.value).equal(((PQ)x).value);
   x.unit.equal(((PQ)x).unit);
   x.value.standardDeviation.equal(x.standardDeviation.value);
   x.standardDeviation.unit.equal(x.unit);
};</pre>
				</exhibit>
				<prop id="prop-ST.value" longname="Value" shortname="value" type="PPD&lt;REAL&gt;" render="false"/>
				<prop id="prop-ST.unit" longname="Unit" shortname="unit" type="CS" render="false"/>
				<div3 id="prop-PPD_PQ.literal">
					<head>Concise Literal Form</head>
					<p>
						A concise literal form for <emph>PPD&lt;PQ&gt;</emph> is defined based on
						the concise literal form of <termref ref="dt-PPD_REAL">PPD&lt;REAL&gt;</termref>
						where <termref ref="dt-REAL">REAL</termref> is the value. This
						literal is defined as an extension of the <termref ref="dt-PQ">PQ</termref> literal.
					</p>
					<exhibit role="dtdl">
						<caption/>
						<pre>
PPD&lt;PQ&gt;.literal ST.SIMPLE {
   PPD&lt;PQ&gt; : PPD&lt;REAL&gt; " " unit  { $.value.equal($1);
                                   $.unit.equal($3); }
};</pre>
					</exhibit>
					<p>
						Examples: "1.23e-3 m (N5e-6 m)" is the normal-distributed length of
						1.23 × 10<emph role="sup">-3</emph> m with 5 × 10<emph role="sup">-6</emph> m
						<termref ref="prop-PPD.standardDeviation">PPD.standardDeviation</termref> in generic literal
						form. "1.230(N5)e-3 m" is the same value in concise literal
						form. "1.23e-3(N0.005e-3) m " is also valid; it is the concise literal
						form for <emph>PPD&lt;PQ&gt;</emph> combined with the
						generic literal form for <termref ref="dt-PPD_REAL">PPD&lt;REAL&gt;</termref>.
					</p>
				</div3>
			</div2>
			<div2 id="dt-PPD_TS">
				<anchor id="PPD&lt;TS&gt;"/>
				<head>ParametricProbabilityDistribution&lt;PointInTime&gt; (PPD&lt;TS&gt;) specializes <termref ref="dt-PPD">PPD</termref>
				</head>
				<exhibit role="dtdl" id="dtdl-PPD_TS">
					<anchor id="dtdl-PPD_TS"/>
					<caption/>
					<pre>
type ParametricProbabilityDistribution&lt;PointInTime&gt; alias PPD&lt;TS&gt; specializes PPD&lt;T&gt;;</pre>
				</exhibit>
				<p>
					<emph>PPD&lt;TS&gt;</emph> is fully defined by the generic data type.
					<termref ref="prop-PPD.standardDeviation">PPD.standardDeviation</termref> is of type TS.diffType, which is a duration (a
					<termref ref="dt-PQ">PQ</termref> in the dimension of time).
				</p>
				<div3>
					<head>Converting <termref ref="dt-TS">TS</termref> to <emph>PPD&lt;TS&gt;</emph>
					</head>
					<p>
						When converting a <termref ref="dt-TS">TS</termref> into a <emph>PPD&lt;TS&gt;</emph>,
						<termref ref="prop-PPD.standardDeviation">PPD.standardDeviation</termref> is
						calculated from the <termref ref="dt-TS">TS</termref> value's order of magnitude
						and precision (number of significant digits) such that two
						<termref ref="prop-PPD.standardDeviation">PPD.standardDeviation</termref>s span the maximal time range of the digits not
						specified. For example, in 20000609 the unspecified digits are hour of
						the day and lower. All these digits together span a duration of 24
						hours, and thus, <termref ref="prop-PPD.standardDeviation">PPD.standardDeviation</termref> is 12 h, or half the span from
						20000609000000.0000... up to 20000609999999.9999... (= 20000610).
					</p>
					<p>
						This rule is different from that specified for <termref ref="dt-REAL">REAL</termref>
						in that the range of uncertainty lies 
						above the time value specified. This is to go with the common sense judgment 
						that June 9th spans all day of June 9th with noon as the center, not midnight.
					</p>
				</div3>
			</div2>
		</div1>
		<div1 id="RepresentationalProperties">
			<head>Representational Properties</head>
			<p>
			   This specification defines the semantics of the data types. In addition to the semantics,
			   HL7 defines several facets of data types that are not semantic in nature, but representational.
			   This section defines these properties and their applicability and scope. These properties never
			   participate in the evaluation of the equal or identical properties.
			</p>
			<!-- we attribute these properties to ANY, though they are not part of the semantic model of any -->
			<div2 id="prop-ANY.updateMode">
				<head>Update Mode (updateMode) : <termref ref="dt-CS">CS</termref>
				</head>
				<p>
					<emph role="strong">Definition:     </emph>
						This property allows a sending system to identify the role that the attribute plays in
						processing the instance that is being represented.
					</p>
				<p>
					Update Mode is fully defined and discussed in the "Core Principles of V3 Models" specification under "Update Mode"
					([<loc href="../coreprinciples/v3modelcoreprinciples.htm#coreP_Update_Mode" xlink-form="simple" show="embed" actuate="auto"/>]).
				</p>
				<exhibit role="dtdl">
					<caption/>
					<pre>
   CS  updateMode; 
</pre>
				</exhibit>
				<table id="domain-HL7UpdateMode">
					<caption>Concept Domain HL7UpdateMode. ValueSet OID:  2.16.840.1.113883.11.10018. CodeSystem "HL7UpdateMode", OID: 2.16.840.1.113883.5.57, Owner: HL7</caption>
					<thead>
						<tr valign="bottom">
							<th>lvl</th>
							<th>code</th>
							<th>name</th>
							<th>definition</th>
						</tr>
					</thead>
					<tr valign="top">
						<td>1</td>
						<td>A</td>
						<td>Add</td>
						<td>
							<p>The item was (or is to be) added, having not been present immediately before. (If it is already present, this may be treated as an error condition.)</p>
						</td>
					</tr>
					<tr valign="top">
						<td>1</td>
						<td>D</td>
						<td>Remove</td>
						<td>
							<p>The item was (or is to be) removed (sometimes referred to as deleted). If the item is part of a collection, delete any matching items.</p>
						</td>
					</tr>
					<tr valign="top">
						<td>1</td>
						<td>R</td>
						<td>Replace</td>
						<td>
							<p>
			    The item existed previously and has (or is to be) revised. (If an item does not already exist, this may be treated as an error condition.)
			  </p>
						</td>
					</tr>
					<tr valign="top">
						<td>1</td>
						<td>AR</td>
						<td>Add or Replace</td>
						<td>
							<p>
			    The item was (or is to be) either added or replaced. 
			  </p>
						</td>
					</tr>
					<tr valign="top">
						<td>1</td>
						<td>N</td>
						<td>No Change</td>
						<td>
							<p>
			    There was (or is to be) no change to the item. This is primarily used when this element has not changed, but
				other attributes in the instance have changed.
			  </p>
						</td>
					</tr>
					<tr valign="top">
						<td>1</td>
						<td>U</td>
						<td>Unknown</td>
						<td>
							<p>
			    	 It is not specified whether or what kind of change has occurred to the item, or whether the item is present as a reference or identifying property.
			  </p>
						</td>
					</tr>
					<tr valign="top">
						<td>1</td>
						<td>K</td>
						<td>Key</td>
						<td>
							<p>This item is part of the identifying information for the object that contains it.</p>
						</td>
					</tr>
				</table>
				<p>
					  UpdateMode SHALL only be applied to data type values when the value is an attribute of
					  a RIM class or an item in a collection that that is an attribute of a RIM Class. 
					  Because data values have neither identity nor state nor changing of state, 
					  update modes do not apply for the properties of data values; data values 
					  and their properties are never updated. 
					</p>
			</div2>
			<div2 id="prop-ANY.flavorId">
				<head>Flavor Id (flavorId) : <termref ref="dt-SET">SET</termref>&lt;<termref ref="dt-ST.SIMPLE">ST.SIMPLE</termref>&gt;</head>
				<p>
					<emph role="strong">Definition:     </emph>
						This property specifies the data type flavors that apply to this value.
					</p>
				<exhibit role="dtdl">
					<caption/>
					<pre>
   SET&lt;ST.SIMPLE&gt;  flavorId;
</pre>
				</exhibit>
				<p>
					  The full details concerning the use of data type flavors are discussed in the
					  Refinement, Constraint and Localization Specification. This property is used
					  to support instance validation. No other semantic or computational use SHALL
					  depend on the value of this property. If this value is populated, the data type
					  flavor(s) SHALL be a valid constraint on the type of the value.
					</p>
			</div2>
		</div1>
	</back>
</spec>
